


## MVP RAD
			



<a name="NOTE1"></a>
<a name="NOTE1_1"></a>


## Overview
<a name="overview_ELTTEXTE000308"></a>
WINDEV proposes an MVP RAD that generates the "table" and "form" windows as well as the necessary Presenter and Model classes.

The windows correspond to the Views of MVP.

The generated code is free and it can be adapted according to the requirements: it is the generation of the basic application skeleton.

**Caution**: This development mode uses OOP: it requires a good knowledge of these concepts. This development mode is an advanced development mode. 



<a name="NOTE2"></a>
<a name="NOTE2_1"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/us/WD.png) 

## How to?
<a name="how_ELTTEXTE000332"></a>


### The steps for generating the window
<a name="the_steps_for_generating_the_window_ELTPARAGRAPHE000032"></a>

To generate a window in "MVP RAD" mode: 

1. Click ![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=3&name=ico_nouveau.gif) in the quick access buttons: 

	- The creation window appears: click "Window" then "Window". 

	- The window creation wizard starts.




2. In the wizard: 

	- Click the "RAD" tab. 

	- Select the "MVP RAD" pattern. 

	- Select the type of window to generate (Form or Table). 

	- Validate the window creation wizard.

	- The MVP RAD generation wizard starts.  




3. In the wizard: 

	- Specify whether RAD must create a new Presenter class (option required if the MVP RAD was not already used). 

	- Specify whether RAD must create a new Model class (option required if the MVP RAD was not already used). 

	- Select the data file to use. 

	- Select the items to use. 

	- Specify whether RAD must create a new class for error management (option required if the MVP RAD was not already used). 

	- Customize (if necessary) the name of the classes that will be generated. 

	- Select the members of the model class that will be displayed in the window (the view). 

	- Specify the title and name of the window that will be generated. 




4. Validate the wizard. 



<a name="NOTE2_2"></a>


### The elements generated by RAD
<a name="the_elements_generated_rad_ELTPARAGRAPHE000064"></a>

When generating a Form window and a Table window on a data file named "MyExampleFile", the MVP RAD generates 6 classes and 2 windows.

The MVP RAD generates 2 "base" classes:

- **MBase**: base class of all the Model classes (M for Model). It contains the basic functionalities of the business code (which will be shared with the other model classes through inheritance).

- **CError**: class for managing the errors. This class centralizes the code for managing the errors that may be signaled by the different classes (business errors or database errors).




The MVP RAD also generates 2 classes of the "Model" layer, specific to the project:

- **MMyExampleFile**: class reflecting the business data. In this example, this class directly "maps" the structure of database "MyExampleFile" file (via the "mapping" attribute).

- **MArrayMyExampleFile**: model class for the table window. It contains an array of MMyExampleFile objects.




The MVP RAD also generates 2 classes of the "Presenter" layer, specific to the project.

- **PTableMyExampleFile**: manages the display of data in the view or table window.

- **PFormMyExampleFile**: manages the display of data in the view or form window.



<a name="NOTE2_3"></a>


### Managing the errors in the classes generated by the MVP RAD
<a name="managing_the_errors_the_classes_generated_the_mvp_rad_ELTPARAGRAPHE000086"></a>In the MVP RAD, the errors are supported via a **CError** class. Each procedure of the presenter expects a **CError** parameter. Therefore, the views can retrieve the possible errors generated by the presenter.


```wl
clError is CError
// Validation
IF NOT gclPresenter.bOK(clError) THEN
	Error(clError.FormatMessage())
	RETURN
END
```
Indeed, only the view displays the possible errors (and not the model or the presenter).

This error management mode (procedure that expects the **CError** parameter) allows for a more rigorous application development.

<a name="NOTE3"></a>
<a name="NOTE3_1"></a>


## WLanguage: Specific features used to simplify the MVP architecture
<a name="wlanguage_specific_features_used_simplify_the_mvp_architecture_ELTTEXTE000368"></a>


### Overview
<a name="overview_ELTPARAGRAPHE000099"></a>

To simplify the implementation of an MVP architecture, it is important to identify and understand the specific WLanguage elements:

- the **mapping** attribute (as well as the **MyMappedFile** and **MyUniqueMappedKey** keywords),

- the **associated** attribute,

- the **"Presenter"** attribute,

- the [RequestRefreshUI](../WDLang1/1000023899.md) and [RequestRefreshUIParent](../WDLang1/1000023900.md) functions, and the window (or report) refresh event.


The MVP RAD uses these features but they can be used in any type of architecture.


<a name="NOTE3_2"></a>


### "Mapping" attribute
<a name="mapping_attribute_ELTPARAGRAPHE000132"></a>

The **mapping** attribute is used to create a "direct link" between the class and the data file.

Example: 


```wl
MMyExampleFile is Class,mapping = MyExampleFile
```
Via this attribute: 

- [MemoryToFile](../WDLang1/3013070.md) will automatically copy the value of class members into the items of current file record. 

- [FileToMemory](../WDLang1/3013071.md) will automatically copy the items of current file record into the class members.




**Important**: 

- In order for this mechanism to operate, the names of class members must be identical to the names of items in the data file.

- If necessary: the **mapping** attribute allows you to use prefixes or names that differ from the analysis ones. To do so, re-use the **mapping** keyword on the members of the class to re-create the link between the member and its analysis item. 
	Example: 
	
	```wl
	m_sEstateTitle is ANSI string <mapping=EstateTitle>
	```




<a name="NOTE3_3"></a>


### MyMappedFile and MyUniqueMappedKey keywords
<a name="mymappedfile_and_myuniquemappedkey_keywords_ELTPARAGRAPHE000160"></a>

In the MBase class generated by the MVP RAD, two keywords are used to simplify the management of mapping: MyMappedFile and MyUniqueMappedKey. These keywords are used to identify, for the MBase base class, the file and the unique key of model: 

- **MyMappedFile** references the data file defined by the **mapping** keyword in the "Model" class. 
	For example, the following code is used in the bSave method of the MBase class: 
	
	```wl
	HReset(MyMappedFile)
	```

	This code will perform a call to [HReset](../WDLang4/3044118.md) on the data file for which the RAD was generated. 

- **MyUniqueMappedKey** references the item defined by the "unique key" mapping in the "Model" class.
	For example, in the MMyExampleFile class, MyUniqueMappedKey is equivalent to the MyExampleFileID item:
	
	```wl
	m_nMyExampleFileID is int<mapping=MyExampleFileID, unique key>
	```



These keywords allow you to use generic code in this base class. 
<a name="NOTE3_4"></a>


### "Associated" attribute
<a name="associated_attribute_ELTPARAGRAPHE000185"></a>

The **associated** attribute is used to access the members, the methods and the properties of a Model class from its Presenter class without having to perform any "rebounds".
Example: 

```wl
PFormMyExampleFile is Class
 PROTECTED
m_clCurrentModel is MMyExampleFile <associated>
```
In the above example, the PFormMyExampleFile objects have an "associated" member whose type is MMyExampleFile.

The PFormMyExampleFile objects directly expose the methods, properties and members of the associated class, without having to redefine them.

Via the **associated** attribute, there is no need to systematically re-create all the properties in the presenter class to expose the members of the model.

The MVP architecture generated by RAD contains generic classes and classes specific to the project. It can be entirely customized!

Simply create the desired methods and properties in the "Presenter" class to override the behavior of the model.

You have the ability to link a control to a member or to a property of the "Presenter" class. Therefore, this link can be performed on all the member or properties of the "Model", exposed by the "Presenter" class with this mechanism.
<a name="NOTE3_5"></a>


### "Presenter" attribute: managing the refresh of views
<a name="presenter_attribute_managing_the_refresh_views_ELTPARAGRAPHE000207"></a>

The **presenter** attribute is used during the global declaration of the generated windows. It is used to associate a class of the presenter layer with a view (window or report). 

For example: 


```wl
PROCEDURE WIN_Table_MyExampleFile(...
	gclPresenter is PTableMyExampleFile dynamic<presenter>=Null)
```
When this attribute is used, the call to the window refresh event will be triggered by:

- any call to [RequestRefreshUI](../WDLang1/1000023899.md) or [RequestRefreshUIParent](../WDLang1/1000023900.md) from a class declared as &lt;presenter&gt;, 

- any call from any class associated with the &lt;presenter&gt; class. 




**For example**, when deleting an element from a Table window generated by the MVP RAD, a request for updating the UI is performed by the call to [RequestRefreshUI](../WDLang1/1000023899.md):

- MArrayMyExampleFile is associated member of PTableMyExampleFile, 

- PTableMyExampleFile is defined as "presenter" of the "WIN_Table_MyExampleFile" window.




Then, the refresh event of "WIN_Table_MyExampleFile" will be automatically called when an element is deleted.

The UI refresh event allows grouping all the window refresh processes together, rather than distributing them into several events (click, etc.).

This mechanism is also found in the form window. The form window is linked to the presenter class PFormMyExampleFile containing an associated member MMyExampleFile. Therefore, the refresh requests performed in MMyExampleFile affect the form window.

**Caution**: The UI refresh event must not be executed "just anywhere".. 

**Important**: [RequestRefreshUI](../WDLang1/1000023899.md) and [RequestRefreshUIParent](../WDLang1/1000023900.md) are asynchronous: the UI refresh event is executed at the end of the current process, and the calls to [RequestRefreshUI](../WDLang1/1000023899.md) or [RequestRefreshUIParent](../WDLang1/1000023900.md) are not stacked. These functions and this mechanism can even be used outside an MVP architecture. **This operating mode offers a large benefit**: if a process loop in the model calls  50 times, WLanguage will perform one single call at the end of the process (prevents the UI from flickering).
Note: to request a synchronous UI refresh, simply use [ExecuteRefreshUI](../WDLang1/1000023901.md) (or [ExecuteRefreshUIParent](../WDLang1/1000023902.md)).


