
## External language: Programming in Pascal
			



<a name="NOTE1"></a>
<a name="NOTE1_1"></a>


## Overview
<a name="overview_ELTTEXTE000181"></a>
We are going to call the elements developed in WINDEV (project, windows, ... analysis) from the Pascal language. The WLanguage code used from the external language will be dynamically compiled and run during its call.

**This mode is illustrated in City.PAS** (in Pascal format) supplied in the "ExternalLanguages\\Pascal" subdirectory of the setup directory of WINDEV.

<a name="NOTE2"></a>
<a name="NOTE2_1"></a>


## Implementation
<a name="implementation_ELTTEXTE000205"></a>




### 1. Including the files of the Pascal interface of WINDEV
<a name="1_including_the_files_the_pascal_interface_windev_ELTPARAGRAPHE000022"></a>

If you are using a database in your application, the first step consists in generating your analysis. In the description of this analysis, specify the programming language used as well as the directory that will contain the source files.

Via the generation, a program skeleton (\*.pas) is generated. This operation will also create the .h file (see below) required to use your data files.

The following files must be included in a Pascal project in order to call the Pascal interface of WINDEV:

- Squelet.PAS (contains the description of the analysis)

- &lt;AnalysisName&gt;.H

- WDHF.PAS

- WINDEV.PAS




The .h and .pas files that describe the structure of the data files will be automatically generated by WINDEV when generating the analysis.
<a name="NOTE2_2"></a>


### 2. Including the HFSQL declarations
<a name="2_including_the_hfsql_declarations_ELTPARAGRAPHE000040"></a>

The .h and .pas files corresponding to the description of the analysis files must be added to the Pascal project. The declarations of data files are included in the file whose extension is .h.

For example, in the City.pas code (supplied with WINDEV in the "ExternalLanguages\\Pascal" directory), these files are "CityPas.H" and "Squelet.PAS".

<a name="NOTE3"></a>
<a name="NOTE3_1"></a>


## Declaration and initialization
<a name="declaration_and_initialization_ELTTEXTE000235"></a>




### 1. Declaring the HFSQL context and the working contexts of each file
<a name="1_declaring_the_hfsql_context_and_the_working_contexts_each_file_ELTPARAGRAPHE000052"></a>

If the application must manage data files, a HFSQL working context must be declared as well as a working context for each data file.

These declarations are performed in the City.pas project via the following lines:


```txt
{------------- include of the descriptions of the files used --------------}
{ write for each file $I .WDR }
{$I CityPas.h}	(* record    *)
var DP:typeDP;
var VI:typeVI;
{$F+}			{ compilation directive  $F+ mandatory at the beginning }
procedure HDescribeRecord;
{Describes each file of the analysis}
VAR
lArrItmST:array[0..1] of longint;
sTypeST: String;
lArrItmCI:array[0..1] of longint;
sTypeCI: String;
begin
lArrItmDP[0]:= 31; lArrItmDP[1]:= 3;
sTypeDP:= '11';
EL_HDescribeRecord(gCtx, stringtoptr('STATE'), 34, 
longint(@lArrItmST[0]), 2, stringtoptr(sTypeST), @ST);
lArrItmVI[0]:= 41; lArrItmVI[1]:= 6;
sTypeVI:= '11';
EL_HDescribeRecord(gCtx, stringtoptr('CITY'), 47, 
longint(@lArrItmCI[0]), 2, stringtoptr(sTypeCI), @CI);
End;
procedure HInit;
VAR
{Creating the context}
sAnalysisName:String;
sPassword:String;
begin
gCtx:= EL_CreateHFContext(2);
sAnalysisName:= 'CITYPAS.WDD';
sPassword:= ' ';
{Describing each record}
HDescribeRecord;
{Initializing HF}
	CALLWD('HFCTX');
If EL_Hinitshare(gCtx,WDLong) = 0 Then
begin
CALLWD('Error,Error initializing the HF context');
End
{opening the analysis}
else
begin
If HOpenAnalysis(gCtx, sAnalysisName, sPassword, ' ', ' ', ' ') = 0 Then
begin
CALLWD('Error,Error opening the analysis');
End;
End;
End;
```

<a name="NOTE3_2"></a>




### 2. Initializing HFSQL contexts
<a name="2_initializing_hfsql_contexts_ELTPARAGRAPHE000064"></a>

If your application is calling a database, the access to HFSQL must be prepared now. The test below is used to check whether this initialization is performed properly:


```txt
{Creating the context}
begin
HInit;
End;
```

<a name="NOTE3_3"></a>


### 3. Loading the WINDEV library (WDL)
<a name="3_loading_the_windev_library_wdl_ELTPARAGRAPHE000073"></a>

The WINDEV library (.WDL extension) contains all the project elements (windows, reports, classes, queries, analysis, ...). Therefore, it must be loaded in memory in order for its components to be called.

The load operation is performed by CALLWD('LIBRA,disk ...') as follows:

**Caution**: If the library to load contains windows, the code of each one of these windows must be included in the corresponding ".WDW" file ("Include the compiled code" must be checked in the "Details" tab of the description of each window).


```txt
begin{ Opening the library }
{ if WDInt is not null, the library was not found! }
CALLWD('LIBRA,disk,city.wdl');	{ Open the library. }
if WDInt0 then
begin
	{ Library not found }
	CALLWD('Error,The CITY.WDL library must be found in the parent directory.');
	{ indicate to WINDEV that the program will be ended }
	{ use HFDone only if an HFSQL database is used }
	HFDone;
	WDEnd;
	Halt;
end;
...
end;
```


<a name="NOTE4"></a>
<a name="NOTE4_1"></a>


## Running WINDEV codes from the external language
<a name="running_windev_codes_from_the_external_language_ELTTEXTE000271"></a>


### 1. Calling a WLanguage code
<a name="1_calling_wlanguage_code_ELTPARAGRAPHE000088"></a>

All the WLanguage functions can be called from the external language. The behavior of these WLanguage functions as well as the returned values are identical whether they are called:

- from WINDEV or

- from the interface of external language




To find out the parameters and the return values of a WLanguage function, see the online help or the documentation about WLanguage.

The call to a WLanguage procedure from the external interface is done via **CallWD**. For example:


```txt
open the first window of the program that contains the menu }
CALLWD('OPEN,menu.wdw);
```


You will notice that the parameter expected by **CallWD** is a  character string containing the WLanguage code to run.

Like the WLanguage coded in WINDEV, this string is not case sensitive (uppercase/lowercase characters). Therefore, the "Info" command can also be written as "INFO".
<a name="NOTE4_2"></a>


### 2. Retrieving the events triggered in the WINDEV windows
<a name="2_retrieving_the_events_triggered_the_windev_windows_ELTPARAGRAPHE000108"></a>

The input in the WINDEV windows requires to retrieve the events triggered in these windows.

To retrieve the user events (click on a menu, on a button, and so on), you must implement a system based on a loop in your Pascal program. This loop will remain active as long as the WINDEV window is opened and it will be used to intercept each user action.

To find out the type of action performed by the user, you have the ability to use a character string variable (in WLanguage) named **'WDKey**'. This variable will be used in your WLanguage code to signal to the Pascal program which button has been pressed for example.

Example: Pascal code


```txt
{ open the first window of the program that contains the menu }
CALLWD('OPEN,menu.wdw);
{ the program loops until the File Exit option }
{ is selected }
while( WDKey<>'ESC' ) do
begin
{ perform the input of the menu }
CALLWD('SCREEN,input');
	{------------------------------------------------}
{ Decode the selected option.	  }
{ WDString contains the sequence of shortcut letters }
{ that are used to select the menu choice }
{------------------------------------------------}
if( WDKey='FQ' ) then WDKey:='ESC';{ Exit              }
if( WDKey='RN' ) then FindCity;      { Search by City }
if( WDKey='RD' ) then FindState;      { Search by State }
if( WDKey='DD' ) then LstState;      { Display the list.    }
if( WDKey='DI' ) then LstPrint;     { Print.         }
if( WDKey='DC' ) then LstConfig;      { Configure the printout   }
end;
```


Code of "File .. Exit" of the WINDEV "Menu" window (WLanguage):


```txt
if( WDKey='FQ' ) then WDKey:='ESC';{ Exit from the loop }
```


When the user clicks "File .. Exit", **WDKey** will be returned to the Pascal code to perform the next action.

<a name="NOTE5"></a>
<a name="NOTE5_1"></a>


## Ending the application
<a name="ending_the_application_ELTTEXTE000301"></a>
To end the use of the external interface, all you have to do is call **HFDoneShare** and **WDDone** that expect no parameter. For example:


```txt
{ Done... }
{ use HFDoneShare only if an HFSQL database is used }
HFDoneShare;
WDEnd;
end.
```



