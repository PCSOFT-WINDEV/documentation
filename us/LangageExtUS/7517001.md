
## External language: Programming in Visual Basic
			



<a name="NOTE1"></a>
<a name="NOTE1_1"></a>


## Overview
<a name="overview_ELTTEXTE000210"></a>
We are going to call the elements developed in WINDEV (project, windows, analysis, ... ) from Visual Basic. This system is based on the use of the functions declared in the wdxxxle.dll of WINDEV. The WLanguage code used from the external language will be dynamically compiled and run during its call.

**This mode is illustrated in City.VBP** (in Visual Basic 6 format) supplied in the "ExternalLanguages\\Basic" subdirectory of the setup directory of WINDEV.

Remarks:

- To migrate an application developed in WINDEV 5.5, see [Migrating a Visual Basic application developed in WINDEV 5.5 to WINDEV 28](../LangageExt/7517002.md).

- This interface with Visual Basic can be used up to Visual Basic version 6 (supplied with Visual Studio 6).




<a name="NOTE2"></a>
<a name="NOTE2_1"></a>


## Implementation
<a name="implementation_ELTTEXTE000234"></a>




### 1. Including the files of the Visual Basic interface of WINDEV
<a name="1_including_the_files_the_visual_basic_interface_windev_ELTPARAGRAPHE000031"></a>

If you are using a database in your application, the first step consists in generating your analysis. In the description of this analysis, specify the programming language used as well as the directory that will contain the source files.

Via the generation, a program skeleton (\*.bas) is generated. This operation will also create the .gbl file (see below) required to use your data files.

The following files must be included in a Visual Basic project in order to call the Visual Basic interface of WINDEV:

![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=3&name=VisualBasic.gif)


The .glb and .bas files that describe the structure of the data files will be automatically generated by WINDEV when generating the analysis.
<a name="NOTE2_2"></a>


### 2. Including the HFSQL declarations
<a name="2_including_the_hfsql_declarations_ELTPARAGRAPHE000046"></a>

The .gbl and .bas files corresponding to the description of the analysis files must be added to the Visual Basic project. The declarations of the data files are included in the file whose extension is.gbl (this file replaces the.wdr created with the earlier WINDEV version).

For example, in the City.vbp project (supplied with WINDEV in the "ExternalLanguages" directory), this file is named "WD External language.gbl".

<a name="NOTE3"></a>
<a name="NOTE3_1"></a>


## Declaration and initialization
<a name="declaration_and_initialization_ELTTEXTE000264"></a>




### 1. Declaring the HFSQL context and the working buffers of each file
<a name="1_declaring_the_hfsql_context_and_the_working_buffers_each_file_ELTPARAGRAPHE000058"></a>

If the application must manage data files, a HFSQL working context must be declared as well as a buffer for each data file.

These declarations are performed by the following lines in the WD28 External Language.bas project:


```txt
' Manage the context of the 3 HFSQL files
gCtx = EL_CreateHFContext(3) ' Structure of the CITY file
' Zip Codes & Cities
Type TYPECD
	ZIPCODE		As String * 5
	F_ZIPCODE	As String * 1
	CITY	As String * 30
	F_CITY	As String * 1
End Type
	Global CD As TYPECD
```



### 2. Initializing the WINDEV DLLs
<a name="2_initializing_the_windev_dlls_ELTPARAGRAPHE000069"></a>

The first step before using the elements developed in WINDEV is to load the WINDEV DLLs in memory and to initialize them.

These operations are performed by the call to **InitModule** in the ***callwd*** procedure as follows:


```txt
Call InitModule(WDCtx)
```





### 3. Initializing HFSQL
<a name="3_initializing_hfsql_ELTPARAGRAPHE000079"></a>

If your application is calling a database, the access to HFSQL must be prepared now. The test below is used to check whether this initialization is performed properly:


```txt
'Initialization of HF
Call Callwd("HFCTX")
If EL_HinitShare(gCtx,WDLong) = 0 Then
	MsgBox ("Error initializing the HF context.")
	Exit Sub
End If
```



### 4. Loading the WINDEV library (WDL)
<a name="4_loading_the_windev_library_wdl_ELTPARAGRAPHE000086"></a>

The WINDEV library (.WDL extension) contains all the project elements (windows, reports, classes, queries, analysis, ...). Therefore, it must be loaded in memory in order for its components to be called.

The load operation is performed by callwd("Library,disk ...") as follows:

**Caution**: If the library to load contains windows, the code of each one of these windows must be included in the corresponding ".WDW" file ("Include the compiled code" must be checked in the "Details" tab of the description of each window).


```txt
' Open the library
' if WDInt is not null, the library was not found!
Call callwd("LIBRA,disk,city.wdl")
If WDInt <> 0 Then
	' Library not found
	 Call callwd("Error,The CITY.WDL library must be found in the current directory.")
	' indicate to WINDEV that the program will be ended
	 Call HFDoneShare
	 Call WDEnd
	 Exit Sub
End If
```



### 5. Opening  the project analysis and associating buffers with the data files
<a name="5_opening_the_project_analysis_and_associating_buffers_with_the_data_files_ELTPARAGRAPHE000097"></a>

Opening the analysis allows you to call the data files. Once this analysis has been opened with **HOpenAnalysis**, simply associate the working buffers with the files described in this analysis:


```txt
'open the analysis
If HOpenAnalysis(gCtx, sAnalysisName, sPassword,"", "", "") = 0 Then
	MsgBox ("Error opening the analysis " + sAnalysisName)
	Exit Sub
End If
' HF buffer of the City file
Call EL_HDescribeRecord(gCtx, "CITY", 37, lArrItmCD(0), 2, sTypeCD, CD)
' HF buffer of the State file
Call EL_HDescribeRecord(gCtx, "STATE", 34, lArrItmDP(0), 2, sTypeDP, DP)
```


<a name="NOTE4"></a>
<a name="NOTE4_1"></a>


## Running WINDEV codes from the external language
<a name="running_windev_codes_from_the_external_language_ELTTEXTE000312"></a>




### 1. Initialization code of the WINDEV project
<a name="1_initialization_code_the_windev_project_ELTPARAGRAPHE000109"></a>

This code is used to start the WINDEV project by declaring the global variables for example. It is run from the external language by **CallWD("Project, ProjectName")**. For example:


```txt
CALLWD("PROJECT,City");
```





### 2. Calling a WLanguage code
<a name="2_calling_wlanguage_code_ELTPARAGRAPHE000117"></a>

All the WLanguage functions can be called from the external language. The behavior of these WLanguage functions as well as the returned values are identical whether they are called:

- from WINDEV or

- from the interface of external language




To find out the parameters and the return values of a WLanguage function, see the online help or the documentation about WLanguage.

The call to a WLanguage procedure from the external interface is done via **CallWD**. For example:


```txt
' Open a WINDEV window
CALLWD("OPEN, menu.wdw")
```


You will notice that the parameter expected by **CallWD** is a  character string containing the WLanguage code to run.

Like the WLanguage coded in WINDEV, this string is not case sensitive (uppercase/lowercase characters). Therefore, the "Info" command can also be written as "INFO".


### 3. Retrieving the events triggered in the WINDEV windows
<a name="3_retrieving_the_events_triggered_the_windev_windows_ELTPARAGRAPHE000135"></a>

The input in the WINDEV windows requires to retrieve the events triggered in these windows.

To retrieve the user events (click on a menu, on a button, ...), you must implement a system based on a loop in your Visual Basic program. This loop will remain active as long as the WINDEV window is opened and it will be used to intercept each user action.

To find out the type of action performed by the user, you have the ability to use a character string variable (in WLanguage) named **'WDKey**'. This variable will be used in your WLanguage code to signal to the Visual Basic program which button has been pressed for example. This string has no size limit and it can contain the detailed statements that will be retrieved from your Visual Basic code.

**Example**: Visual Basic code


```txt
' open the first window of the program that contains the menu
Call callwd("OPEN,menu.wdw")
' the program loops until the File Exit option
' is selected
While WDKey <> "ESC"
	' perform the input of the menu
	Call callwd("SCREEN,input")
	'---------------------------------------
	' Test of the selected option.
	'---------------------------------------
	If WDKey = "FE" then WDKey = "ESC" ' Exit
	If WDKey = "RN" Then Call SearchCity ' Search by City
	If WDKey = "RD" Then Call SearchState ' Search by State
	If WDKey = "DD" Then Call LstState ' Display list.
	If WDKey = "DI" Then Call LstPrint ' Print.
	If WDKey = "DC" Then Call LstConfig ' Configure printer
Wend
' close the window
Call callwd("CLOSE")
```


Code of "File .. Exit" of the WINDEV "Menu" window (WLanguage):


```txt
WDKey="ESC"
```


When the user clicks "File..Exit", **WDKey** will be returned to the Visual Basic code to perform the next action.

**Remark**: The **WDKey** variable being a character string, its content can be a detailed description of the action to perform. For example, "Close the application".

<a name="NOTE5"></a>
<a name="NOTE5_1"></a>


## Ending the application
<a name="ending_the_application_ELTTEXTE000348"></a>
To end the use of the external interface, all you have to do is call **WDEnd** that expects no parameter. For example:


```txt
WDEnd
```



