
## External language: Programming in C
			



<a name="NOTE1"></a>
<a name="NOTE1_1"></a>


## Overview
<a name="overview_ELTTEXTE000228"></a>
We are going to call the elements developed in WINDEV (project, windows, ... analysis) from the C language. This system is based on the use of the functions declared in the .h, .c and .cpp files of WINDEV. The WLanguage code used from the external language will be dynamically compiled and run during its call.

**This mode is illustrated in**: 

- ** the VC60.dsp** (in Visual C++ 6 format) supplied in the "ExternalLanguages\\C" subdirectory of the setup directory of WINDEV.

- ** the BC5.0.IDE project** (in Borland C 5 format) supplied in the "ExternalLanguages\\C" subdirectory of the setup directory of WINDEV.




**Remark**: other modes are available for programming in external language. For more details, see [The programming modes of the external languages](../LangageExt/7510002.md)

<a name="NOTE2"></a>
<a name="NOTE2_1"></a>


## Implementation
<a name="implementation_ELTTEXTE000252"></a>


### 1. Including the files of the C interface of WINDEV
<a name="1_including_the_files_the_interface_windev_ELTPARAGRAPHE000027"></a>

If you are using a database in your application, the first step consists in generating your analysis. In the description of this analysis, specify the programming language used as well as the directory that will contain the source files.

Via the generation, a program skeleton is generated in the selected external language (C for example). This operation will also create the .h file (see below) required to use your data files.

The following files must be included in a C project in order to call the C interface of WINDEV in this second method:
<br>![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=3&name=mode2.gif)


The two following lines must be found in the code of the main .c file of your C project:


```txt
# include "WDExtern.h" // WINDEV language and objects
# include "HFContext.h" // HFSQL database
```


These lines allow you to retrieve the minimum declarations required to use the external interface. You will notice that the .h files that describe the structure of the files will be automatically generated by WINDEV when generating the analysis.
<a name="NOTE2_2"></a>


### 2. Including the HFSQL declarations
<a name="2_including_the_hfsql_declarations_ELTPARAGRAPHE000046"></a>

An inclusion (#include) must be added for each data file declared in the analysis of the WINDEV project. The declarations of data files are included in the file whose extension is.h (this file replaces the.wdr created with the earlier WINDEV version).

For example, in the Vc60.dsp project (provided with WINDEV in the "ExternalLanguages" directory), the following line is used to manage the City and State files:


```txt
#include "WD External language.h"
```


<a name="NOTE3"></a>
<a name="NOTE3_1"></a>


## Declaration and initialization
<a name="declaration_and_initialization_ELTTEXTE000282"></a>


### 1. Declaring the HyperFileSQL context and the working buffers of each file: 
<a name="1_declaring_the_hyperfilesql_context_and_the_working_buffers_each_file_ELTPARAGRAPHE000059"></a>

If the application must manage data files, a HyperFileSQL working context must be declared as well as a buffer for each data file.

These declarations are performed in the Vc60.dsp project via the following lines:


```txt
CHFContext gclHF; // Management of the HyperFileSQL context
StCITY gstCity; // HF buffer of City file
StSTATE gstState;       // HF buffer of State file
```


**2. Initializing the WINDEV DLLs**

The first step before using the elements developed in WINDEV is to load the WINDEV DLLs in memory and to initialize them.

These operations are performed by calling [nWDInit](../LangageExt/7513016.md), at the beginning of the *WinMain* procedure as follows:


```txt
if (nWDInit(FALSE)!=WDERROR_OK) ... // manage the error case
```


**3. Initializing HFSQL**

If your application is calling a database, the access to HyperFileSQL must now be prepared. The test below is used to check whether this initialization is performed properly:


```txt
IHFContext * pIHF;
if (!((nWDGetHFContext((void**)&pIHF)==WDERROR_OK) && 
(gclHF.bInit(pIHF)))) 
{
// manage the error case
}
```


**4. Loading the WINDEV library (WDL)**

The WINDEV library (.WDL extension) contains all the project elements (windows, reports, classes, queries, analysis, ...). Therefore, it must be loaded in memory in order for its components to be called.

The load operation is performed by [nWDOpenWDL](../LangageExt/7513013.md) as follows:


```txt
if (nWDOpenWDL(szWDL)!=WDERROR_OK)
{  
// Library not found
}
```


**5. Opening  the project analysis and associating buffers with the data files**

Opening the analysis allows you to call the data files. Once this analysis has been opened by **/HOpenAnalysis**, all you have to do is associate the working buffers with the files described in this analysis:


```txt
// Open the analysis (WDD contained in the WDL)
if (!gclHF.HOpenAnalysis(szAnalysis,szPassword))
{ 
// Error opening the analysis
}
// Buffer <-> file association
gclHF.bAssociate("city",&gstCity,sizeof(gstCity));
gclHF.bAssociate("state",&gstState,sizeof(gstState));
```


<a name="NOTE4"></a>
<a name="NOTE4_1"></a>


## Running WINDEV codes from the external language
<a name="running_windev_codes_from_the_external_language_ELTTEXTE000306"></a>


### 1. Initialization code of the WINDEV project
<a name="1_initialization_code_the_windev_project_ELTPARAGRAPHE000106"></a>

This code is used to start the WINDEV project by declaring the global variables for example. It is run from the external language by [**nWDInitProject**](../LangageExt/7513014.md). For example:


```txt
if (nWDInitProject("")==WDERROR_INIT)
{
// Error initializing the project
}
```

<a name="NOTE4_2"></a>


### 2. Calling a WLanguage code
<a name="2_calling_wlanguage_code_ELTPARAGRAPHE000118"></a>

All the WLanguage functions can be called from the external language. The behavior of these WLanguage functions as well as the returned values are identical whether they are called:

- from WINDEV or

- from the interface of external language




To find out the parameters and the return values of a WLanguage function, see the online help or the documentation about WLanguage.

You can use [**nWDExecute**](../LangageExt/7513015.md) to call a WLanguage procedure from the external interface. For example:


```txt
nWDExecute("OPEN(\"menu.wdw\")"); // Open the WINDEV window
```


You will notice that the parameter expected by [**nWDExecute**](../LangageExt/7513015.md) being a C character string containing the WLanguage code to run, you must respect the syntax of C strings (the \\ characters must be doubled, the quotes must be preceded by the control character \\ ... etc). This enables you to format this string with control characters such as %s, %l ... like the printf function of C.

Furthermore, as for the WLanguage coded in WINDEV, this string is not case sensitive (uppercase/lowercase characters). Therefore, the "Info" command can also be written as "INFO".
<a name="NOTE4_3"></a>


### 3. Retrieving the events triggered in the WINDEV windows
<a name="3_retrieving_the_events_triggered_the_windev_windows_ELTPARAGRAPHE000144"></a>

The input in the WINDEV windows requires to retrieve the events triggered in these windows.

To retrieve the user events (click on a menu, on a button, ...), you must implement a system based on a 'callback' function in your C program. This function will be called automatically by your WINDEV window for each user action.

To find out the type of action performed by the user, you have the ability to use a character string variable (in WLanguage) named **'WDKey**'. This variable will be used in your WLanguage code to signal to the C program which button has been pressed for example. This string has no size limit and it can contain the detailed statements that will be retrieved from your C code.

Example: C code


```txt
// Open the first application window
// Define the procedure that manages the WINDEV window
nWDSetCallbackNext(CallBackMenu,0);
// Open the WINDEV window
nWDExecute("OPEN(\"menu.wdw\")");
 [...]
C procedure used as callback for the window:
void CallBackMenu(DWORD dwUserParam,LPCTSTR pszCodeAction)
{
// pszCodeAction contains the sequence of shortcuts
// that are used to select the menu choice  
if( strcmp(pszCodeAction,"Exit application")==0 ) nWDExecute("CLOSE()"); // Exit
```


Code of "File .. Exit" of the WINDEV "Menu" window (WLanguage):


```wl
WDKey="Exit application"
```


[nWDSetCallbackNext](../LangageExt/7513012.md) allows you to define the procedure associated with the next window that will be opened. The call to [nWDExecute](../LangageExt/7513015.md) to perform then opening of this window ens the link between the "Menu" window and the "CallBackMenu" callback.

When the user clicks "File..Exit", **WDKey** will be returned in the "pszCodeAction" parameter to the "CallBackMenu" callback that can be tested in the C code in order to perform the next action.

Note: The **WDKey** variable being a character string, its content can be a detailed description of the action to perform. For example, "Close the application".

<a name="NOTE5"></a>
<a name="NOTE5_1"></a>


## Ending the application
<a name="ending_the_application_ELTTEXTE000342"></a>
To end the use of the external interface, all you have to do is call [WDTerm](../LangageExt/7513007.md) that expects no parameter. For example:


```txt
WDTerm();
```



