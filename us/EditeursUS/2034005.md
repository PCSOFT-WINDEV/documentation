


## SQL functions that can be used in SQL queries
			



<a name="NOTE1"></a>
<a name="NOTE1_1"></a>


## Overview
<a name="overview_ELTTEXTE003010"></a>
The following SQL functions can be used on the queries written in SQL code (classified by theme):


|   |   |
| --- | --- |
| <br><br>- extract characters:<br><br><br> | <br><br>- [ELT](#SQL_ELT)<br><br>- [EXTRACTVALUE](#SQL_EXTRACTVALUE)<br><br>- [LEFT](#SQL_LEFT)<br><br>- [RIGHT](#SQL_RIGHT)<br><br>- [MID](#SQL_MID), <br><br>- [SPLIT_PART](#SQL_SPLITPART)<br><br>- [SUBSTR](#SQL_MID) and [SUBSTRING](#SQL_MID)<br><br><br> |
| <br><br>- delete characters:<br><br><br> | <br><br>- [BTRIM](#SQL_BTRIM)<br><br>- [LTRIM](#SQL_LTRIM)<br><br>- [RTRIM](#SQL_RTRIM)<br><br>- [TRIM](#SQL_TRIM)<br><br><br> |
| <br><br>- substitute characters:<br><br><br> | <br><br>- [OVERLAY](#SQL_OVERLAY)<br><br>- [REPLACE](#SQL_REPLACE)<br><br>- [REVERSE](#SQL_REVERSE)<br><br>- [TRANSLATE](#SQL_TRANSLATE)<br><br><br> |
| <br><br>- merge strings:<br><br><br> | <br><br>- [CONCAT](#SQL_CONCAT)<br><br>- [GROUP_CONCAT](#SQL_GROUP_CONCAT)<br><br>- [STRING_AGG](#SQL_STRING_AGG)<br><br><br> |
| <br><br>- string padding:<br><br><br> | <br><br>- [LPAD](#SQL_LPAD)<br><br>- [REPEAT](#SQL_REPEAT)<br><br>- [RPAD](#SQL_RPAD)<br><br>- [SPACE](#SQL_SPACE)<br><br><br> |
| <br><br>- convert to string:<br><br><br> | <br><br>- [TO_CHAR](#SQL_TO_CHAR)<br><br>- [CHAR](#SQL_CHAR)<br><br>- [CHR](#SQL_CHR)<br><br>- [CAST](#SQL_CAST)<br><br>- [CONVERT](#SQL_CONVERT)<br><br><br> |
| <br><br>- change the case of a string:<br><br><br> | <br><br>- [INITCAP](#SQL_INITCAP)<br><br>- [LOWER](#SQL_LOWER)<br><br>- [UPPER](#SQL_UPPER)<br><br>- [LCASE](#SQL_LCASE)<br><br>- [UCASE](#SQL_UCASE)<br><br><br> |
| <br><br>- string length:<br><br><br> | <br><br>- [LEN](#SQL_LEN) and [LENGTH](#SQL_LENGTH)<br><br>- CHARACTER_LENGTH, CHAR_LENGTH and BYTE_LENGTH<br><br><br> |
| <br><br>- position of character string:<br><br><br> | <br><br>- [INSTR](#SQL_INSTR)<br><br>- [FIELD](#SQL_FIELD)<br><br>- [FIND_IN_SET](#SQL_FIND_IN_SET)<br><br>- [PATINDEX](#SQL_PATINDEX)<br><br>- [POSITION](#SQL_POSITION)<br><br><br> |
| <br><br>- number of records in a file:<br><br><br> | <br><br>- [COUNT](#SQL_COUNT)<br><br><br> |
| <br><br>- calculate numeric values:<br><br><br> | <br><br>- [AVG](#SQL_AVG)<br><br>- [MAX](#SQL_MAX)<br><br>- [MIN](#SQL_MIN)<br><br>- [SUM](#SQL_SUM)<br><br>- [EVERY](#SQL_EVERY)<br><br><br>See the [mathematical SQL functions](../Editeurs/2034002.md). |
| <br><br>- select the first or last n records n records:<br><br><br> | <br><br>- [TOP](#SQL_TOP)<br><br>- [BOTTOM](#SQL_BOTTOM)<br><br>- [LIMIT](#SQL_LIMIT)<br><br><br> |
| <br><br>- ASCII code<br><br><br> | <br><br>- [ASCII](#SQL_ASCII)<br><br><br> |
| <br><br>- Miscellaneous<br><br><br> | <br><br>- [UNICODE](#SQL_UNICODE)<br><br>- [CURRENT_USER](#SQL_CURRENT_USER)<br><br>- [SYSTEM_USER](#SQL_SYSTEM_USER)<br><br>- [USERNAME](#SQL_USER_NAME)<br><br><br> |
| <br><br>- phonetic<br><br><br> | <br><br>- [SOUNDEX, SOUND LIKE](#SQL_SOUNDEX, SOUND LIKE)<br><br>- [SOUNDEX2, SOUND2 LIKE](#SQL_SOUNDEX2, SOUND2 LIKE)<br><br><br> |
| <br><br>- managing dates<br><br><br> | <br><br>- [ADD_MONTHS](#SQL_ADD_MONTHS)<br><br>- [LAST_DAY](#SQL_LAST_DAY)<br><br>- [MONTHS_BETWEEN](#SQL_MONTHS_BETWEEN)<br><br>- [NEW_TIME](#SQL_NEW_TIME)<br><br>- [NEXT_DAY](#SQL_NEXT_DAY)<br><br>- [ROUND](#SQL_ROUND)<br><br>- [SYSDATE](#SQL_SYSDATE)<br><br>- [TRUNC](#SQL_TRUNC)<br><br>- [DAY](#SQL_DAY)<br><br>- [DAYOFMONTH](#SQL_DAYOFMONTH)<br><br>- [DAYOFWEEK](#SQL_DAYOFWEEK)<br><br>- [DAYOFYEAR](#SQL_DAYOFYEAR)<br><br>- [CURRENT_TIMESTAMP](#SQL_CURRENT_TIMESTAMP)<br><br>- [GETDATE](#SQL_GETDATE)<br><br>- [GETUTCDATE](#SQL_GETUTCDATE)<br><br>- [ISDATE](#SQL_ISDATE)<br><br>- [EOMONTH](#SQL_EOMONTH)<br><br>- [DATEADD](#SQL_DATEADD)<br><br>- [DATEDIFF](#SQL_DATEDIFF), [DATEDIFF_BIG](#SQL_DATEDIFF)<br><br>- [DATETIMEFROMPARTS](#SQL_DATETIMEFROMPARTS), [DATEFROMPARTS](#SQL_DATEFROMPARTS), [DATEPART](#SQL_DATEPART)<br><br>- [MONTH](#SQL_YEAR_MONTH), [YEAR](#SQL_YEAR_MONTH)<br><br><br> |
| <br><br>- comparison functions<br><br><br> | <br><br>- [COALESCE](#SQL_COALESCE)<br><br>- [GREATEST](#SQL_GREATEST)<br><br>- [IFNULL, ISNULL](#SQL_NVL_IF_NULL_IS_NULL)<br><br>- [NULLIF](#SQL_NULLIF)<br><br>- [LEAST](#SQL_LEAST)<br><br>- [NVL](#SQL_NVL_IF_NULL_IS_NULL)<br><br><br> |
| <br><br>- Conditional statement<br><br><br> | <br><br>- [DECODE](#SQL_DECODE)<br><br>- [CASE](#SQL_CASE)<br><br><br> |
| <br><br>- "Full-text" search<br><br><br> | <br><br>- [MATCH AGAINST](#SQL_MATCH AGAINST)<br><br><br> |
| <br><br>- Verification<br><br><br> | <br><br>- [MD5](#SQL_MD5)<br><br>- [SHA and SHA1](#SQL_SHA)<br><br><br> |
| <br><br>- Regular expression<br><br><br> | <br><br>- [REGEXP or NOT REGEXP (negation)](#SQL_REGEXP)<br><br>- [RLIKE or NOT RLIKE (negation)](#SQL_REGEXP)<br><br>- [~ or!~ (negation)](#SQL_REGEXP)<br><br>- [REGEXP_LIKE or NOT REGEXP_LIKE (negation)](#SQL_REGEXP)<br><br><br> |
| <br><br>- Bitwise functions and operators<br><br><br> | <br><br>- [BITAND, BITOR, BITXOR, BITNOT](#SQL_BITS)<br><br>- [BITANDNOT](#SQL_BITS)<br><br><br> |
| <br><br>- JSON operators<br><br><br> | <br><br>- [JSON_OBJECT](#SQL_JSONOBJECT), [JSON_OBJECTAGG](#SQL_JSONOBJECTAGG)<br><br>- [JSON_ARRAY](#SQL_JSONARRAY), [JSON_ARRAYAGG](#SQL_JSONARRAYAGG)<br><br>- [IS JSON](#SQL_ISJSON)<br><br>- [JSON_EXISTS](#SQL_JSONEXISTS)<br><br>- [JSON_VALUE](#SQL_JSONVALUE)<br><br>- [JSON_QUERY](#SQL_JSONQUERY)<br><br><br> |


For more details on SQL functions, please refer to a specific SQL documentation.

To discover all the SQL commands (functions, clauses, operators, etc.) that can be used in an SQL query managed by HFSQL, see [Commands that can be used in an SQL query managed by HFSQL](../Editeurs/2034006.md).

**Remarks**:

- These statements can be used:

	- in the SQL code of queries created in the query editor. Then, these queries will be run by [HExecuteQuery](../WDLang4/3044080.md).

	- in the SQL code of queries run by [HExecuteSQLQuery](../WDLang4/3044084.md).




- Unless stated otherwise, these functions can be used with all the types of data sources (Oracle, Access, SQL Server, and so on).






<a name="NOTE2"></a>
<a name="NOTE2_1"></a>


## SQL functions
<a name="sql_functions_ELTTEXTE003040"></a>


### Scalar expression
<a name="scalar_expression_ELTPARAGRAPHE000452"></a>

Each parameter passed to one of these SQL functions corresponds to an expression (called "scalar expression").

An expression can correspond to:

- a ***constant***: character string, integer, real, character, ... For example: 125, 'A', 'Doe'.

- an ***item name***.

- the ***result of another SQL function***.

- a ***calculation on an expression***. For example: "MyItem1+LEN(MyItem2)+1"



<a name="SQL_ELT"></a>
**ELT**
**ELT** returns the nth character string found in a list of strings.

**Format**:


```txt
ELT(String Number, String1, String2, String3, ...)
```


**Example**: The following SQL code is used to select the first string of the list:


```sql
SELECT ELT(1, 'ej', 'Heja', 'hej', 'foo')
```

<a name="SQL_EXTRACTVALUE"></a>
**EXTRACTVALUE**
**EXTRACTVALUE** is used to handle XML strings. This function returns the text (CDATA) of the first text node that is a child of the element corresponding to the XPATH expression. If several correspondences are found, the content of the first child text node of each node corresponding to the XPATH expression is returned in the format of a string delimited by space characters. 

**Format**:


```txt
EXTRACTVALUE(XML fragment, XPATH expression)
```


&lt;XML fragment&gt; must be a valid XML fragment. It must contain a unique root. 

**Example**: The following code is used to count the elements found: 


```sql
SELECT ExtractValue('<a><b/></a>', 'count(/a/b)') 
FROM CUSTOMER 
WHERE CUUNIKKEY=1
```

<a name="SQL_LEFT"></a>


### LEFT
<a name="left_ELTPARAGRAPHE000502"></a>**LEFT** extracts the left part (which means the first characters) of an expression.
![Native Connectors (Native Accesses)](https://doc.pcsoft.fr/ext/images/us/AN.png) This function cannot be used on a PostgreSQL data source.

**Format**:


```txt
LEFT(Initial expression, Number of characters to extract)
```


**Example**: The following SQL code is used to list the states of the customers:


```sql
SELECT LEFT(ZipCode, 2)
FROM CUSTOMER
```

<a name="SQL_RIGHT"></a>


### RIGHT
<a name="right_ELTPARAGRAPHE000520"></a>

**RIGHT** extracts the right part (which means the last characters) of an expression.

**Format**:


```txt
RIGHT(Initial expression, Number of characters to extract)
```


**Example**: The following SQL code is used to extract the last five characters from the name of the customers:


```sql
SELECT RIGHT(Name, 5)
FROM CUSTOMER
```

<a name="SQL_MID"></a>


### MID, SUBSTR and SUBSTRING
<a name="mid_substr_and_substring_ELTPARAGRAPHE000535"></a>

**MID, SUBSTR and SUBSTRING** are used to extract a substring found in the content of an expression from a given position.

If the given position corresponds to:

- a negative number, the extraction will start from the end of string.

- 0, the extraction will start from the beginning of the string (equivalent to position 1).




If the absolute value of the given position (returned by [ABS](../Editeurs/2034002.md)) is greater than the number of characters found in the initial expression, an empty string is returned.

**Example**: The following SQL code is used to extract the cities whose second character is 'A':


```sql
SELECT 
	ZIPCODES.IDCedex AS IDCedex,	
	ZIPCODES.ZipCode AS ZipCode,	
	ZIPCODES.City AS City,	
	SUBSTR(ZIPCODES.City, 2, 1) AS Expression1
FROM 
	ZIPCODES
WHERE 
	SUBSTR(ZIPCODES.City, 2, 1) = 'A'
```

<a name="NOTE2_5"></a>


### MID
<a name="mid_ELTPARAGRAPHE000556"></a>

**MID** can only be used on an Access data source.

**Format**:


```txt
MID(Initial expression, Start position, Number of characters to extract)
```


**Example**: The following SQL code is used to extract the 3rd and 4th characters from the name of the customers:


```sql
SELECT MID(Name, 3, 2)
FROM CUSTOMER
```

<a name="NOTE2_6"></a>


### SUBSTR
<a name="substr_ELTPARAGRAPHE000571"></a>

**SUBSTR** can only be used on an Oracle, HFSQL Classic or HFSQL Client/Server data source.

**Format**:


```txt
SUBSTR(Initial expression, Start position, Number of characters to extract)
```


**Example**: The following SQL code is used to extract the 3rd and 4th characters from the name of the customers:


```sql
SELECT SUBSTR(Name, 3, 2)
FROM CUSTOMER
```

<a name="SQL_SPLITPART"></a>
**SPLIT_PART**
**SPLIT_PART** divides a character string according to the specified separator and returns the nth part of the string.

**Format**:


```txt
SPLIT_PART(Initial Expression, Delimiter, Number of the Part to Extract)
```


**Example**: The following SQL code is used to extract the first 3 words corresponding to the address:


```sql
SELECT split_part(ADDRESS,' ',1), split_part(ADDRESS,' ',2),split_part(ADDRESS,' ',3) 
FROM CUSTOMER 
WHERE CUUNIKKEY=2
```

<a name="SQL_BTRIM"></a>


### BTRIM
<a name="btrim_ELTPARAGRAPHE000605"></a>

**BTRIM** deletes a character string found at the beginning or at the end of a string. 

**Format**:


```txt
BTRIM(<Source string>, [<String to delete>])
```


**Example**: Delete the 'AB' string from the 'ABRACADABRA' string


```sql
BTRIM('ABRACADABRA','AB')
```
In this example, the result is 'RCDR'.
<a name="SQL_LTRIM"></a>


### LTRIM
<a name="ltrim_ELTPARAGRAPHE000621"></a>

**LTRIM** returns a character string:

- without space characters on the left.

- without a list of characters.




The characters are deleted from left to right. This deletion is case sensitive (lowercase/uppercase characters). This deletion stops when a character that does not belong to the specified list is found.

The deletions of specific characters cannot be performed on an Access or SQL Server data source.

**Format**:


```txt
-- Deleting the space characters found on the left
LTRIM(Initial expression)
-- Deleting a list of characters
LTRIM(Initial expression, Characters to delete)
```


**Example**: The name of the customers is preceded by the title of the customers ("Mr.", "Mrs." or "Ms."). The following SQL code is used to:

- delete the title from each name (the letters "M", "r", and "s" as well as the dot character).

- delete the space character found in front of the name (space character that was found between the title and the name).



```sql
-- Deleting characters
SELECT LTRIM(Name, 'Ms.')
FROM CUSTOMER
-- Deleting the space character
SELECT LTRIM(Name)
FROM CUSTOMER
```
In this example:

| If the name of the customer is: | The returned string is: |
| --- | --- |
| 'Ms. DOE' | 'DOE' |
| 'Mr. CLARK' | 'CLARK' |
| 'Mrs. Davis' | 'Davis' |


<a name="SQL_RTRIM"></a>


### RTRIM
<a name="rtrim_ELTPARAGRAPHE000664"></a>

**RTRIM** returns a character string:

- without space characters on the right.

- without a list of characters.




The characters are deleted from right to left. This deletion is case sensitive (lowercase/uppercase characters). This deletion stops when a character that does not belong to the specified list is found.

The deletions of specific characters cannot be performed on an Access or SQL Server data source.

**Format**:


```txt
-- Deleting the space characters found on the right
RTRIM(Initial expression)
-- Deleting a list of characters
RTRIM(Initial expression, Characters to delete)
```


**Example**: The following SQL code is used to delete the 'E', 'U' and 'R' characters found on the right of the customer names:


```sql
SELECT RTRIM(Name, 'EUR')
FROM CUSTOMER
```
In this example:

| If the name of the customer is: | The returned string is: |
| --- | --- |
| 'DUVALEUR' | 'DUVAL' |
| 'DRAFUREUR' | 'DRAF' |
| 'Galteur' | 'Galteur' |
| 'FOURMALTE' | 'FOURMALTE' |
| 'BENUR' | 'BEN' |


<a name="SQL_TRIM"></a>


### TRIM
<a name="trim_ELTPARAGRAPHE000712"></a>

**TRIM** returns a character string:

- without space characters on the left and on the right.

- without a character string found at the beginning and at the end of string.

- without a character string found at the beginning of string.

- without a character string found at the end of string.




The characters are deleted from right to left. This deletion is case sensitive (lowercase/uppercase characters). This deletion stops when a character that does not belong to the specified string is found.

**Format**:


```txt
-- Deleting the space characters on the right ant on the left
TRIM(Initial expression)
-- Deleting a character string found at the beginning or at the end of a string
TRIM(Initial expression, String to delete)
-- OR
TRIM(BOTH String to delete FROM Initial expression)
-- Deleting a character string found at the beginning of a string
TRIM(LEADING String to delete FROM Initial expression)
-- Deleting a character string found at the end of a string
TRIM(TRAILING String to delete FROM Initial expression)
```

<a name="SQL_OVERLAY"></a>


### OVERLAY
<a name="overlay_ELTPARAGRAPHE000732"></a>

**OVERLAY** replaces a string with another one. 

**Format**:


```txt
OVERLAY(<Source string> PLACING <String to replace> 
FROM <Start position> [FOR <Length>])
```


Example: The following SQL code is used to replace "Green" by "Red": 


```sql
SELECT OVERLAY('Green apple' PLACING 'Red' FROM 7) FROM Product
```

<a name="SQL_REPLACE"></a>


### REPLACE
<a name="replace_ELTPARAGRAPHE000747"></a>

**REPLACE** returns a character string:

- by replacing all the occurrences of a word found in a string by another word.

- by replacing all occurrences of a word found in a string.




The replacement is performed from right to left. This replacement is case sensitive (uppercase/lowercase characters). This replacement stops when a character that does not belong to the specified string is found.

**Format**:


```txt
-- Replacing all the occurrences of a word by another word
REPLACE(Initial expression, String to replace, New string)
-- Deleting all the occurrences of a word
REPLACE(Initial expression, String to delete)
```

<a name="SQL_REVERSE"></a>
**REVERSE**
**REVERSE** returns a character string in which the order of characters is the reversed order of the initial string. 

**Format**:


```txt
REVERSE(Initial string)
```

<a name="SQL_TRANSLATE"></a>


### TRANSLATE
<a name="translate_ELTPARAGRAPHE000776"></a>

**TRANSLATE** returns a character string by replacing all the specified characters by other characters. If a character to replace has no corresponding character, this character is deleted.

The replacement is performed from right to left. This replacement is case sensitive (uppercase/lowercase characters).

**Format**:


```txt
-- Replace characters
TRANSLATE(Initial expression, Characters to replace, New characters)
```


Example: The following SQL code is used to replace:

- the "é" character by the "e" character.

- the "è" character by the "e" character.

- the "à" character by the "a" character.

- the "ù" character by the "u" character.





```sql
SELECT TRANSLATE(MyControl, 'éèàù', 'eeau')
FROM MyTable
```

<a name="SQL_CONCAT"></a>


### CONCAT
<a name="concat_ELTPARAGRAPHE000798"></a>

**CONCAT** concatenates several strings together.

**Format**:


```txt
CONCAT(String 1, String 2 [,..., String N])
```


![Native Connectors (Native Accesses)](https://doc.pcsoft.fr/ext/images/us/AN.png) CONCAT is not supported by Sybase.




<a name="SQL_GROUP_CONCAT"></a>


### GROUP_CONCAT
<a name="groupconcat_ELTPARAGRAPHE000816"></a>

**GROUP_CONCAT** concatenates the non-null values of an item from a series of records into a string.

Each value can be separated using a specific separator (spaces, ";", etc.). 

This function can be used to group results into one line.

If the GROUP BY statement is used, the different values can be grouped by a different criterion.

**Format**:


```txt
GROUP_CONCAT(<Column name> SEPARATOR <Separator>)
```


where: 

- &lt;Column name&gt; represents the item that contains the values to be grouped.

- &lt;Separator&gt; represents the character that separates each value.




**Example**: The following SQL code gets the list of weekdays and weekend days, each in a line. Days are separated by a semicolon. 

The "DAYOFWEEK" table handled is as follows: 

| DayType | DayName |
| --- | --- |
| Weekday | Monday |
| Weekday | Tuesday |
| Weekday | Wednesday |
| Weekday | Thursday |
| Weekday | Friday |
| Weekend | Saturday |
| Weekend | Sunday |






```sql
SELECT DayType, GROUP_CONCAT(DayName SEPARATOR ';')
FROM DAYOFWEEK
GROUP BY DayType
```


The result will be displayed as follows: 


```txt
'Weekday', 'Monday;Tuesday;Wednesday;Thrusday;Friday'
'Weekend', 'Saturday;Sunday'
```





<a name="SQL_STRING_AGG"></a>


### STRING_AGG
<a name="stringagg_ELTPARAGRAPHE000885"></a>

**STRING_AGG** is used to concatenate non-null strings from a list of values.

**Format**:


```txt
STRING_AGG(string, separator)
```
**Example**: 

The following code returns in a single string the list of delivery modes separated by ";".


```sql
select string_agg(ltext,';') as str from delivery
```


Content of the delivery file: 

- Shipping company

- Express delivery

- Certified

- Pick up




Result returned by the STRING_AGG function: "Shipping company;Express delivery;Certified;Pick up". 
<a name="SQL_LPAD"></a>


### LPAD
<a name="lpad_ELTPARAGRAPHE000910"></a>

**LPAD** returns a string whose size is defined. To reach the requested size, the string is left-padded:

- by space characters.

- by a character or by a given string.




**Format**:


```txt
-- Completion with space characters
LPAD(Initial expression, Length)
-- Completion with a character
LPAD(Initial expression, Length, Character)
-- Completion with a character string
LPAD(Initial expression, Length, Character string)
```

<a name="SQL_REPEAT"></a>
**REPEAT**
**REPEAT** returns a character string containing n times the repetition of the initial string. 

- If n is less than or equal to 0, the function returns an empty string. 

- If the initial string or n is NULL, the function returns NULL. 




**Format**:


```txt
REPEAT(Initial String, n)
```


**Example**: The following code is used to repeat the name of the contact 3 times: 


```sql
SELECT REPEAT(CONTACTNAME,14) 
FROM CUSTOMER  
WHERE CUUNIKKEY=10
```

<a name="SQL_RPAD"></a>


### RPAD
<a name="rpad_ELTPARAGRAPHE000944"></a>

**RPAD** returns a string whose size is defined. To reach the requested size, the string is right-padded:

- by space characters.

- by a character or by a given string.




**Format**:


```txt
-- Completion with space characters
RPAD(Initial expression, Length)
-- Completion with a character
RPAD(Initial expression, Length, Character)
-- Completion with a character string
RPAD(Initial expression, Length, Character string)
```

<a name="SQL_SPACE"></a>
**SPACE**
**SPACE** returns a string containing N space characters. 

**Format**:


```txt
SPACE(N)
```

<a name="SQL_TO_CHAR"></a>
**TO_CHAR**
**TO_CHAR** is used to convert into character string: 

- a datetime, 

- a numeric value.




**Format**:

**1. Convert a datetime value:** 


```txt
TO_CHAR(<DateTime value>, <DataTime format> [, <DateTime options>])
```


In this syntax: 

- &lt;DateTime format&gt; can correspond to one of the following elements: 

	- "-", "/", ",", ".", ";", ":"

	- "text": punctuation characters (separators) for a date and/or for a time.

	- AD, A.D.: Indicator of AD era for a date (After Jesus-Christ)

	- AM, A.M.: Indicator of AM meridian for the time (Ante Meridian)

	- BC, B.C.: Indicator of BC era for a date (Before Jesus-Christ)

	- CC or SCC Century: 

		- If the last two digits of the century on 4 digits are included between 01 and 99 (inclusive), the century is represented by the last 2 digits of the year.

		- If the last two digits of the century on 4 digits are 00, the century is represented by the first 2 digits of the year.
						For example, 2002 return 02 ; 2000 returns 20.




- D: Number of the day in the week (1-7). 

- DAY: Day in letters. 

- DD: Number of the day in the month (1-31).

- DDD: Number of the day in the year (1-366).

- DY: Abbreviated day in letters

- FF [1..9]: Fractions of seconds. The digit represents the number of digits representing the fraction of second. Examples:

	- 'HH:MI:SS.FF'

	- SELECT TO_CHAR(SYSTIMESTAMP, 'SS.FF3') from dual;

- The &lt;datetime options&gt; parameter is a character string containing the following keywords: 

	- "NLS_DATE_LANGUAGE=language in en"

	- "NLS_NUMERIC_CHARACTERS ='dg'": 'dg' is a 2-character string whose first one corresponds to the decimal separator and whose second one corresponds to the group separator (between thousand and hundred for example).
			Example: ‘NLS_DATE_LANGUAGE=*french*, NLS_NUMERIC_CHARACTERS =*, ‘*







**2. Converting a numeric value**: 


```txt
TO_CHAR(<Numeric value>, <Numeric format> [, <Numeric options>])
```


- The &lt;Numeric format&gt; parameter can correspond to one of the following elements: 

	- , (comma). Position a comma at the specified location. Example: 9,999

	- . (point). Position a point at the specified location. Example: 99.99

	- 0. Fills with zeros before or after. Example: 0999 or 9990

	- 9. Represents digits. Example: 9999

	- B. Replaces zeros by spaces. Example: B9999

	- C. Position the currency symbol according to the ISO standard when the NLS_ISO_CURRENCY parameter is used. Example: C999

	- D. Indicates the position of the decimal separator when the  NLS_NUMERIC_CHARACTER parameter is used. The (.) is the default separator. Example: 99D99

	- EEEE. Returns a value in scientific format. Example: 9.9EEEE

	- G. Indicates the thousand separator when the  NLS_NUMERIC_CHARACTER parameter is used. You can specify several thousands separators. Example: 9G999

	- L. Indicates the position of the currency symbol when the NLS_ISO_CURRENCY parameter is used. Example: L999

	- MI. Places the - sign after negative values. Example: 9999MI

	- PR. Encloses the negative values in angular brackets. Example: 9999PR

	- rn or RN. Returns the value in uppercase or lowercase roman numeric.

	- S. Indicates the +/- sign Positive or Negative. Example: S9999

	- U. Indicates the Euro currency symbol when the NLS_DUAL_CURRENCY parameter is used. Example: U9999

	- V. Returns the value in power of 10. Example 999V99

	- X. Returns the value in hexadecimal format. Example: XXXX




- In this syntax, &lt;Numeric options&gt; is a character string containing the following keywords: 

	- "NLS_CURRENCY='currency in us'"

	- "NLS_NUMERIC_CHARACTERS ='dg'": 'dg' is a 2-character string whose first one corresponds to the decimal separator and whose second one corresponds to the group separator (between thousand and hundred for example).
			Example: NLS_CURRENCY='$', NLS_NUMERIC_CHARACTERS='dg'







Remark: By default, the language, the currency and the separators are defined by the current nation.
<a name="SQL_CHAR"></a>
**CHAR**
CHAR is used to convert an ASCII code (integer) into character.


**Format**:


```txt
CHAR(<ASCII Code>)
```
&lt;ASCII code&gt; is a numeric and corresponds to the ASCII character to convert, between 0 and 255. Otherwise, the character returned by the function is NULL.

The result of the function is the character corresponding to the ASCII code of &lt;ASCII code&gt;. 

**Remark**: The result depends on the current character set.
<a name="SQL_CHR"></a>
**CHR**
CHR is used to convert an ASCII code (integer) into character.


```txt
CHR(<ASCII Code>)
```
&lt;ASCII code&gt; is a numeric and corresponds to the ASCII character to convert, between 0 and 255. Otherwise, the character returned by the function is NULL.

The result of the function is the character corresponding to the ASCII code of &lt;ASCII code&gt;. 

**Remarks**: 

- The result depends on the current character set.

- In UTF8, the integer sent is interpreted as a "code point" ; otherwise, the character returned corresponds to the character modulo 256.



<a name="SQL_CAST"></a>
**CAST**
CAST is used to convert a data from a type to another one.


```txt
CAST(Expression AS Type)
```


- &lt;Expression&gt; represents the value to convert.

- &lt;Type&gt; represents the new type into which the expression is converted. The available types are:





|   |   |
| --- | --- |
| CHARACTER | Character string |
| CHARACTER(Size) | String on size |
| VARCHAR(Size) | String on size |
| CHARACTER VARYING(Size) | String on size |
| CHAR VARYING(Size) | String on size |
| NVARCHAR(Size) | Unicode string on size |
| VARCHAR(Size) BINARY | Binary string on size |
| BINARY(Size) | Binary string on size |
| VARBINARY(Size) | Binary string on size |
| BLOB | Binary memo |
| CLOB | Text memo |
| TEXT | Text memo |
| NCLOB | Unicode memo |
| NTEXT | Unicode memo |
| NUMBER(Precision) | Integer |
| NUMBER(Precision, scale) | Integer |
| DECIMAL(Precision) | Real |
| DECIMAL(Precision, scale) | Real |
| TINYINT UNSIGNED | Unsigned 1-byte integer |
| SMALLINT UNSIGNED | Unsigned 2-byte integer |
| INTEGER UNSIGNED | Unsigned 4-byte integer |
| BIGINT UNSIGNED | Unsigned 8-byte integer |
| TINYINT | Signed 1-byte integer |
| SMALLINT | Signed 2-byte integer |
| INTEGER | Signed 4-byte integer |
| BIGINT | Signed 8-byte integer |
| FLOAT | 4-byte real |
| REAL | 8-byte real |
| DOUBLE PRECISION | 8-byte real |
| MONEY | Currency |
| DATE | DATE |
| DATETIME | Date time |
| TIME | Time |

The result of the function is the converted value.

Example: 


```sql
CAST(126.12 AS INTEGER)
```
This code returns: "126". 
<a name="SQL_CONVERT"></a>
**CONVERT**


CONVERT is used to convert a character string from a character set to another one.

**Format**:


```txt
CONVERT(Text to Convert, Charset Used, New Charset)
```


**Example**: Converting a string from UTF-8 to LATIN1: 


```sql
SELECT CONVERT('text in utf8', 'UTF8', 'LATIN1')
```


Remark: This function is not available for the SQL queries run on HFSQL files in Android. 
<a name="SQL_INITCAP"></a>
**INITCAP**
**INITCAP** returns a character string where the first letter of each word is written in uppercase character and all the other letters are written in lowercase characters. 

**Format**:


```txt
INITCAP(<String>)
```


Example: 


```sql
INITCAP ('grEat Weather today')
```
This code returns: 'Great Weather Today'. 
<a name="SQL_LOWER"></a>


### LOWER
<a name="lower_ELTPARAGRAPHE001311"></a>

**LOWER** converts an expression to lowercase.

**LOWER** cannot be used on an Access data source.

**Format**:


```txt
LOWER(Initial Expression)
```


**Example**: The following SQL code is used to convert the first name of the customers into lowercase characters:


```sql
SELECT LOWER(FirstName)
FROM CUSTOMER
```

<a name="SQL_UPPER"></a>


### UPPER
<a name="upper_ELTPARAGRAPHE001328"></a>

**UPPER** converts an expression to uppercase.

**UPPER** cannot be used on an Access data source.

**Format**:


```txt
UPPER(Initial Expression)
```


**Example**: The following SQL code is used to convert the cities of customers into uppercase characters:


```sql
SELECT UPPER(City)
FROM CUSTOMER
```

<a name="SQL_LCASE"></a>
**LCASE**
**LCASE** returns a string with all the characters in lowercase according to the current character set.

**Format**:


```txt
LCASE(Initial Expression)
```


**Example**: The following SQL code is used to convert the cities of customers into lowercase characters:


```sql
SELECT LCASE(City)
FROM CUSTOMER
```

<a name="SQL_UCASE"></a>
**UCASE**
**UCASE** returns a string with all the characters in uppercase according to the current set of characters.

**Format**:


```txt
UCASE(Initial Expression)
```


**Example**: The following SQL code is used to convert the cities of customers into uppercase characters:


```sql
SELECT UCASE(City)
FROM CUSTOMER
```

<a name="NOTE2_17"></a>


### LEN/LENGTH
<a name="lenlength_ELTPARAGRAPHE001379"></a>

**LEN and LENGTH** return the size (the number of characters) of an expression.

This size includes all the characters, including the space characters and the binary 0.
<a name="SQL_LEN"></a>


### LEN
<a name="len_ELTPARAGRAPHE001388"></a>

**LEN** can be used on all the types of data sources excluding the Oracle data sources. For the Oracle data sources, use **LENGTH**.

**Format**:


```txt
LEN(Initial Expression)
```


**Example**: The following SQL code is used to find out the size of the customer names:


```sql
SELECT LEN(Name)
FROM CUSTOMER
```

<a name="SQL_LENGTH"></a>


### LENGTH
<a name="length_ELTPARAGRAPHE001403"></a>

**LENGTH** can only be used on an Oracle data source.

**Format**:


```txt
LENGTH(Initial Expression)
```


**Example**: The following SQL code is used to find out the size of the customer names:


```sql
SELECT LENGTH(Name)
FROM CUSTOMER
```

<a name="SQL_INSTR"></a>


### INSTR
<a name="instr_ELTPARAGRAPHE001418"></a>

**INSTR** returns the position of a character string in an expression.

**INSTR** can only be used on an Oracle data source or on a data source supporting the SQL-92 standard.

**Format**:


```txt
INSTR(Initial Expression, String to Find, Start Position, Occurrence)
```


**Example**: The following SQL code is used to find out the position of the first occurrence of the letter "T" in the cities of the customers:


```sql
SELECT INSTR(City, 'T', 1, 1)
FROM CUSTOMER
```

<a name="SQL_FIELD"></a>
**FIELD**
**FIELD** returns the index of the sought string in the list.

If the string is not found, the function returns 0. 

**Format**:


```txt
FIELD(String to Find, String1, String2, ...)
```

<a name="SQL_FIND_IN_SET"></a>
**FIND_IN_SET**
**FIND_IN_SET** returns the position of a string in a list of values.

If the string is not found, the function returns 0. 

**Format**:


```txt
FIND_IN_SET(<String to Find>, <List of Values>)
```


The &lt;List of values&gt; parameter corresponds to a character string containing the values separated by a comma. 

Example: The following code returns 3: 


```sql
FIND_IN_SET('Red','Blue,Yellow,Red,Green')
```

<a name="SQL_PATINDEX"></a>


### PATINDEX
<a name="patindex_ELTPARAGRAPHE001471"></a>

**PATINDEX** returns the position of the first occurrence of a character string corresponding to a specified value (with generic characters).

The authorized wildcard characters are:

- '%': represents zero, one or more characters.

- '_': represents a single character.




These generic characters can be combined.

**PATINDEX** can be used on an HFSQL Classic or SQL Server data source.

**Format**:


```txt
PATINDEX(Value to Find, Expression)
```


**Example**: The table below presents the position of the first occurrence found according to the sought values:

   |   | --- | --- |
| --- | --- |
|   | Sought value |
| **City name** | '%E%' | '%E_' | '%AR%' |
| MONTPELLIER | 6 | 10 | 0 |
| PARIS | 0 | 0 | 2 |
| TARBES | 5 | 5 | 2 |
| TOULOUSE | 8 | 0 | 0 |
| VIENNE | 3 | 0 | 0 |


<a name="SQL_POSITION"></a>


### POSITION
<a name="position_ELTPARAGRAPHE001580"></a>

**POSITION** returns the position of a character string in an expression.

**Format**:


```txt
POSITION(String to find IN Initial expression)
POSITION(String to find IN Initial expression, Start position)
```


Example:


```wl
TestQRY is Data Source
sSQLCode is string = [
SELECT POSITION( 'No' IN Name ) As NamePos
FROM cooperator
LIMIT 0 , 30
]

IF NOT HExecuteSQLQuery(TestQRY, MyConnection, hQueryWithoutCorrection, sSQLCode) THEN 
	Error(HErrorInfo())
END
FOR EACH TestQRY 
	Trace(TestQRY.NamePos)
END
```

<a name="SQL_COUNT"></a>


### COUNT
<a name="count_ELTPARAGRAPHE001595"></a>

**COUNT** returns:

- the number of records selected in a file.

- the number of non-null values of an item.

- the number of different values and non-null values of an item.




**Format**:


```txt
COUNT(*)
COUNT(Item)
COUNT(DISTINCT Item)
```


**Examples**:

- The following SQL code is used to find out the number of products found in the Product file:
	
	```sql
	SELECT COUNT(*)
	FROM PRODUCT
	```


- The following SQL code is used to find out the number of products onto which a VAT rate of 5.5 % is applied:
	
	```sql
	SELECT COUNT(VATRate)
	FROM PRODUCT
	WHERE VATRate = '5.5'
	```


- The following SQL code is used to find out the number of different and non-null VAT rates:
	
	```sql
	SELECT COUNT(DISTINCT PRODUCT.VATRate)
	FROM PRODUCT
	```




<a name="SQL_AVG"></a>


### AVG
<a name="avg_ELTPARAGRAPHE001622"></a>

**AVG** calculates:

- the average of a set of non-null values.

- the average of a set of different and non-null values.




**Format**:


```txt
AVG(Item) 
AVG(DISTINCT Item)
```


**Examples**:

- The following SQL code is used to find out the average salary of the employees:
	
	```sql
	SELECT AVG(Salary)
	FROM EMPLOYEE
	```


- The following SQL code is used to find out the average of the different salaries of the employees:
	
	```sql
	SELECT AVG(DISTINCT Salary)
	FROM EMPLOYEE
	```




<a name="SQL_MAX"></a>


### MAX
<a name="max_ELTPARAGRAPHE001645"></a>

**MAX** returns the greatest of the values found in an item for all the records selected in the file.

MAX used in a query without grouping must return a single record. If the query contains groupings, a record will be returned for each grouping.

If the data source contains records, the record returned by the query will contain the maximum value.

If the data source contains no record, the value of MAX in the record returned is NULL.

**Format**:


```txt
MAX(Item) 

MAX(DISTINCT Item)
```


**Example**: The following SQL code is used to find out the maximum salary of employees:


```sql
SELECT MAX(Salary)
FROM EMPLOYEE
-- Equivalent to:
-- SELECT MAX(DISTINCT Salary)
-- FROM EMPLOYEE
```

<a name="SQL_MIN"></a>


### MIN
<a name="min_ELTPARAGRAPHE001666"></a>

**MIN** returns the lowest of the non-null values found in an item for all the records selected in the file.

**Format**:


```txt
MIN(Item)

MIN(DISTINCT Item)
```


**Example**: The following SQL code is used to find out the minimum salary of employees:


```sql
SELECT MIN(Salary)
FROM EMPLOYEE
-- Equivalent to:
-- SELECT MIN(DISTINCT Salary)
-- FROM EMPLOYEE
```

<a name="SQL_SUM"></a>


### SUM
<a name="sum_ELTPARAGRAPHE001681"></a>

**SUM** returns:

- the sum of the non-null values found in an item for all the records selected in the file.

- the sum of the different and non-null values found in an item for all the records selected in the file. 




**Format**:


```txt
SUM(Item)

SUM(DISTINCT Item)
```


**Examples**:

- The following SQL code is used to find out the total sum of salaries:
	
	```sql
	SELECT SUM(Salary)
	FROM EMPLOYEE
	```


- The following SQL code is used to find out the total sum of different salaries:
	
	```sql
	SELECT SUM(DISTINCT Salary)
	FROM EMPLOYEE
	```





**Remark**: The item handled by **SUM** must not correspond to the result of an operation. Therefore, the following syntax generates an error:

```sql
SELECT (A*B) AS C, SUM C
FROM MYFILE
```


This syntax must be replaced with the following syntax:

```sql
SELECT (A*B) AS C, SUM(A*B)
FROM MYFILE
```

<a name="SQL_EVERY"></a>


### EVERY
<a name="every_ELTPARAGRAPHE001714"></a>

**EVERY** is an aggregate function (like SUM for example), which means that the functions acts on a group of data and returns a value.

**EVERY** returns: 

- <u><u><u><u>True</u></u></u></u> if all the received arguments are checked and true.

- <u><u><u><u>False</u></u></u></u> if at least one of the arguments is not checked.




**Format**:


```txt
EVERY(Expression 1, Expression 2, ..., Expression N)
```


**Example**:
The following SQL code is used to get the list of companies with employees whose salary is greater than 10000:


```sql
SELECT company.name, every(employee.salary > 10000) as rich 
FROM company NATURAL JOIN employee GROUP BY company.name
```

<a name="SQL_TOP"></a>


### TOP
<a name="top_ELTPARAGRAPHE001741"></a>

**TOP** returns the first n records of the query result.

**TOP** cannot be used on an Oracle or PostgreSQL data source.

**Format**:


```txt
TOP Number of the last selected record
```


**Example**: The following SQL code is used to list the 10 best customers:


```sql
SELECT TOP 10 SUM(ORDERS.TotalIncTax) AS TotalIncTax,
CUSTOMER.CustomerName
FROM CUSTOMER, ORDERS
WHERE CUSTOMER.CustNum = ORDERS.CustNum
GROUP BY CustomerName
ORDER BY TotalIncTax DESC
```


**Remark**: 

- We recommend that you use **TOP** on a sorted query. Otherwise, the records returned by **TOP** will be selected according to their record number.

- You have the ability to pass a parameter to **TOP**. The parameter can be: 

	- defined in the query editor. For more details, see [Select query: Displaying the first/last n records](../Editeurs/2032022.md). 

	- defined in the code editor directly. For example: 



	```sql
	SELECT TOP {pMaxNumberCustomers}
	Customer.CustomerID AS CustomerID,
	Customer.LastName AS LastName,
	Customer.FirstName AS FirstName,
	Customer.Email AS Email,
	Customer.FidelityBonus AS FidelityBonus
	FROM
	Customer
	```




<a name="SQL_BOTTOM"></a>


### BOTTOM
<a name="bottom_ELTPARAGRAPHE001773"></a>

**BOTTOM** returns the last n records found in the result of a query.

**BOTTOM** can only be used on an HFSQL data source.

**Format**:


```txt
BOTTOM Number of the last selected record
```


**Example**: The following SQL code is used to list the 10 worst customers:


```sql
SELECT BOTTOM 10 SUM(ORDERS.TotalIncTax) AS TotalIncTax,
CUSTOMER.CustomerName
FROM CUSTOMER, ORDERS
WHERE CUSTOMER.CustNum = ORDERS.CustNum
GROUP BY CustomerName
ORDER BY TotalIncTax DESC
```


**Remark**: 

- It is recommend to use **BOTTOM** on a sorted query. Otherwise, the records returned by **BOTTOM** will be selected according to their record number.

- You have the ability to pass a parameter to **BOTTOM**. The parameter can be: 

	- defined in the query editor. For more details, see [Select query: Displaying the first/last n records](../Editeurs/2032022.md). 

	- defined in the code editor directly. 






<a name="SQL_LIMIT"></a>


### LIMIT
<a name="limit_ELTPARAGRAPHE001803"></a>

**LIMIT** returns the first n records of the query result.

**LIMIT** cannot be used on an Oracle or PostgreSQL data source.

**Format**:


```txt
LIMIT Number of the last selected record
```


**Example**: The following SQL code is used to list the 10 best customers:


```sql
SELECT SUM(ORDERS.TotalIncTax) AS TotalIncTax,
CUSTOMER.CustomerName
FROM CUSTOMER, ORDERS
WHERE CUSTOMER.CustNum = ORDERS.CustNum
GROUP BY CustomerName
ORDER BY TotalIncTax DESC
LIMIT 10
```


**Remark**: 

- It is not recommended to use **LIMIT** on a sorted query. Otherwise, the records returned by **TOP** will be selected according to their record number.

- You have the ability to pass a parameter to **LIMIT**. The parameter can be: 

	- defined in the query editor. For more details, see [Select query: Displaying the first/last n records](../Editeurs/2032022.md). 

	- defined in the code editor directly. 






<a name="SQL_ASCII"></a>


### ASCII
<a name="ascii_ELTPARAGRAPHE001833"></a>

**ASCII** returns the ASCII code:

- of a character. 

- of first character found in a string.




If the character or the character string corresponds to an empty string (""), **ASCII** returns 0.

**Format**:


```txt
-- ASCII code of character
ASCII(Character)
-- ASCII code of first character found in a string
ASCII(Character string)
```

<a name="SQL_UNICODE"></a>


### UNICODE
<a name="unicode_ELTPARAGRAPHE001849"></a>

**UNICODE** returns the integer value defined by the Unicode standard:

- of a character. 

- of first character found in a string.




**Format**:


```txt
-- Unicode code of character
UNICODE(Character)
-- Unicode code of first character found in a string
UNICODE(Character string)
```

<a name="SQL_CURRENT_USER"></a>


### CURRENT_USER
<a name="currentuser_ELTPARAGRAPHE001865"></a>

**CURRENT_USER** returns the username for the current connection.

**Format**:


```txt
CURRENT_USER()
```


**Example**: The following code updates the author of the modification performed in CUSTOMER table: 


```sql
UPDATE CUSTOMER SET USER=CURRENT_USER() WHERE CUSTOMERID=1
```

<a name="SQL_SYSTEM_USER"></a>


### SYSTEM_USER
<a name="systemuser_ELTPARAGRAPHE001882"></a>

**SYSTEM_USER** returns the username for the current connection.

**Format**:


```txt
SYSTEM_USER()
```


**Example**: The following code updates the author of the modification performed in CUSTOMER table: 


```sql
UPDATE CUSTOMER SET USER=SYSTEM_USER() WHERE CUSTOMERID=1
```

<a name="SQL_USER_NAME"></a>


### USER_NAME
<a name="username_ELTPARAGRAPHE001899"></a>

**USER_NAME** returns the username for the current connection.

**Format**:


```txt
USER_NAME()
```


**Example**: The following code updates the author of the modification performed in CUSTOMER table: 


```sql
UPDATE CUSTOMER SET USER=USER_NAME() WHERE CUSTOMERID=1
```

<a name="SQL_SOUNDEX, SOUND LIKE"></a>


### SOUNDEX, SOUND LIKE
<a name="soundex_sound_like_ELTPARAGRAPHE001914"></a>

**SOUNDEX** and **SOUND LIKE** return the phonetic representation of a character string (based on an English algorithm).

**Format**:


```txt
SOUNDEX(String)

SOUND LIKE(String)
```


**Example**: The following SQL code is used to list the customers whose name phonetically corresponds to "Henry":


```sql
SELECT CUSTOMER.CustomerLastName
FROM CUSTOMER 
WHERE SOUNDEX(CUSTOMER.CustomerName) = SOUNDEX('Henry')
```



```sql
SELECT CUSTOMER.CustomerLastName
FROM CUSTOMER 
WHERE CUSTOMER.CustomerName SOUND LIKE 'Henry'
```


Remark: SOUNDEX used on different databases (HFSQL, Oracle, MySQL, ...) may return different results according to the database used. 

![Native Connectors (Native Accesses)](https://doc.pcsoft.fr/ext/images/us/AN.png) SOUND LIKE is not supported by Oracle, MySQL, Progress or Informix. 

SOUNDEX is not supported by Informix. 
<a name="SQL_SOUNDEX2, SOUND2 LIKE"></a>


### SOUNDEX2, SOUND2 LIKE
<a name="soundex2_sound2_like_ELTPARAGRAPHE001939"></a>

**SOUNDEX2** and **SOUND2 LIKE** return the phonetic representation of a character string (based on an algorithm close to French).

**Format**:


```txt
SOUNDEX2(String)

SOUND2 LIKE(String)
```


**Example**: The following SQL code is used to list the customers whose city phonetically corresponds to "Montpellier":


```sql
SELECT CUSTOMER.CityName
FROM CUSTOMER 
WHERE SOUNDEX2(CUSTOMER.CityName) = SOUNDEX2('Montpellier')
```



```sql
SELECT CUSTOMER.CityName
FROM CUSTOMER 
WHERE CUSTOMER.CityName SOUND2 LIKE 'Montpellier'
```


![Native Connectors (Native Accesses)](https://doc.pcsoft.fr/ext/images/us/AN.png) SOUNDEX2 and SOUNDEX2 LIKE are not supported by Oracle, SQL Server, MySQL, Progress, Informix or DB2. 
<a name="SQL_ADD_MONTHS"></a>


### ADD_MONTHS
<a name="addmonths_ELTPARAGRAPHE001960"></a>

**ADD_MONTHS** is used to add several months to a specified date.

**Format**:


```txt
ADD_MONTHS(Date,Number of months)
```


**Example**: The following SQL code is used to select the orders placed in April 2003.


```sql
SELECT ORDDATE,
	ADD_MONTHS('20070203',2) AS AM 
FROM ORDERS
```


![Native Connectors (Native Accesses)](https://doc.pcsoft.fr/ext/images/us/AN.png) ADD_MONTHS is not supported by SQL Server, MySQL, Informix, DB2 or Sybase.
<a name="SQL_LAST_DAY"></a>


### LAST_DAY
<a name="lastday_ELTPARAGRAPHE001979"></a>

**LAST_DAY** is used to find out the date of the last day for the specified month.

**Format**:


```txt
LAST_DAY(Date)
```


**Example**: The following SQL code is used to select the orders placed in February 2008: 


```sql
SELECT LAST_DAY('20080203') as LD,
	ORDDATE 
FROM ORDERS
WHERE ORDERS.CUUNIKKEY=2 order by ORDDATE
```


![Native Connectors (Native Accesses)](https://doc.pcsoft.fr/ext/images/us/AN.png) LAST_DAY is not supported by Informix, DB2 or Sybase.
<a name="SQL_DAY"></a>


### DAY
<a name="day_ELTPARAGRAPHE002000"></a>

**DAY** returns the day of the month, which means a number included between 1 and 31.

**Format**:


```txt
DAY(Date)
```

<a name="SQL_DAYOFMONTH"></a>


### DAYOFMONTH
<a name="dayofmonth_ELTPARAGRAPHE002013"></a>

**DAYOFMONTH** returns the day in the month (included between 1 and 31).

**Format**:


```txt
DAYOFMONTH(Date)
```

<a name="SQL_DAYOFWEEK"></a>


### DAYOFWEEK
<a name="dayofweek_ELTPARAGRAPHE002026"></a>

**DAYOFWEEK** returns the day in the week (1 for Sunday, 2 for Monday, etc.). 

**Format**:


```txt
DAYOFWEEK(Date)
```

<a name="SQL_DAYOFYEAR"></a>


### DAYOFYEAR
<a name="dayofyear_ELTPARAGRAPHE002039"></a>

**DAYOFYEAR** returns the day in the year (included between 1 and 366). 

**Format**:


```txt
DAYOFYEAR(Date)
```

<a name="SQL_EOMONTH"></a>


### EOMONTH
<a name="eomonth_ELTPARAGRAPHE002052"></a>

**EOMONTH** returns the last day of the month of the specified date. 

**Format**:


```txt
EOMONTH(Start date [, Number of months to add ] )
```
where: 

- Start date: Date for which to return the last day of the month.

- Number of months to add: Number of months to add to the start date before calculating the last day of the month. 



<a name="SQL_YEAR_MONTH"></a>


### YEAR and MONTH
<a name="year_and_month_ELTPARAGRAPHE002069"></a>

**YEAR** and **MONTH** get the year and the month of a date, respectively. 

**Format**:


```txt
YEAR date
```



```txt
MONTH date
```


where date corresponds to: 

- the date written out: YEAR - MONTH - DAY (YYYYMMDD or YYYY-MM-DD)

- a partial date. in this case, missing data is represented by 0

- only a year (YEAR)

- only a year and a month (YEAR-MONTH)




Remark: 

- Dates are decoded from left to right: for a date to be valid, all available information must be valid. 

- If the format is invalid, the function returns NULL. 



<a name="SQL_CURRENT_TIMESTAMP"></a>


### CURRENT_TIMESTAMP
<a name="currenttimestamp_ELTPARAGRAPHE002096"></a>

**CURRENT_TIMESTAMP** returns the local time of server (in datetime format). 

**Format**:


```txt
CURRENT_TIMESTAMP()
```

<a name="SQL_GETDATE"></a>


### GETDATE
<a name="getdate_ELTPARAGRAPHE002109"></a>

**GETDATE** returns the local time of server (in datetime format). 

**Format**:


```txt
GETDATE()
```

<a name="SQL_GETUTCDATE"></a>


### GETUTCDATE
<a name="getutcdate_ELTPARAGRAPHE002122"></a>

**GETUTCDATE** returns the UTC time of server (in datetime format). 

**Format**:


```txt
GETUTCDATE()
```

<a name="SQL_DATEADD"></a>


### DATEADD
<a name="dateadd_ELTPARAGRAPHE002135"></a>

**DATEADD** adds a value to the start date and returns the new date.  

**Format**:


```txt
DATEADD(Part to add, number, date )
```
where: 

- Part to add: Part of the date to which the number will be added. This parameter can be: 
	

| Date part	 | Abbreviations |
| --- | --- |
| year | yy, yyyy |
| quarter | qq, q |
| month	 | mm, m |
| dayofyear	 | dy, y |
| day	 | dd, d |
| week	 | wk, ww |
| weekday | dw, w |
| hour | hh |
| minute	 | mi, n |
| second	 | ss, s |
| millisecond | ms |
| microsecond	 | mcs |
| nanosecond	 | ns |



- Number: integer corresponding to the number of units to be added. 

- date: date or datetime to be used. 



<a name="SQL_DATEDIFF"></a>


### DATEDIFF and DATEDIFF_BIG
<a name="datediff_and_datediffbig_ELTPARAGRAPHE002211"></a>

**DATEDIFF** calculates the difference between two dates in a given unit. The return value is a signed integer. 

**DATEDIFF_BIG** calculates the difference between two dates in a given unit. The return value is a signed big integer. 

**Format**:


```txt
DATEDIFF(Part used, Start date, End date) 

DATEDIFF_BIG(Part used, Start date, End date)
```
where: 

- Part used: Part of the date on which the calculation will be performed. This parameter can be: 
	

| Date part	 | Abbreviations |
| --- | --- |
| year | yy, yyyy |
| quarter | qq, q |
| month	 | mm, m |
| dayofyear	 | dy, y |
| day	 | dd, d |
| week	 | wk, ww |
| weekday | dw, w |
| hour | hh |
| minute	 | mi, n |
| second	 | ss, s |
| millisecond | ms |
| microsecond	 | mcs |
| nanosecond	 | ns |



- Start date: start date or datetime for the calculation. 

- End date: end date or datetime for the calculation. 



<a name="SQL_DATEPART"></a>


### DATEPART
<a name="datepart_ELTPARAGRAPHE002289"></a>

**DATEPART** returns the integer corresponding to the requested part of the specified datetime.  

**Format**:


```txt
DATEPART(Part used, date)
```
where: 

- Part used: Part of the date to be extracted. This parameter can be: 
	

| Date part	 | Abbreviations |
| --- | --- |
| year | yy, yyyy |
| quarter | qq, q |
| month	 | mm, m |
| dayofyear	 | dy, y |
| day	 | dd, d |
| week	 | wk, ww |
| weekday | dw, w |
| hour | hh |
| minute	 | mi, n |
| second	 | ss, s |
| millisecond | ms |
| microsecond	 | mcs |
| nanosecond	 | ns |



- Start date: date or datetime used. 



<a name="SQL_DATETIMEFROMPARTS"></a>


### DATETIMEFROMPARTS
<a name="datetimefromparts_ELTPARAGRAPHE002364"></a>

**DATETIMEFROMPARTS** returns a datetime value that corresponds to the specified elements. 

**Format**:


```txt
DATETIMEFROMPARTS(Year, Month, Day, Hours, Minutes, Seconds, Milliseconds)
```

<a name="SQL_DATEFROMPARTS"></a>


### DATEFROMPARTS
<a name="datefromparts_ELTPARAGRAPHE002377"></a>

**DATEFROMPARTS** returns a date value that corresponds to the specified elements. 

**Format**:


```txt
DATETIMEFROMPARTS(Year, Month, Days)
```

<a name="SQL_MONTHS_BETWEEN"></a>


### MONTHS_BETWEEN
<a name="monthsbetween_ELTPARAGRAPHE002388"></a>

**MONTHS_BETWEEN** is used to find out the number of months between two specified dates.

**Format**:


```txt
MONTHS_BETWEEN(Date1, Date2)
```


**Example**: The following SQL code is used to select the orders placed between two dates: 


```sql
SELECT ORDDATE,
	MONTHS_BETWEEN('20070203','20070102') AS MB 
FROM ORDERS
```


**Example**: The following SQL code is used to select the customers according to their age: 


```sql
SELECT CUSTOMER.CUSTOMERID,
	CUSTOMER.LASTNAME,CUSTOMER.FIRSTNAME,   
    -- Number of months divided by 12 in real: number of years
	CAST(MONTHS_BETWEEN(SYSDATE,CUSTOMER.DATE_OF_BIRTH)/12 AS FLOAT) AS Age
FROM 
	CUSTOMER
WHERE 
	-- customers over 18 only
	Age >= 18
```


![Native Connectors (Native Accesses)](https://doc.pcsoft.fr/ext/images/us/AN.png) MONTHS_BETWEEN is not supported by MySQL, Informix, DB2 or Sybase.
<a name="SQL_NEW_TIME"></a>


### NEW_TIME
<a name="newtime_ELTPARAGRAPHE002411"></a>

**NEW_TIME** is used to find out a date after converting its time zone.

**Format**:


```txt
NEW_TIME(Date, Time Zone 1, Time Zone 2)
```


**Example**: 


```sql
SELECT NEW_TIME('200311010145', 'AST', 'MST') as NTI 
FROM CUSTOMER
```


Remark: If the time zones correspond to an empty string (""), the result will be a DateTime value to 0.

![Native Connectors (Native Accesses)](https://doc.pcsoft.fr/ext/images/us/AN.png) NEW_TIME is not supported by SQL Server, MySQL, Progress, Informix, DB2 or Sybase.
<a name="SQL_NEXT_DAY"></a>


### NEXT_DAY
<a name="nextday_ELTPARAGRAPHE002432"></a>

**NEXT_DAY** is used to find out the first day of the week following the specified date or the specified day.

**Format**:


```txt
NEXT_DAY(Date, Day)
```


**Example**: 


```sql
SELECT NEXT_DAY('20071007','Sunday') AS NXD 
FROM CUSTOMER
```


![Native Connectors (Native Accesses)](https://doc.pcsoft.fr/ext/images/us/AN.png) NEXT_DAY is not supported by SQL Server, MySQL, Progress, Informix, DB2 or Sybase. 
<a name="SQL_ROUND"></a>


### ROUND
<a name="round_ELTPARAGRAPHE002451"></a>

**ROUND** is used to round the date to the specified format.

**Format**:


```txt
ROUND(Date, Format)
```


**Example**: 


```sql
SELECT ORDDATE,
	ROUND(ORDDATE,'YYYY') AS TR 
FROM ORDERS
```


![Native Connectors (Native Accesses)](https://doc.pcsoft.fr/ext/images/us/AN.png) ROUND is not supported by Progress, DB2 and Sybase. 
<a name="SQL_SYSDATE"></a>


### SYSDATE
<a name="sysdate_ELTPARAGRAPHE002470"></a>

**SYSDATE** is used to find out the current date and time.

**Format**:


```txt
SYSDATE
```


**Example**: 


```sql
SELECT SYSDATE as SY FROM CUSTOMER WHERE CUSTOMERID=1
```


![Native Connectors (Native Accesses)](https://doc.pcsoft.fr/ext/images/us/AN.png)  SYSDATE is not supported by Informix and Sybase.
<a name="SQL_TRUNC"></a>


### TRUNC
<a name="trunc_ELTPARAGRAPHE002489"></a>

**TRUNC** is used to truncate the date to the specified format.

**Format**:


```txt
TRUNC(Date, Format)
```
The "Format" parameter can correspond to the following values: 

- Century: "CC" or "SCC"

- Year: "Y", "YEAR", "YY", "YYY", "YYYY", "SYEAR", "SYYYY"

- ISO year: "I", "IY", "IY", "IYYY": 	ISOYear

- Quarter: "Q"

- Month: "MM", "MON", "MONTH"

- First day of month that is the same day of week: "W"

- First day of the week: "D", "DAY", "DY"

- Day: "DD", "DDD", "J"

- Hour: "HH", "HH12", "HH24"

- Minutes: "MI" 




**Example**: 


```sql
SELECT ORDDATE,
TRUNC(ORDDATE) AS TR 
FROM ORDERS 
WHERE ORDUNIKKEY
```


![Native Connectors (Native Accesses)](https://doc.pcsoft.fr/ext/images/us/AN.png) TRUNC is not supported by SQL Server, MySQL, Progress, DB2 and Sybase.
<a name="SQL_ISDATE"></a>


### ISDATE
<a name="isdate_ELTPARAGRAPHE002522"></a>

**ISDATE** is used to determine if an expression corresponds to a date. This function returns: 

- 1 if the expression corresponds to a date or datetime

- 0 otherwise. 




**Format**:


```txt
ISSDATE(Expression)
```


**Example**: 


```sql
SELECT Date, ISDATE(Date) FROM Order WHERE OrderID=50
```

<a name="SQL_COALESCE"></a>


### COALESCE
<a name="coalesce_ELTPARAGRAPHE002540"></a>

**COALESCE** is used to find out the first non-null expression among its arguments. 

**Format**:


```txt
COALESCE(Param1, Param2, ...)
```


**Example**: 


```sql
SELECT COALESCE(hourly_wage, salary, commission) AS Total_Salary FROM wages
```


![Native Connectors (Native Accesses)](https://doc.pcsoft.fr/ext/images/us/AN.png) COALESCE is not supported by Progress or Informix.
<a name="SQL_GREATEST"></a>
**GREATEST**
**GREATEST** returns the greatest value of the elements passed as parameter. 

**Format**:


```txt
GREATEST(Param1, Param2, ...)
```

<a name="SQL_LEAST"></a>
**LEAST**
**LEAST** returns the lowest value of the elements passed as parameter. 

**Format**:


```txt
LEAST(Param1, Param2, ...)
```

<a name="SQL_NVL_IF_NULL_IS_NULL"></a>


### NVL, IFNULL, ISNULL
<a name="nvl_ifnull_isnull_ELTPARAGRAPHE002585"></a>

**NVL** is used to replace the null values of a column by a substitution value. ISNULL and IFNULL are identical.

ISNULL is used in SQL Server and IFNULL is used in MySQL or Progress databases.

**Format**:


```txt
NVL(Column name, Substitution value)
```


**Example**: 


```sql
SELECT hourly_wage AS R1,NVL(hourly_wage,0) AS Total FROM wages
```

<a name="SQL_NULLIF"></a>


### NULLIF
<a name="nullif_ELTPARAGRAPHE002602"></a>

**NULLIF** returns a NULL value if the two specified expressions are equal.

**Format**:


```txt
NULLIF(expression1, expression2)
```

<a name="SQL_DECODE"></a>


### DECODE
<a name="decode_ELTPARAGRAPHE002613"></a>

**DECODE** is used to find out the operating mode of a IF .. THEN .. ELSE statement.

**Format**:


```txt
DECODE(Column_Name, Compared value 1, Returned value 1, [Compared value 2, ...
		Returned value 2][, Default value])
```


**Example**: Depending on the selected customer, returns the name corresponding to the specified identifier: 


```sql
SELECT CUSTOMER_NAME, 
DECODE(CUSTOMER_ID, 10000, 'Customer 1',10001,'Customer 2',10002,'Customer 3','Other')
FROM CUSTOMER
```


![Native Connectors (Native Accesses)](https://doc.pcsoft.fr/ext/images/us/AN.png)  DECODE is not supported by SQL Server, MySQL, Progress, Informix, DB2, Sybase and ACCESS.
<a name="SQL_CASE"></a>


### CASE
<a name="case_ELTPARAGRAPHE002632"></a>

**CASE** is used to find out the operating mode of a IF .. THEN .. ELSE statement.

**Format**:


```txt
CASE Column_Name WHEN Compared value 1 THEN Returned value 1 [WHEN compared value 2 THEN ...
		Returned value 2][ELSE Default returned value] END
```



```txt
CASE WHEN Condition 1 THEN Returned value 1 [WHEN Condition 2 THEN Returned value 2] ...
		[ELSE Default returned value] END
```


**Example**: Returns "three" if the item corresponds to "3" , returns "four" if the item corresponds to "4" and returns "other" in the other cases: 


```sql
SELECT itmInt, CASE itmInt WHEN 3 THEN 'three' WHEN 4 THEN 'four' ELSE 'other' END
```



```sql
SELECT itmInt, CASE WHEN itmInt=3 THEN 'three' WHEN itmInt=4 THEN 'four' ELSE 'other' END
```

<a name="SQL_MATCH AGAINST"></a>


### MATCH AGAINST
<a name="match_against_ELTPARAGRAPHE002651"></a>

**MATCH AGAINST** is used to find out the pertinence of the record during a full-text search.

**Format**:


```txt
MATCH(List of items) AGAINST [ALL] Value
```


Where: 

- **List of items** corresponds to the list of index items separated by commas (the order of items is not important)

- **Value** corresponds to the value sought in the different items. This parameter can correspond to a literal value or to a parameter name. The search value can contain the following elements:





|   |   |
| --- | --- |
| **Element** | **Meaning** |
| A single word | The specified word will be sought. The relevance will be increased if the text contains this word.<br><br>Example: "WINDEV" searches for "WINDEV". |
| Two words separated by a space character | Searches for one of the words.<br><br>Example: "WINDEV WEBDEV" searches for the texts containing either "WINDEV" or "WEBDEV". |
| A word preceded by the "+" sign | The specified word is mandatory.<br><br>Example: "+WINDEV" searches for the texts that necessarily contain "WINDEV". |
| A word preceded by the "-" sign | The specified word must not be found in the text.<br><br>Example: "-Index" searches for the texts that do no contain "Index". |
| A word preceded by the "~" sign | If the text contains the specified word, the relevance will be reduced. |
| One or more words enclosed in quotes | The specified words are searched in group and in order.<br><br>Caution: if "Ignore the words less than " differs from 0, the words enclosed in quotes less than the specified size will not be sought. |
| A word followed by the "\*" sign | The type of the search performed is "Starts with" the specified word. |

[ALL] is used to force the replacement of space characters by "+" in the sought value.

**Example**: In this example, EDT_Find is an edit control and ConnectedUserID is a variable.


```wl
MyQuery is string = [
SELECT * FROM Contact
WHERE MATCH(Contact.LastName, Contact.FirstName, Contact.HTMLComment, 
Contact.RoughTextComment, Contact.Comments, Contact.Phone, Contact.Office, 
Contact.Cell, Contact.Email, Contact.MSN, Contact.Internet_site, Contact.Country,
		Contact.FaxNum, Contact.City)
AGAINST ('
]
MyQuery = MyQuery + EDT_Find + [
')	
AND Contact.UserID =	
]
MyQuery = MyQuery + ConnectedUserID + [
ORDER BY LastName DESC
]

HExecuteSQLQuery(QRY_SRCH, hQueryDefault, MyQuery)
FOR EACH QRY_SRCH
	TableAddLine(TABLE_Contact_by_category, ...
	QRY_SRCH.ContactID,QRY_SRCH.CategoryID, ConnectedUserID, ...
	QRY_SRCH.LastName, QRY_SRCH.FirstName) 
END
CASE ERROR: 
	Error(HErrorInfo())
```
For more details on full-text search, see [Search and full-text index](../WDLang4/3044375.md).
<a name="SQL_MD5"></a>
**MD5**
**MD5** calculates the MD5 check sum of the string passed as parameter. The returned value is a hexadecimal integer of 32 characters that can be used as hash key for example. 

**Format**:


```txt
MD5(String)
```

<a name="SQL_SHA"></a>
**SHA and SHA1**
SHA and SHA1 calculate the 160-bit SHA1 check sum of the string passed as parameter according to the RFC 3174 standard (Secure Hash Algorithm). The returned value is a hexadecimal string of 40 characters or NULL if the argument is NULL. This function can be used for hashing the keys. 

**Format**:


```txt
SHA(String)

SHA1(String)
```

<a name="SQL_REGEXP"></a>
**REGEXP** or **RLIKE** or **~** or **REGEXP_LIKE**


The purpose of **REGEXP** or **RLIKE** or **~** or **REGEXP_LIKE** is to evaluate a regular expression inside an SQL query.

**Format**:


```txt
string REGEXP expression
```



```txt
string RLIKE expression
```



```txt
string ~ expression
```



```txt
REGEXP_LIKE(string, expression)
```
where: 

- string corresponds to the string that must be evaluated.

- expression corresponds to the regular expression.




The function result is a boolean: 

- <u><u><u><u> True</u></u></u></u> if the string corresponds to the regular expression.

- <u><u><u><u>False</u></u></u></u> othewise.




**Remark**: In a regular expression, the "\\" character is used to specify a specific formatting. Therefore, "\\r" corresponds to a carriage return and "\\n" to a line wrap...

**Examples**: In these examples, the 'abcde' string is compared to a regular expression.


```wl
sQuery = "SELECT 'abcde' REGEXP 'a[bcd]{3}e' AS result"
QRY is Data Source
HExecuteSQLQuery(QRY, hQueryDefault, sQuery)
HReadFirst(QRY)
let bResult = QRY.result
// bResult is set to True
```



```wl
sQuery = "SELECT 'abcde' REGEXP 'a[bcd]{2}e' AS result"
HExecuteSQLQuery(QRY, hQueryDefault, sQuery)
HReadFirst(QRY)
bResult = QRY.result
// bResult is set to False
```

<a name="SQL_BITS"></a>


### Bitwise operators and functions
<a name="bitwise_operators_and_functions_ELTPARAGRAPHE002800"></a>

The following are bitwise operators: 

- & 

- | 

- ^ 

- ~ 

- &lt;&lt; 

- &gt;&gt;




The corresponding functions are as follows: 

- BITAND,

- BITOR,

- BITXOR,

- BITNOT, 

- BITANDNOT.




Example: 


```wl
dsQuery is Data Source
sSQL is string = [
SELECT 
	1 | 2 AS op_or,						-- 3
	BITOR(1, 2) AS fct_or,					-- 3
	3 & 6 AS op_and,						-- 2
	BITAND(3, 6) AS fct_and,					-- 2
	~CAST(240 AS TINYINT) AS op_not,				-- 15
	BITNOT(CAST(240 AS TINYINT)) AS fct_not,			-- 15
	5 ^ 6 AS op_xor,						-- 3
	BITXOR(5, 6) AS fct_xor,					-- 3
	BITANDNOT(3,1) AS fct_andnot,				-- 2
	1 << 2 AS sl,							-- 4
	16 >> 2 AS sr							-- 4
]

HExecuteSQLQuery(dsQuery, sSQL)

Trace("Expected:")
Trace("3 - 3 - 2 - 2 - 15 - 15 - 3 - 3 - 2 - 4 - 4")
Trace("Received:")
FOR EACH dsQuery
	Trace(Replace(HRecordToString(dsQuery), TAB, " - "))
END
```

<a name="SQL_ISJSON"></a>


### IS JSON XXX
<a name="json_xxx_ELTPARAGRAPHE002828"></a>

"IS JSON xxx" commands are used to determine if an item is:

- a JSON content (IS JSON),

- a JSON content that represents an object (IS JSON OBJECT),

- a JSON content that represents an array (IS JSON ARRAY),

- ...




**Format**:


```txt
IS [NOT] JSON [OBJECT|ARRAY|SCALAR|VALUE] (expression)
```
The command returns 1 if the expression contains valid data, 0 otherwise. 

Example:


```sql
SELECT
	Product.Characteristics IS JSON AS ItemISJSON,
	Product.Characteristics IS JSON OBJECT AS ItemISJSONOBJECT,
	Product.Characteristics IS JSON ARRAY AS ItemISJSONARRAY,
	Product.Characteristics IS JSON SCALAR AS ItemISJSONSCALAR,
	Product.Characteristics IS JSON VALUE AS ItemISJSONVALUE
FROM
	Product
```

<a name="SQL_JSONVALUE"></a>


### JSON_VALUE
<a name="jsonvalue_ELTPARAGRAPHE002851"></a>

The SQL "JSON_VALUE" command gets the value of an element contained in the JSON item.
**Format**:


```txt
JSON_VALUE(expression, path)
```
 where: 

- expression corresponds to a variable containing JSON text

- path corresponds to the property to extract. 




Example:

```sql
SELECT
	Product.Reference,
	Product.Name,
	Product.Characteristics,
	JSON_VALUE(Product.Characteristics, 
		'$.brand' DEFAULT 'no brand' ON ERROR) AS Brand
FROM
	Product
```

<a name="SQL_JSONQUERY"></a>


### JSON_QUERY
<a name="jsonquery_ELTPARAGRAPHE002872"></a>

The SQL "JSON_QUERY" command extracts an object or an array from a JSON string.
**Format**:


```txt
JSON_QUERY(expression, path)
```
 where: 

- expression corresponds to a variable that contains JSON text

- path specifies the object or the array to extract. 




Example: 


```sql
SELECT
	Product.Reference,
	Product.Name,
	Product.Characteristics,
	JSON_QUERY(Product.Characteristics, '$.colors' ) AS Colors
FROM
	Product
```

<a name="SQL_JSONEXISTS"></a>


### JSON_EXISTS
<a name="jsonexists_ELTPARAGRAPHE002893"></a>

The SQL "JSON_EXISTS" command allows you to get the records with a JSON item that contains a particular value. 

**Format**:


```txt
JSON_EXISTS(expression, filter)
```
 where: 

- expression corresponds to a variable that contains JSON text

- filter corresponds to the data to be extracted. 




Example: 


```sql
SELECT
	Product.Reference,
	Product.Name,
	Product.Characteristics
FROM
	Product
WHERE
	JSON_EXISTS(Product.Characteristics, '$.heel?(@ == true)')
```

<a name="SQL_JSONOBJECT"></a>


### JSON_OBJECT
<a name="jsonobject_ELTPARAGRAPHE002915"></a>

The SQL "JSON_OBJECT" command returns a JSON object from any item. The retrieved JSON content is an object. 

Example: 
```sql
SELECT
Contact.ContactID,
JSON_OBJECT('FullName': Contact.lastname+' '+Contact.firstname, 
		'Address': Address+' '+PostalCode+' '+city+' '+country) 
		AS JSONContent
FROM
	Contact
WHERE
	ContactID <= 3
```





<a name="SQL_JSONOBJECTAGG"></a>


### JSON_OBJECTAGG
<a name="jsonobjectagg_ELTPARAGRAPHE002928"></a>

The SQL "JSON_OBJECTAGG" command returns a JSON object containing key-value pairs for each specific key and value in a set of SQL values.

Example: 
```sql
SELECT
JSON_OBJECTAGG(Contact.lastname+' '+Contact.firstname VALUE Address+' '+
		PostalCode+' '+city+' '+country) AS JSONContent
FROM
	Contact
WHERE
	ContactID <= 3
```

<a name="SQL_JSONARRAY"></a>


### JSON_ARRAY
<a name="jsonarray_ELTPARAGRAPHE002940"></a>

The SQL "JSON_ARRAY" command returns a JSON array from any item. The JSON content retrieved is an array ( [xxx, ...] ). 

Example: 
```sql
SELECT
Contact.ContactID,
JSON_ARRAY(Contact.lastname+' '+Contact.firstname) AS JSONContent
FROM
	Contact
WHERE
	ContactID <= 3
```

<a name="SQL_JSONARRAYAGG"></a>


### JSON_ARRAYAGG
<a name="jsonarrayagg_ELTPARAGRAPHE002955"></a>

The SQL "JSON_ARRAYAGG" command returns a JSON array containing key-value pairs for each specific key and value in a set of SQL values. The JSON content retrieved is an array ( [xxx, ...] ). 

Example: 
```sql
SELECT country, 
JSON_ARRAYAGG(customer.name) 
FROM customer 
GROUP BY country -> [ "romaric", "bob", "joe" ]
```



