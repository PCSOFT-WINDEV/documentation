
## CertificateCheckString( Función)



<a name="XUse"></a>
<a name="Use"></a>
<a name="description"></a>
Verifica la correspondencia entre una firma y un string.


<a name="Example1"></a>
<a name="sample_code"></a>

## Ejemplo

![WINDEV](https://doc.pcsoft.fr/ext/images/us/WD.png)![Código de Usuario (UMC)](https://doc.pcsoft.fr/ext/images/us/MCU.png) 
```wl
MyCertificate is Certificate

// Open the certificate picker of Windows
MyCertificate = CertificateSelect()

// Cancellation or error
IF MyCertificate.Name = "" THEN
	RETURN
END

// Checks whether the selected certificate is valid for signing
IF MyCertificate.ValidForSignature = False THEN
	Info("The selected certificate cannot be used to generate a signature.")
	RETURN
END

// Retrieve the buffer containing the signature
bufSignature is Buffer
bufSignature = CertificateSignString("Character string to sign", MyCertificate)

// Check the signature
SWITCH CertificateCheckString("Character string to sign", bufSignature)
	CASE certificateOk: Info("Valid signature and trusted certificate")
	CASE certificateInvalid: Info("Invalid signature or certificate")
	CASE certificateExpired: Info("Valid signature but expired certificate")
	CASE certificateUntrusted: Info("Valid signature but root confidence " + ...
		"of certificate not reliable")
END
```


<a name="Example2"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/us/WD.png)![Windows](https://doc.pcsoft.fr/ext/images/us/WINDOWS.png)![Linux](https://doc.pcsoft.fr/ext/images/us/LX.png) 
```wl
// Check the signature of data transmitted by PayBox
sData is string = [
act=ps_validated&secid=190&fpay=1&montant=25000&reference=CMD2019021309341242&auto=XXXXXX
&trans=33015345&abo=0&paiement=CARTE&carte=Maestro
&idtrans=14515770&erreur=00000&payscarte=FRA&fincb=44&debcb=111122
]
sSignatureBase64 is string = [
DVD+nMNaQatCBdS/qVjZGE8DtwPvIA3jxGhKlU83MyYC98ezKori/
3cceClqNhtmzD6MDhuKbm8Lw5sFTYdaKWzy79tXzxMLCq814u0+fc5KSihExS6
gIaixjCHiOTgqQXmPP29MkFPpfAFz/wKU/fu+FPGp2dpgLcoRAv0+m1o=
]
sPublicKeyFile is string = fDataDir() + "\pubkey.pem"
// Signature Base64 decoding
bufSignature is Buffer = Decode(Replace(sSignatureBase64, CR, ""), encodeBASE64URL)
// SHA-1 digest ==> certSHA160
IF CertificateCheckString(sData, bufSignature, sPublicKeyFile, 
	"", "", certSignatureOnly + certSHA160) = certificateOk THEN
	Info("The signature is correct")
ELSE
	Error("The signature is incorrect", ErrorInfo())
END
```





<a name="XSYNTAX"></a>

## Sintaxis
<a name="SYNTAX1"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/us/WD.png)![Linux](https://doc.pcsoft.fr/ext/images/us/LX.png)![Código de Usuario (UMC)](https://doc.pcsoft.fr/ext/images/us/MCU.png) 
### Comprobando la correspondencia entre una firma y una cadena

`<Result> = CertificateCheckString(<String to check> , <Signature buffer>)`
---

**`<Result>: (Constante de tipo Integer)`**

Resultado de la verificación de la firma: 


|   |   |
| --- | --- |
| *certificateExpired* | La firma es válida, pero ha caducado Certificate. |
| *certificateInvalid* | Firma inválida o Certificate. |
| *certificateOk* | Firma de confianza y Certificate. |
| *certificateUntrusted* | Firma válida pero raíz de Certificate no confiable. |



**`<String to check>: (Cadena de caracteres)`**

String de caracteres en el que se realizará la verificación.

**`<Signature buffer>: (Buffer)`**

Buffer que contiene la firma de la cadena de caracteres. Este búfer es devuelto por [CertificateSignString](../WDLang1/1000019296.md).


<a name="SYNTAX2"></a>

### Comprobación de la correspondencia entre una firma y una cadena (firma numérica)

`<Result> = CertificateCheckString(<String to check> , <Signature buffer> , <Certificate file> [, <Password> [, <Trusted authorities>]] , <Options>)`
---

**`<Result>: (Constante de tipo Integer)`**

Resultado de la verificación de la firma: 


|   |   |
| --- | --- |
| *certificateExpired* | La firma es válida, pero ha caducado Certificate. |
| *certificateInvalid* | Firma inválida o Certificate. |
| *certificateOk* | Firma de confianza y Certificate. |
| *certificateUntrusted* | Firma válida pero raíz de Certificate no confiable. |



**`<String to check>: (Cadena de caracteres o memoria intermedia)`**

La cadena de caracteres en la que se realizará la comprobación. 
Este parámetro puede corresponder a una cadena ANSI, una cadena UNICODE o un Buffer. La cadena será procesada como un buffer. 
Si este parámetro corresponde a una cadena (sin especificar el tipo), el tipo de cadena que se tiene en cuenta depende del tipo de cadena definido por Default en la configuración actual del proyecto. 
Observación: En el caso de una cadena UNICODE, note que Unicode no es lo mismo en Linux y Windows.

**`<Signature buffer>: (Buffer)`**

Buffer que contiene la firma de la cadena de caracteres. Este búfer es devuelto por [CertificateSignString](../WDLang1/1000019296.md).

**`<Certificate file>: (Cadena de caracteres o memoria intermedia)`**

Corresponde a: 

- ruta completa del archivo Certificate para usar (en formato PEM, DER o P12). 

- Tampón que contiene la Certificate a utilizar.


Observaciones: 

- Para una firma PKCS7, este parámetro permite añadir los certificados utilizados para buscar la cadena de confianza. 

- Para la firma en bruto, este parámetro contiene la clave public. 




**`<Password>: (Cadena de caracteres)`**

Contraseña que se utilizará para desencriptar el fichero Certificate si éste es password-protected.
Observación: Este parámetro es útil si la Certificate utilizada es idéntica a la utilizada para la firma.  

**`<Trusted authorities>: (Cadena o array de cadenas)`**

La ruta completa de la Certificate de confianza para usar. 
Este parámetro también puede corresponder a una array de cadenas que contiene el ruta completo de los diferentes certificados de confianza a utilizar.

Observación: También se tienen en cuenta los certificados de confianza añadidos con [TrustedCertificateAdd](../WDLang1/1000024320.md).



**`<Options>: (Constante o combinación de constantes de tipo Integer)`**

Formato de la firma: 


|   |   |
| --- | --- |
| *certPKCS7* | Firma en formato PKCS7. |
| *certSignatureOnly* | Sólo firma. En este caso, la constante *certSignatureOnly* debe combinarse con el algoritmo hash: <br><br>- *certSignatureOnly* + *certMD5*: Algoritmo MD5. <br><br>- *certSignatureOnly* + *certificado SHA160*: Algoritmo SHA1.<br><br>- *certSignatureOnly* + *certSHA256*: Algoritmo SHA2. Se obtiene un resultado de 256 bits. <br><br>- *certSignatureOnly* + *certSHA384*: Algoritmo SHA-384. Se obtiene un resultado de 384 bits<br><br>- *certSignatureOnly* + *certSHA512*: Algoritmo SHA-512. Se produce un resultado de 512 bits.<br><br><br><br><br>En este caso, la cadena de confianza no se comprueba. Sólo se comprueba la validez de la firma en relación con la clave public. |





<a name="NOTE0"></a>
<a name="NOTE0_1"></a>

## Observaciones


### Sección LDAP de Certificate
<a name="seccion_ldap_certificate_ELTPARAGRAPHE000177"></a>

El Certificate y el Certificate de confianza deben tener secciones LDAP diferentes. Una sección contiene los detalles sobre el emisor del Certificate. Por ejemplo, puede utilizar diferentes subsecciones "commonName.
De lo contrario, la función puede devolver un error correspondiente a la constante *certificateUntrusted* .

Observación: Dependiendo de la herramienta utilizada, esta sección puede tener diferentes nombres: Emisor (Windows Certificate), etc.







<a name="XComponent"></a>

## Clasificación Lógica de negocio / UI:
Lógica de negocio
## Componente:
wd280std.dll
