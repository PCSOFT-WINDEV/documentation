
## Prototipo overload/overload
			

<a name="NOTE1"></a>
<a name="NOTE1_1"></a>


## Presentación
<a name="presentacion_ELTTEXTE000229"></a>
Los procedimientos y los métodos de las clases pueden tener varias sintaxis.

Por ejemplo, un Procedure puede tener: 

- una sintaxis que toma una cadena en el parámetro.

- una sintaxis que toma un número entero en parámetro.




Por lo tanto, pueden existir varias sintaxis para la misma Procedure o para el mismo método con diferentes parámetros y código. En tiempo de ejecución, el motor define automáticamente la sintaxis de llamada en función del número y del tipo de parámetros pasados.

Esta tecnología se presenta bajo varios nombres e incluye diferentes propósitos. Se pueden utilizar los siguientes términos:

- Sobrecargar, 

- Prototipo overload,

- Sobrecargar, 

- Despacho dinámico,

- Polimorfismo paramétrico,

- etc.




Esta función está disponible para:

- Los procedimientos globales.

- Los procedimientos locales.

- Los métodos de la clase, incluidos los Constructores.
	




En el resto de esta Document: 

- utilizaremos el término **overload**.

- la palabra clave "Procedure" se usará para identificar un Procedure global, un Procedure local o un método.










<a name="NOTE2"></a>
<a name="NOTE1_2"></a>


## ¿Cómo proceder?
<a name="¿como_proceder_ELTTEXTE000253"></a>


### Añadiendo sintaxis a una Procedure
<a name="anadiendo_sintaxis_una_procedure_ELTPARAGRAPHE000084"></a>

Para añadir una sintaxis a un Procedure existente:

1. En el explorador del proyecto, seleccione el Procedure.

2. Abra el menú contextual de Procedure y seleccione "Añadir una sintaxis".. 

3. Se crea automáticamente una nueva sintaxis en el editor de código.  




**Observaciones**: 

- La creación de un Procedure con el mismo nombre propone automáticamente añadir una nueva sintaxis al Procedure existente.

- Si una Procedure tiene varias sintaxis, el número de sintaxis se muestra en el explorador del proyecto (junto al nombre de la Procedure). 





### Borrar una sintaxis de Procedure
<a name="borrar_una_sintaxis_procedure_ELTPARAGRAPHE000098"></a>

Para borrar una sintaxis:

1. Mostrar el código de la Procedure en el editor de códigos.

2. En la barra de la sintaxis, seleccione "Borrar" de el menú contextual.

3. Es posible: 

	- borrar la sintaxis actual. 

	- borrar todas las sintaxis (en este caso, se borra la Procedure). 











<a name="NOTE3"></a>
<a name="NOTE3_1"></a>




## Gestión de overload en tiempo de ejecución
<a name="gestion_overload_tiempo_ejecucion_ELTTEXTE000283"></a>


### Mecanismo básico: determinación dinámica de la sintaxis según el número y tipo de parámetros
<a name="mecanismo_basico_determinacion_dinamica_sintaxis_segun_numero_tipo_parametros_ELTPARAGRAPHE000116"></a>

El motor de tiempo de ejecución busca la sintaxis: 

- que tiene el mismo número de parámetros. 

- que tiene el número mínimo de conversiones.




Si dos sintaxis son equivalentes, se ejecuta la primera en el orden del editor de código.

**Ejemplo básico**


```wl
// First syntax
PROCEDURE p(s is string)
```

```wl
// Second syntax
PROCEDURE p(n is int)
```

```wl
// Third syntax
PROCEDURE p(n is int, s is string)
```

```wl
// Fourth syntax
PROCEDURE p(s is string, n is int)
```

```wl
// Calls

// Calls the first syntax (best corresponding syntax)
p("A")

// Calls the second syntax (best corresponding syntax)
p(1)	

// Calls the third syntax (best corresponding syntax)	
p(1,"A")

// Calls the fourth syntax (best corresponding syntax)	
p("A",1)
	
// Calls the third syntax 
// (equivalent to the fourth one, the third one has priority because described before)
p(1,1)	

// Calls the third syntax 
// (equivalent to the fourth one, the third one has priority because described before)
p("A","A")
```



### Despacho dinámico
<a name="despacho_dinamico_ELTPARAGRAPHE000134"></a>

Para una Procedure con varias sintaxis cuyos parámetros esperan instancias de clase, el motor de tiempo de ejecución está usando el método de "Despacho Dinámico" para definir la sintaxis que debe ser llamada. 

Veamos el siguiente ejemplo: 

- una clase "BaseClass

- dos clases, "DerivedClass1" y "DerivedClass2", que heredan de "BaseClass".





```wl
// First syntax
PROCEDURE p(LOCAL p is BaseClass)
```

```wl
// Second syntax
PROCEDURE p(LOCAL p is DerivedClass1)
```

```wl
// Calls
pBase is Dynamic BaseClass
pBase = New BaseClass		// Initialization 
p(pBase)				// First syntax
pBase = New DerivedClass1		// Initialization
p(pBase)				// Second syntax
pBase = New DerivedClass2		// Initialization
p(pBase)				// First syntax
```



### Métodos virtuales
<a name="metodos_virtuales_ELTPARAGRAPHE000148"></a>

Para gestionar los métodos virtuales, se pueden tener en cuenta varios aspectos: 

- **1er aspecto**: una sintaxis del método de la clase derivada redefine una sintaxis del método de la clase base
	
	```wl
	BaseClass
		PROCEDURE meth(s is string)
		PROCEDURE meth(n is int)
	
	DerivedClass
		PROCEDURE meth(n is int)
	
	// Call
	oBase is BaseClass
	// Calls the first syntax in the BaseClass class
	oBase.meth("A")
	// Calls the second syntax in the BaseClass class	
	oBase.meth(1)	
	
	oDerived is DerivedClass
	// Calls the first syntax in the BaseClass class
	oDerived.meth("A")
	// Calls the first syntax in the DerivedClass class
	oDerived.met (1)
	```


- **2º aspecto**: una sintaxis adicional en el método de la clase derivada
	
	```wl
	BaseClass
		PROCEDURE meth(p)
		PROCEDURE meth(s is string)
	
	DerivedClass
		PROCEDURE meth(n is int)
	
	// Call
	oBase is BaseClass
	// Calls the second syntax in the BaseClass class
	oBase.meth("A")
	// Calls the first syntax in the BaseClass class
	oBase.meth(1)		
	
	oDerived is DerivedClass
	// Calls the second syntax in the BaseClass class
	oDerived.meth("A")	
	// Calls the first syntax in the DerivedClass class
	oDerived.met (1)
	```


- **3er aspecto**: caso especial cuando el método de la clase base y el método de la clase derivada tienen una sintaxis única con diferentes prototipos: 
	
	```wl
	BaseClass
		PROCEDURE meth(s is string)
	
	DerivedClass
		PROCEDURE meth(n is int)
	```

	El compilador no puede decidir si el método de la clase derivada es una override del método de la clase base o una nueva sintaxis.

	- Para activar un override, el atributo con la extensión &lt;override&gt; debe ser añadido al método de la clase derivada. 
			
		```txt
		PROCEDURE method(...) <override>
		```


	- Para activar un overload, el atributo con la extensión &lt;overload&gt; debe ser añadido al método de la clase derivada.
			
		```txt
		PROCEDURE method(...) <overload>
		```









### Notas
<a name="notas_ELTPARAGRAPHE000172"></a>

- En la mayoría de los casos, debe forzar los parámetros a LOCAL para respetar las reglas de WLanguage para pasar los parámetros.

- Si la determinación dinámica de la sintaxis encuentra una sintaxis compatible, ésta puede desencadenar un error de tiempo de ejecución en las reglas de paso de parámetros de reference.








## Notas
<a name="notas_ELTTEXTE000325"></a>


### Alcance de los procedimientos
<a name="alcance_los_procedimientos_ELTPARAGRAPHE000180"></a>

Los procedimientos globales y el método de clase pueden ser públicos, protegidos o privados.. Para una Procedure sobrecargada, el alcance debe ser el mismo para todas las sintaxis. Se produce un error de compilación si los alcances de las sintaxis son diferentes.


