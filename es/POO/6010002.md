
## Instanciación de un objeto
			



<a name="NOTE1"></a>
<a name="NOTE1_1"></a>


## Resumen de un objeto
<a name="resumen_objeto_ELTTEXTE000219"></a>
Para acceder a una clase, **el objeto** debe declararse como parte de la clase a manipular, esto se denomina Instanciación de objeto **object**.

Una instancia es un objeto que pertenece a una clase determinada.

**To manipular un objeto**, usted debe: 

1. Describa la clase.

2. Instancia el objeto.




Un objeto puede ser pasado en parámetro a una función o a un Procedure.

**Observación**: Tiene la capacidad de instanciar dinámicamente un objeto a una clase. La implementación del polimorfismo requiere la instanciación dinámica. Para obtener más información, consulte [Instanciación dinámica](../POO/6010003.md).

Ejemplo de objeto: "SourceFile" es objeto de la clase "File. Para este objeto, usted tiene la capacidad de manipular los miembros llamados "Nombre", "Extensión", etc.


```wl
SourceFile is File object

SourceFile is File
```




<a name="NOTE2"></a>
<a name="NOTE2_1"></a>


## Sintaxis para declarar/instanciar un objeto
<a name="sintaxis_para_declararinstanciar_objeto_ELTTEXTE000243"></a>


### Declarar/Instanciar un objeto
<a name="declararinstanciar_objeto_ELTPARAGRAPHE000057"></a>


```txt
<ObjectName> is [object] <Class Name> ([<Parameters>])
```


**Detalles de la sintaxis**

**Nombre del Objeto&gt; &lt;Nombre del Objeto**

Nombre que identifica la instancia de la clase.

**&lt;Nombre de la clase&gt;**

Nombre que identifica a la clase, definido al crear la clase en el editor de código.

**Parámetros&gt; &lt;Parámetros**

Parámetros opcionales del constructor. Para obtener más información, consulte [Método constructor](../POO/6010001.md).
<a name="NOTE2_2"></a>


### Declarar/Instanciar un objeto NULL
<a name="declararinstanciar_objeto_null_ELTPARAGRAPHE000081"></a>


```txt
<ObjectName> is [object] <Class Name> ([<Parameters>]) = NULL
```


Esta sintaxis se utiliza para declarar un objeto sin instanciarlo.. En este caso:

- el &lt;- operador se utiliza para tomar un reference sobre el objeto.

- la declarada Variable se comporta como si la declaración fuera una declaración no dinámica: el = operador realiza una copy de los miembros.

- el objeto manejado puede ser devuelto como valor de retorno de la Procedure o método.

- en algunos casos avanzados, el objeto manipulado puede ser destruido para anticipar la operación de destrucción de automatic.



<a name="NOTE2_3"></a>


### Observación: Objeto actual
<a name="observacion_objeto_actual_ELTPARAGRAPHE000095"></a>

La palabra clave **Object** también puede ser usada para identificar el objeto actual.

También puede usar la palabra clave **This** para acceder al objeto actual.
<a name="NOTE2_4"></a>


### Miembros y métodos
<a name="miembros_metodos_ELTPARAGRAPHE000106"></a>

Para obtener más información, consulte [Usar un objeto](../POO/6010010.md).

<a name="NOTE3"></a>
<a name="NOTE3_1"></a>


## Vida útil de un objeto
<a name="vida_util_objeto_ELTTEXTE000285"></a>


### reference sobre un objeto local
<a name="reference_sobre_objeto_local_ELTPARAGRAPHE000118"></a>

El objeto se crea durante su declaración. El objeto es local de Default.

Los objetos locales no se destruyen automáticamente al final de la ejecución de Process. **Sólo el local reference es liberado.**

Por lo tanto, si otro reference fue tomado sobre el objeto, el objeto no será destruido cuando el reference local sea liberado.

Ejemplo:


```wl
// Declaration code of global variables
gpo is Class1 dynamic
gArr is array of Class1 dynamic

// Any code
o1, o2, o3 are Class1
gpo1 = o1
Add(gArr, o2)

// At the end of process
// o1 is not destroyed because it is referenced by the global variable gpo
// o2 is not destroyed because it was added to the gArr array
// o3 is not destroyed because there is only the local reference
```

<a name="NOTE3_2"></a>


### Devolución de un objeto
<a name="devolucion_objeto_ELTPARAGRAPHE000133"></a>

Tienes la capacidad de devolver un objeto manejado por un Variable local dinámico o no dinámico.

**Observación**: En las versiones anteriores, sólo tenías la posibilidad de devolver un objeto manejado por un Variable local dinámico.
<a name="NOTE3_3"></a>


### Objetos en los bucles
<a name="objetos_los_bucles_ELTPARAGRAPHE000142"></a>

En un bucle, los objetos pueden ser manejados por variables locales no dinámicas y sin asignación explícita.

Los objetos declarados en un bucle se reasignan en cada iteración del bucle y se libera el reference sobre el objeto de la iteración anterior:

- si no se ha tomado ningún otro reference, el objeto es destruido.

- si se tomó un reference (Variable global, adición a un array, etc.), el objeto no se destruye.




Ejemplo:


```wl
// build the array
t is array of Class1 dynamic
FOR I = 1 TO 10
	// create an object corresponding to the subscript
	o is Class (x)
	o.m_nIndex = i
	// add the object into the array
	Add(t,o)
END
```

<a name="NOTE3_4"></a>


### Liberar el objeto
<a name="liberar_objeto_ELTPARAGRAPHE000158"></a>

Los objetos utilizados por las variables locales no dinámicas pueden ser destruidos explícitamente por la palabra clave [BORRAR](../Motscles/1511012.md) para anticipar la destrucción de automatic.

**Observación**: Esta sintaxis es una sintaxis avanzada y debe utilizarse sólo en casos específicos.. En la mayoría de los casos, la operación de destrucción es automatic.

**Recordatorio**: En la mayoría de los casos, no se requiere el uso de la palabra clave DELETE.. El WLanguage destruye automáticamente los objetos que ya no son usados por ningún Variable. Los casos más comunes son:

- destruyendo una set de objetos referenciados de forma cíclica

- liberando los recursos utilizados por la Instance(sockets, archivos, ...) por adelantado a través de la ejecución del destructor.




![Java](https://doc.pcsoft.fr/ext/images/us/JAVA.png) **Caso especial en Java/Android**
El concepto de destructor no existe en Java/Android. Por lo tanto, el código encontrado en el destructor de una clase nunca se ejecutará. 
Un objeto es liberado por el recolector de basura cuando ya no está referenciado en la aplicación.. No hay forma de prever el momento en que esta operación ocurra..
Para forzar la liberación de un objeto, tienes la posibilidad de asignarlo a NULL o utilizar la sentencia [Libre](../Motscles/1511012.md).


