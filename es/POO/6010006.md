


## Clases, miembros, métodos y propiedades
			



<a name="NOTE1"></a>
<a name="NOTE1_1"></a>


## Resumen de una clase
<a name="resumen_una_clase_ELTTEXTE000821"></a>
Una clase está hecha de:

- datos, llamados **miembros**.

- **constantes**.

- procedimientos, llamados **métodos**.. Un método es una Procedure escrita específicamente para manipular los objetos encontrados en la clase.

- **propiedades**. Una propiedad es un elemento de clase que puede ser utilizado directamente por su nombre como miembro y para el cual las operaciones de asignación de valor y recuperación desencadenan la ejecución de una Process.
	![Universal Windows 10 App](https://doc.pcsoft.fr/ext/images/us/UNIVERSALAPP.png) Las propiedades de clase no están disponibles.




Para utilizar una clase, debe declarar uno o varios objetos. Todos los objetos de una clase dada tienen los mismos atributos y comportamiento, pero sus miembros contienen datos diferentes.

Por defecto, los miembros de una clase son públicos. Se puede acceder a ellos por un método de la clase así como por un proceso/Event del proyecto o sus elementos (control, ventana, etc.).



<a name="NOTE2"></a>
<a name="NOTE2_1"></a>


## Ejemplo de clase
<a name="ejemplo_clase_ELTTEXTE000845"></a>
La clase "CFile" incluye a los miembros: m_sShortPath, m_sLongPath, m_sExtension, m_sShortName, m_sLongName.

La clase "CFile" incluye los siguientes métodos:


|   |   |
| --- | --- |
| <br><br>- FileDate()<br><br>- FileSelection()<br><br><br> | <br><br>- FileTime()<br><br>- FileSize()<br><br><br> |

Esta clase no tiene Property.

La siguiente información se muestra en el panel "Explorador de proyectos":<br>![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=7&name=VoletClasse.gif)
 Vea las notas para obtener la description de los diferentes iconos utilizados.

<a name="NOTE3"></a>
<a name="NOTE3_1"></a>


## Creación y declaración de una clase
<a name="creacion_declaracion_una_clase_ELTTEXTE000869"></a>


### Creación de una clase
<a name="creacion_una_clase_ELTPARAGRAPHE000065"></a>

Para crear una clase:

1. Visualizar el panel "Explorador de proyectos" si es necesario: en la pestaña "Inicio", en el grupo "Entorno", despliegue "Paneles" y seleccione "Explorador de proyectos".

2. En el panel "Explorador de proyectos", abra el menú contextual de la carpeta "Clases" y seleccione "Crear una clase".

3. En la ventana que se visualiza, introduzca el nombre de la clase y valide.

4. El editor de código muestra el código de la nueva clase. La "Declaración" Event de la clase así como el constructor y el destructor se crean automáticamente.



<a name="NOTE3_2"></a>


### Sintaxis para declarar la clase y sus elementos
<a name="sintaxis_para_declarar_clase_sus_elementos_ELTPARAGRAPHE000089"></a>


```txt
<ClassName> is Class [, abstract]
	<Scope and rights>
		<Declaration member 1>
		<Declaration member 2>
	<Scope and rights>
		<Declaration member 3>
		<Declaration member 4>
	...
	<CONSTANT>
		<Declaration of constants>
END
```

<a name="NOTE3_3"></a>


### Sintaxis detallada de la declaración de clase
<a name="sintaxis_detallada_declaracion_clase_ELTPARAGRAPHE000096"></a>

**&lt;ClassName&gt;**

Nombre que identifica a la clase.

**abstract: opcional**

Se utiliza para especificar que la clase es abstract. Una clase abstract es una clase base que agrupa comportamientos comunes a varias clases. 
Una clase es abstract cuando se declara como tal o si uno de sus métodos es abstract.
Una clase abstract no puede ser instanciada.

**&lt;Alcance y derechos&gt;**

Este parámetro tiene el siguiente formato: [ GLOBAL][ Público / Público CONSTANTE / Protegido / Protegido CONSTANTE / Privado ]

**GLOBAL: Opcional**

Define un miembro global. Este miembro existirá fuera de los objetos. Se puede utilizar sin instanciar un objeto. Si se declaran varios objetos, un miembro global es común a todos los objetos.

**&lt;Modo de acceso&gt;: Opcional**

Permite restringir el acceso a este miembro de la clase.

- **Public** (por Default): acceso permitido desde cualquier código de la clase o proyecto.

- **Público CONSTANTE**: El valor del miembro puede ser leído y modificado desde un código de la clase o desde un código de una clase derivada; sólo puede ser leído desde otro código de la aplicación.. 

- **Protegido**: acceso permitido desde un código de la clase o desde un código de una clase derivada (y una clase "heredada")

- **Protegido CONSTANTE**: El valor del miembro puede ser leído y modificado a partir de un código de la clase; sólo puede ser leído a partir de un código de una clase derivada; no puede ser accedido a partir de ningún otro código de la aplicación.. 

- **Privado**: acceso permitido desde un código de la clase




**&lt;Miembro de la declaración&gt;**

Sintaxis para declarar a los miembros de la clase (véase más abajo). El alcance y los derechos de acceso de los miembros son los actuales.

**&lt;Declaración de constantes&gt;**

Sintaxis para declarar las constantes (ver abajo).<a name="NOTE3_4"></a>


### Ejemplo
<a name="ejemplo_ELTPARAGRAPHE000166"></a>


```wl
SystemClass is Class
	Name is string
END
```


<a name="NOTE4"></a>
<a name="NOTE4_1"></a>


## Declarar a los miembros de una clase
<a name="declarar_los_miembros_una_clase_ELTTEXTE000911"></a>


### Sintaxis
<a name="sintaxis_ELTPARAGRAPHE000175"></a>


```txt
<Member name> is <Member type> [ = <Initial value>]
```

<a name="NOTE4_2"></a>


### Sintaxis detallada
<a name="sintaxis_detallada_ELTPARAGRAPHE000182"></a>

**&lt;Nombre del miembro&gt;**

Nombre que identifica al miembro.

**&lt;Tipo de miembro&gt;**

Tipo de miembro elegido entre los tipos disponibles de WLanguage.

**&lt;Valor inicial&gt;**

Valor inicial del miembro.
```wl
SystemClass is class
	Name is string
	Private
		ClassSize is int
END
```

<a name="NOTE4_3"></a>


### Declarando a los miembros de Array
<a name="declarando_los_miembros_array_ELTPARAGRAPHE000206"></a>

Para declarar una array en una clase, utilice la siguiente sintaxis:

```txt
SystemClass is Class
	DefaultArray is array of 1 int
END
```


La array se declara de la misma manera que la arrays simple (para más detalles, véase [Tipo «array»](../Motscles/1514030.md)).

Cuando se copian instancias de clases, todos los miembros de la clase se copian en la nueva instancia excepto arrays. Por lo tanto, si se modifica el valor de un miembro de array, este valor se modifica en todas las instancias.

**Para obtener arrays independientes en todas las instancias de las clases**, debe declararse un array local de la siguiente manera:


```txt
SystemClass is Class
	DefaultArray is local array of 1 int
END
```

 
Observación: A la get independiente arrays en todas las instancias de las clases: 

1. Abra la ventana de descripción del proyecto: en la pestaña "Proyecto", en el grupo "Proyecto", haga clic en "Descripción". 

2. En la pestaña "Compilación" seleccione "Arrays: la asignación copia el contenido". 


Para obtener más información, consulte [Descripción del proyecto, pestaña compilación](../Editeurs/9500218.md).
<a name="NOTE4_4"></a>


### Serialización de los miembros de una clase
<a name="serializacion_los_miembros_una_clase_ELTPARAGRAPHE000253"></a>

Por Default, todos los miembros de una clase son seriados. 

Tiene la capacidad de gestionar con precisión la serialización de cada miembro de la clase.: 

- especificando el miembro que será serializado durante la llamada a [Serialize](../WDLang1/3013065.md). 
	Esta operación se puede realizar en todos los tipos de serialización (WXML, JSON, binario).. 

- cambiando el nombre del miembro durante la serialización con [Serialize](../WDLang1/3013065.md).  
	Esta operación sólo se puede realizar durante una serialización binaria.. 




Esta gestión de serialización se realiza utilizando la siguiente sintaxis: 

- Serialización (o no) de un miembro: 
	
	```txt
	<Member name> is <Member type> [ = <Initial value>] 
	[, Serialize = <True/False>]
	```


- Serialización y cambio de nombre de miembro: 
	
	```txt
	<Member name> is <Member type> [ = <Initial value>] 
	[, Serialize = <New Name>]
	```
Ejemplo: 





```wl
Cl is Class
	// Serialized member
	SerializedMember is int 
	// Non-serialized member
	NonSerializedMember is string, Serialize = False  
	// Member renamed during the serialization
	RenamedMember is int, Serialize = "NewMemberName" 
END
```

<a name="NOTE4_5"></a>


### La vinculación de los datos
<a name="vinculacion_los_datos_ELTPARAGRAPHE000287"></a>

El enlace de datos está disponible para los miembros de la clase. 
<a name="NOTE4_6"></a>


### Generación de los métodos para acceder a un miembro de la clase (guardado para compatibilidad con versiones anteriores)
<a name="generacion_los_metodos_para_acceder_miembro_clase_guardado_para_compatibilidad_con_versiones_anteriores_ELTPARAGRAPHE000294"></a>

El editor de código se utiliza para generar los métodos para acceder a un miembro de la clase. Para esto:

1. Declare a su miembro en la clase si aún no lo ha hecho.

2. En el panel "Código", abra la clase description.

3. Seleccione el miembro y elija "Generar los métodos de acceso" en el menú contextual. <br>![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=7&name=Methode_acces.gif)


4. Se generan automáticamente dos nuevos métodos en la clase:

	- Escribe_&lt;Nombre del miembro&gt;

	- Reads_&lt;Nombre del miembro&gt;





Estos métodos se pueden utilizar para acceder al miembro.

<a name="NOTE5"></a>
<a name="NOTE5_1"></a>


## Declaración de las constantes de clase
<a name="declaracion_las_constantes_clase_ELTTEXTE000965"></a>


### Sintaxis
<a name="sintaxis_ELTPARAGRAPHE000314"></a>


```txt
CONSTANT <Constant name> = <Constant value>

CONSTANT 
	<Constant name> = <Constant value>
	<Constant name> = <Constant value>
END
```

<a name="NOTE5_2"></a>


### Sintaxis detallada
<a name="sintaxis_detallada_ELTPARAGRAPHE000321"></a>**&lt;Nombre constante&gt;**
Nombre definido para la constante. Una constante es pública.

**&lt;Valor constante...**
Valora associated con la constante. Este valor no cambiará durante la ejecución del programa.<a name="NOTE5_3"></a>


### Ejemplo
<a name="ejemplo_ELTPARAGRAPHE000336"></a>


```wl
CONSTANT K=5
CONSTANT 
	K=5
	J=10
END
```


<a name="NOTE6_Singleton"></a>
<a name="NOTE6_1_Singleton"></a>


## Declarando un singleton
<a name="declarando_singleton_ELTTEXTE001001"></a>
A **Singleton** es una declaración de instancia de clase única. 

Para declarar una instancia de clase única y asignarla inmediatamente, utilice la siguiente sintaxis:

```txt
<Name singleton class> is Class
GLOBAL
	<Instance name> is <Name singleton class>
END
```
**Ejemplo**


```wl
CSingleton is Class
GLOBAL
	m_Singleton is CSingleton
END
```


<a name="NOTE6"></a>
<a name="NOTE6_1"></a>


## Creación y declaración de los métodos de clase
<a name="creacion_declaracion_los_metodos_clase_ELTTEXTE001025"></a>


### Creación de un método de clase
<a name="creacion_metodo_clase_ELTPARAGRAPHE000359"></a>

Para crear un método de clase:

1. Visualizar el panel "Explorador de proyectos" si es necesario: en el panel "Inicio", en el grupo "Entorno", expanda "Paneles" y seleccione "Project explorer"..

2. En el panel "Explorador del proyecto", mostrar las clases disponibles: Para ello, expanda la carpeta "Clases".

3. Seleccione la clase deseada. Haga clic con el botón derecho del ratón para abrir el menú contextual de la clase y seleccione "Nuevo método".

4. En la ventana que aparece:

	- Escriba el nombre del método.

	- Especifique si el comentario del prototipo del método se debe generar automáticamente (opción "Generar un comentario de encabezado").
			Para más detalles sobre los comentarios generados automáticamente, véase [automatic documentación de procedimientos y métodos](../Motscles/1513006.md).

	- Especificar si el método es público, protegido o privado. Para más detalles, consulte la sección "**Access**" del [Sintaxis detallada](#NOTE6_3).

	- Especificar si el método es abstract. Para más detalles, consulte la sección "**abstract**" del [Sintaxis detallada](#NOTE6_3).

	- Especifique si el método es global. Para más detalles, consulte la sección "**Global**" del [Sintaxis detallada](#NOTE6_3).

	- Valide.




5. El editor de código muestra el código del nuevo método.



<a name="NOTE6_2"></a>


### Sintaxis para declarar un método
<a name="sintaxis_para_declarar_metodo_ELTPARAGRAPHE000407"></a>


```txt
PROCEDURE [<Access>] [Global] [VIRTUAL] [ABSTRACT] 
	<Method name> ([<Parameter1>, ...[<ParameterN>]]) [<Extension attributes>]
```

<a name="NOTE6_3"></a>


### Sintaxis detallada
<a name="sintaxis_detallada_ELTPARAGRAPHE000414"></a>

**&lt;Acceso&gt;: Opcional**

Se utiliza para restringir el acceso a este método. Hay 3 niveles disponibles: 

- **Privado**: el método sólo puede ser llamado desde un código de la clase

- **Protegido**: el método sólo puede llamarse desde un código de la clase o desde un código de una clase derivada

- **Public** (por Default): el método puede ser llamado desde cualquier código de la clase o proyecto.




Global **Global: Opcional**

Define un método global. Este método no funcionará en un objeto específico: no se requiere ningún objeto de clase para llamar a este método. Esta clase también puede ser utilizada para manipular los miembros globales.

**Virtual: Opcional**

Define un método virtual. Un método anulado es virtual por Default.

**abstract: Opcional**

Define un método de abstract. Un método abstract es un método que debe redefinirse absolutamente en las clases derivadas. Un método no es abstract de Default. 

**&lt;Nombre de método&gt;**

Nombre que identifica el método.

**&lt;Parámetro 1&gt; ... &lt;Parámetro N&gt;**

Parámetros opcionales para pasar al método.

**&lt;Atributo de extensión&gt;**

Atributos de extensión utilizados para definir las opciones de gestión del editor de código. Los atributos de extensión disponibles son: 

- &lt;zombie [comment = "text"]>: Se utiliza para definir un método obsoleto (también llamado método zombie). La palabra clave opcional **comment** se utiliza para especificar el texto que se mostrará en el error de compilación associated con el método obsoleto. Para obtener más información, consulte [Procedimientos de zombie](../Motscles/1513008.md).

- &lt;sin paso a paso&gt;: Se usa para especificar que este método será ignorado por el depurador al depurar en modo "Paso a paso"..  



```wl
GLOBAL PROCEDURE ViewObject(obj)
// The private member ClassSize is accessible from the class code
Info("Name: " + Obj:Name + "Size: " + Obj:ClassSize)
```



```wl
GLOBAL FUNCTION Attempt(a1,b1)
RESULT a1 + b1
```

<a name="NOTE6_4"></a>


### Alcance identificado por la Color de la barra
<a name="alcance_identificado_por_color_barra_ELTPARAGRAPHE000486"></a>

Un método de una clase puede ser público, privado o protegido. 

El color de inicio de la barra de Event cambia según el alcance del método: 

- rojo comienzo de la barra: método privado. 

- inicio de la barra de naranja: método protegido. 

- inicio estándar de la barra: método público. 

<br>![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=7&name=Code_Couleurs_methode.gif)

<a name="NOTE6_5"></a>


### Borrar un método
<a name="borrar_metodo_ELTPARAGRAPHE000501"></a>

Un método puede borrarse: 

- desde el panel "Explorador de proyectos" ("Eliminar" en el menú contextual)

- desde el editor de códigos, a través de la el menú contextual de la barra de método ("Borrar"). 




<a name="NOTE7"></a>
<a name="NOTE7_1"></a>


## Creación y declaración de propiedades
<a name="creacion_declaracion_propiedades_ELTTEXTE001073"></a>


### Presentación
<a name="presentacion_ELTPARAGRAPHE000515"></a>

Una Property es un elemento de código con dos eventos: 

- un evento para recuperar el valor,

- un evento para asignar el valor.




Un Property puede ser usado como un Variable o como un miembro (recuperación directa del valor, asignación a través del símbolo '=', ...). En tiempo de ejecución:

- Cualquier operación que requiera la lectura de la propiedad ejecuta el evento para recuperar el valor. Este evento debe devolver un valor.

- Cualquier operación que requiera la escritura de la propiedad ejecuta el evento para asignar el valor. Este evento debe procesar un parámetro.




![Universal Windows 10 App](https://doc.pcsoft.fr/ext/images/us/UNIVERSALAPP.png) Las propiedades de clase no están disponibles.
<a name="NOTE7_2"></a>


### Creando una clase Property
<a name="creando_una_clase_property_ELTPARAGRAPHE000534"></a>

Para crear una clase Property:

1. Visualizar el panel "Explorador de proyectos" si es necesario: en la pestaña "Inicio", en el grupo "Entorno", despliegue "Paneles" y seleccione "Explorador de proyectos".

2. En el panel "Explorador del proyecto", mostrar las clases disponibles (ampliar la carpeta "Clases").

3. Seleccione la clase deseada. Abra el menú contextual de la clase y seleccione la opción "Nueva propiedad".

4. En la ventana que se abre, introduzca el nombre de la Property y valide.

5. El editor de código muestra los eventos relacionados con la propiedad:

	- Event para recuperar la Property. Esta Event contiene: 

		- la palabra clave "RESULT" que permite obtener el valor de la propiedad.

		- la palabra clave "RETURN =" para devolver el valor de la propiedad.




- Event por asignar la Property. Este evento se permite dar un valor a la propiedad. Este valor se pasa como parámetro. Este evento no debe devolver resultados.




**Observación**: También se puede crear una nueva Property en el menú contextual de un miembro. En este caso, los procedimientos automáticamente manipular el miembro especificado.
<a name="NOTE7_3"></a>


### La vinculación de los datos
<a name="vinculacion_los_datos_ELTPARAGRAPHE000567"></a>

El enlace de datos está disponible para las propiedades de las clases y los miembros de la llamada.
<a name="NOTE7_4"></a>


### Derechos de acceso a una Property
<a name="derechos_acceso_una_property_ELTPARAGRAPHE000574"></a>

La Property no puede ser leída si la recuperación de la Event está vacía.. Aparecerá un error de compilación en el editor y se producirá un error en tiempo de ejecución.

La propiedad no puede escribirse si la asignación Event está vacía. Aparecerá un error de compilación en el editor y se producirá un error en tiempo de ejecución. 

Los eventos de recuperación y asignación pueden ser públicos, privados o protegidos. Los derechos de acceso de la Property corresponden a los derechos menos restrictivos de los dos eventos. Para obtener más información, consulte [Derechos de acceso a una Property](../POO/6010011.md).

Las propiedades pueden ser globales. Una Property es global para la clase cuando los eventos de recuperación y asignación son globales. Si uno de los eventos es global, todos los eventos deben ser globales, de lo contrario se muestra un error de compilación.
<a name="NOTE7_5"></a>


### Miembros y propiedades
<a name="miembros_propiedades_ELTPARAGRAPHE000590"></a>

Una Property y un miembro existente pueden tener el mismo nombre. En este caso, las órdenes de prioridad son las siguientes:

- en los eventos de la Property, el miembro tiene prioridad sobre la Property.

- en el resto del código, la Property tiene prioridad sobre el miembro.




Por lo tanto, un miembro puede ser reemplazado por una Property sin modificar el código que utiliza el miembro.

El evento de una Property no puede utilizar de forma recursiva la Property. Si ningún miembro tiene el mismo nombre que la Property, el uso de la Property en uno de sus eventos causará un error de compilación.
<a name="NOTE7_6"></a>


### Herencia
<a name="herencia_ELTPARAGRAPHE000604"></a>

Las propiedades de las clases base se heredan en las clases derivadas.

Una Property puede ser sobrecargada en una clase derivada. Los eventos de una Property siempre se consideran como virtuales: se ignora el uso de la palabra clave VIRTUAL.

La herencia múltiple está soportada por las propiedades. Las siguientes sintaxis pueden utilizarse para llamar a las propiedades de las clases base:

- ***Ancestor.Property*** si la clase derivada tiene una sola clase base

- ***BaseClass.Property*** en todos los casos.



<a name="NOTE7_7"></a>


### Pasando propiedades como parámetros a una función de WLanguage o Procedure
<a name="pasando_propiedades_como_parametros_una_funcion_wlanguage_procedure_ELTPARAGRAPHE000618"></a>

**Si el parámetro es pasado por reference (caso de Default) y no se escribe a mano:**

- la Property se pasa como parámetro.

- no se ejecutan eventos asociados a la propiedad durante la llamada.

- la lectura del parámetro formal ejecuta el código de recuperación de valor.

- la escritura del parámetro formal ejecuta el código de asignación de valor.




**Si el parámetro es por valor pasado (LOCAL) y no mecanografiado:**

- el valor de Property se pasa como parámetro.

- el código de recuperación del valor se ejecuta durante la llamada.

- la lectura del parámetro formal accede al valor pasado durante la llamada y no ejecuta el código de recuperación de valor. 

- la escritura del parámetro formal modifica el valor pasado durante la llamada y no ejecuta el código de asignación de valor. 




**Si el parámetro es pasado por reference (caso de Default) y se teclea:**

- la Property se pasa como parámetro.

- el tipo de la propiedad debe ser correcto. De lo contrario, se produce un error WLanguage.

- no se ejecutan eventos asociados a la propiedad durante la llamada.

- la lectura del parámetro formal ejecuta el código de recuperación de valor.

- la escritura del parámetro formal ejecuta el código de asignación de valor.




**Si el parámetro es por valor pasado (LOCAL) y con tipo específico:**

- el valor de Property se pasa como parámetro.

- el código de recuperación del valor se ejecuta durante la llamada.

- si es necesario, el valor de la propiedad se convierte en el tipo del parámetro.

- la lectura del parámetro formal accede al valor pasado durante la llamada y no ejecuta el código de recuperación de valor. 

- la escritura del parámetro formal modifica el valor pasado durante la llamada y no ejecuta el código de asignación de valor. 




<a name="NOTE8"></a>
<a name="NOTE8_1"></a>


## Instancias de clase con contexto HFSQL independiente
<a name="instancias_clase_con_contexto_hfsql_independiente_ELTTEXTE001133"></a>


### Presentación
<a name="presentacion_ELTPARAGRAPHE000656"></a>Una copia del contexto HFSQL puede ser associated con una instancia de clase. Todos los accesos al HFSQL realizados desde los métodos y propiedades de la clase (llamadas a funciones o acceso a los registros) operan sobre la copy del contexto de la instancia de la clase.
![Universal Windows 10 App](https://doc.pcsoft.fr/ext/images/us/UNIVERSALAPP.png)![Java](https://doc.pcsoft.fr/ext/images/us/JAVA.png) Esta funcionalidad no está disponible.
<a name="NOTE8_2"></a>


### Sintaxis
<a name="sintaxis_ELTPARAGRAPHE000667"></a>Se debe utilizar la siguiente sintaxis:


```txt
// Declare the class
IndependentHFSQLClass is Class, independent <light/full> HFSQL context
END
```
o


```txt
// Declare the class
IndependentHFSQLClass is Class
	<independent light/full HFSQL context>

END
```
Por ejemplo: 


```wl
IndependentHFSQLClass is Class, independent light HFSQL context
```


**Light/Full** parámetro: 

- La palabra clave "ligero" desencadena la inmediata copy de parte del contexto HFSQL. 
	Solo se almacenan los directorios que contienen los archivos de datos en modo HFSQL Classic y/o las conexiones en modo HFSQL Client/Server. 

- La palabra clave "completo" desencadena la inmediata copy del contexto HFSQL.
	Se recomienda si el hilo debe tener en cuenta las posiciones actuales en los archivos y consultas del contexto llamador.



<a name="NOTE8_3"></a>


### aprovechamiento
<a name="aprovechamiento_ELTPARAGRAPHE000693"></a>

El contexto HFSQL de la instancia se crea copiando el contexto actual durante la ejecución del constructor.

Los operadores **=** y **&lt;=** entre dos instancias con contexto HFSQL independiente copy el contenido del contexto HFSQL.

No se recomienda utilizar instancias de clase con contextos HFSQL independientes para simular un alias en un único archivo HFSQL o en una Record específica de un archivo HFSQL. De hecho, copiar el contexto HFSQL afecta a todos los elementos del contexto (archivos, vistas, consultas, conexiones,...) y puede llevar bastante tiempo.

Una instancia de clase con un contexto HFSQL independiente sólo puede ser usada en el hilo que ejecuta el constructor. Para manipular una instancia de clase con contexto HFSQL independiente en varios hilos, debes hacerlo:

- asignar una nueva instancia de la clase,

- realizar una copy de la instancia de la fuente con el operador **=** o **&lt;=**.




<a name="NOTE9"></a>
<a name="NOTE9_1"></a>


## Notas
<a name="notas_ELTTEXTE001175"></a>


### Leyenda de los iconos utilizados
<a name="leyenda_los_iconos_utilizados_ELTPARAGRAPHE000710"></a>

Los diferentes iconos utilizados son los siguientes:


|   |   |
| --- | --- |
| <br>![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=7&name=ProcedurePublique.gif)<br> | Público Procedure |
| <br>![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=7&name=ProcedureProtegee.gif)<br> | Protegido Procedure |
| <br>![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=7&name=ProcedurePrivee.gif)<br> | Soldado Procedure |
| <br>![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=7&name=MethVirtPublique.gif)<br> | Método público virtual |
| <br>![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=7&name=MethVirtProtegee.gif)<br> | Método virtual protegido |
| <br>![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=7&name=MethVirtPrivee.gif)<br> | Método virtual privado |
| <br>![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=7&name=MethStatPublique.gif)<br> | Método público global |
| <br>![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=7&name=MethStatProtegee.gif)<br> | Método global protegido |
| <br>![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=7&name=MethStatPrivee.gif)<br> | Método privado global |
| <br>![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=7&name=Constante.gif)<br> | Constante |


<a name="NOTE9_2"></a>


### Nuevas características desde la versión 9
<a name="nuevas_caracteristicas_desde_version_9_ELTPARAGRAPHE000768"></a>

Una clase que contiene un miembro del personaje no tiene el mismo comportamiento que en las versiones anteriores. De hecho, los caracteres estaban codificados en 1 byte en las versiones anteriores y en 2 bytes desde la versión 9.

Le recomendamos que utilice el tipo "1 byte entero".




