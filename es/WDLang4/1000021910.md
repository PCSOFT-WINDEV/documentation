
## HJSONToRecord (Función)



<a name="XUse"></a>
<a name="Use"></a>
<a name="description"></a>
Importa datos JSON al registro actual.
<a name="Example1"></a>
<a name="sample_code"></a>

## Ejemplo


```wl
let sString1 = "{ ""FirstName"":""Tintin"", ""FirstName"":[""Milou"", ""IDEFIX""] }"
let b1 = HJSONToRecord(Customer, sString1)
IF ErrorOccurred = True THEN
	// Full message of the main error
	Trace(HErrorInfo())
	// Browse the sub-errors (if any)
	FOR i = 1 _TO_ ErrorInfo(errNumberSubError)
		// Full message of each sub-error
		Trace("Sub-error " + i + ": " + ErrorInfo(errMessage, i))
	END
END
HAdd(Customer)
```

<a name="XSYNTAX"></a>

## Sintaxis
<a name="SYNTAX1"></a>

`<Result> = HJSONToRecord(<Data file> , <JSON data> [, <List of items to import> [, <List of "items" to import>]])`
---

**`<Result>: (booleano)`**



- <u><u><u><u>True</u></u></u></u> si no se ha encontrado ningún problema durante la importación Process,

- <u><u><u><u>False</u></u></u></u> en caso contrario. La función [HErrorInfo](../WDLang4/3044071.md) permite obtener más detalles sobre el problema.




**`<Data file>: (Cadena de caracteres opcional)`**

Nombre del archivo de datos HFSQL utilizado. Los datos de JSON se importan en la actual Record. 

**`<JSON data>: (Cadena de caracteres) o JSON Variable)`**

Los datos de JSON serán convertidos a Record. Estos datos pueden corresponder a una cadena JSON o a una [JSON](../Motscles/1000023611.md) Variable.  

**`<List of items to import>: (Cadena de caracteres opcional)`**

Lista de nombres de artículos en el archivo de datos a los que se realizará la importación. Los nombres pueden ser delimitados por comillas simples y están separados por comas o caracteres CR (Carriage Return). Los nombres de elementos de tipo clave compuesta, memo binario y binario se ignoran. 
Los elementos no importados se inicializarán con el valor predeterminado descrito en el análisis. 
Si este parámetro no se especifica o corresponde a una cadena vacía (""), todos los elementos se importan (excepto las claves compuestas, los elementos binarios y los memorandos binarios) en el orden en que se crearon en el archivo físico.

**`<List of "items" to import>: (Cadena de caracteres opcional)`**

Lista de nombres de artículos de JSON para importar. Si este parámetro no se especifica o es una cadena vacía (""), se importan todos los elementos de JSON.
Si no se encuentra un elemento restante, se devuelve un error no fatal.



<a name="NOTE0"></a>
<a name="NOTE0_1"></a>

## Observaciones


### Tipo de importación
<a name="tipo_importacion_ELTPARAGRAPHE000080"></a>

Si se especifica la lista de artículos: la importación encontrará los "JSON items" con el mismo nombre que los artículos.

Ejemplo: El archivo de datos descrito en el análisis contiene los siguientes elementos: ÍTEM 1, ÍTEM 2, ... El fichero JSON debe tener la siguiente estructura:


```txt
{"File":
	{
		"Item1":Data of item 1,
		"Item2":Data of item 2,
		...
		}
}
```
Los nombres de los elementos encontrados en el archivo JSON que no existen en el análisis o que no están especificados en la lista de elementos serán ignorados durante la importación.

Si no se especifica la lista de elementos de JSON, el valor de los elementos de JSON se incluye en el elemento del archivo de datos HFSQL que se denomina como el elemento JSON.
<a name="NOTE0_2"></a>


### Codificación
<a name="codificacion_ELTPARAGRAPHE000096"></a>

La codificación utilizada corresponde al estándar JSON: 

- Codificación ASCII de 7 bits, es decir, los primeros 128 caracteres, caracteres sin acento,

- codificación JSON de los otros caracteres: "\\u" seguido del código de caracteres en hexadecimal de 4 bytes. 




Ejemplo: para "é" (código ASCII 233, código hexadecimal E9), la codificación corresponde a "\\u00E9".

<a name="XComponent"></a>

## Clasificación Lógica de negocio / UI:
Lógica de negocio
## Componente:
wd280hf.dll
