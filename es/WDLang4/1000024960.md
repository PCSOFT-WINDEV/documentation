


## &lt;Fuente&gt;.Filter (Función)



<a name="XUse"></a>
<a name="Use"></a>
<a name="description"></a>
Define y activa un filtro en un archivo de datos, vista o consulta.

Después de su ejecución, los casos más comunes son los siguientes:

- no se puede crear el filtro: **&lt;Fuente&gt;.Filter** devuelve una cadena vacía. [HError](../WDLang4/3044088.md) devuelve el identificador del error.

- se crea el filtro: la función **&lt;Fuente&gt;.Filter** devuelve la clave de búsqueda adecuada que se utilizará para navegar por el archivo de datos, la vista o la consulta.





<a name="Example1"></a>
<a name="sample_code"></a>

## Ejemplo


```wl
// Simple filter with condition: 
// Find the customers of a city

SearchKey is string
mycity is string

mycity = "MONTPELLIER"
SearchKey = Customer.Filter("CITY='" + mycity + "'")
Customer.ReadFirst(SearchKey)
WHILE Customer.Out() = False
	// Process the record 
	...
	Customer.ReadNext(SearchKey)
END
// Cancels the filter
Customer.DeactivateFilter()
```

```wl
// Filter performed with a bounded search key and a condition: 
// the search key is fixed

SearchKey is string
// Filters the invoices found between 1/1/2005 and
// 12/31/2005, whose total is greater than 1500 Euros IOT
// with a discount whose type is passed as parameter (text item)
SearchKey = Invoice.Filter(InvoiceDate, "20050101", "20051231", ...
	StringBuild("TotalIOT>1500 AND DiscountType='%1'" + , ...
	Replace(sDiscountType, "", "\")))
// The Replace function is used to prefix the quotes
// contained in sDiscountType with a backslash
IF SearchKey <> "" THEN
	Invoice.ReadFirst(SearchKey)
	WHILE Invoice.Out() = False
		// Process the record: send a thank you letter
		Send_Letter()
	Invoice.ReadNext(SearchKey)
	END
END
...
// Cancels the filter
Invoice.DeactivateFilter()
```

<a name="XSYNTAX"></a>
<a name="SYNTAX1"></a>

## Sintaxis

### Filtro construido con una clave de búsqueda limitada y una condición

`<Result> = <Source>.Filter(<Search key> , <Lower bound> [, <Upper bound> [, <Selection condition>]])`
---

**`<Result>: (Cadena de caracteres)`**

Campo de navegación. Corresponde a: 

- la clave de búsqueda del archivo de datos si el filtro está activado. 

- una cadena vacía ("") si no se puede establecer el filtro.




**`<Source>: (Tipo de fuente especificada)`**

Nombre del archivo de datos, vista HFSQL o consulta utilizada.

**`<Search key>: (Cadena de caracteres)`**

Nombre del elemento clave utilizado para el bucle de el archivo de datos, vista o consulta. Este elemento debe ser una clave de búsqueda de archivo, vista o consulta de datos. Los límites inferior y superior se aplicarán a este ítem.

**`<Lower bound>: (Tipo de campo de búsqueda)`**

Valor mínimo (incluido) del elemento de búsqueda (si la clave de búsqueda se define con una iteración en orden ascendente en el análisis). Los registros correspondientes a este valor mínimo se incluirán en el filtro. Para una iteración descendente (es decir, si la clave de búsqueda se define con una iteración en orden descendente en el análisis), es el valor máximo del elemento de búsqueda. 
El tipo de este parámetro debe corresponder al tipo de elemento de búsqueda. Por ejemplo, si el elemento de búsqueda es una cadena, el límite inferior también debe ser una cadena.

**`<Upper bound>: (Tipo de campo de búsqueda, parámetro opcional)`**

Valor máximo (incluido) del elemento de búsqueda (iteración ascendente). Los registros correspondientes a este valor máximo se incluirán en el filtro. El tipo de este parámetro debe corresponder al tipo de elemento de búsqueda. Por ejemplo, si el elemento de búsqueda es una cadena, el límite superior también debe ser una cadena. 
Para una iteración descendente, es el valor mínimo del elemento de búsqueda.
Si no se especifica este parámetro, el límite superior corresponde al valor de &lt;Límite inferior&gt;.

**`<Selection condition>: (Cadena de caracteres opcional)`**

Condición de selección para crear el filtro (véase Notas). Esta condición de selección puede ser una cadena de caracteres Ansi o Unicode.


<a name="SYNTAX2"></a>

### Filtro construido con una condición

`<Result> = <Source>.Filter(<Selection condition>)`
---

**`<Result>: (Cadena de caracteres)`**

Campo de navegación. Corresponde a: 

- la clave de búsqueda del archivo de datos si el filtro está activado

- una cadena vacía si el filtro no se puede implementar




**`<Source>: (Tipo de fuente especificada)`**

Nombre del archivo de datos, vista HFSQL o consulta utilizada.

**`<Selection condition>: (Cadena de caracteres)`**

Condición de selección utilizada para crear el filtro (véanse las Notas). Esta condición de selección puede ser una cadena de caracteres Ansi o Unicode.



<a name="NOTE0"></a>
<a name="NOTE0_1"></a>

## Observaciones


### Límite inferior y límite superior de un elemento clave de Texto o Clave Compuesta
<a name="limite_inferior_limite_superior_elemento_clave_texto_clave_compuesta_ELTPARAGRAPHE000300"></a>

Si el límite inferior y el límite superior son iguales:

- para realizar **un filtro de búsqueda exacta en un valor**, solo se debe indicar el valor en el parámetro "Límite mín".
	Por ejemplo, para seleccionar los clientes cuyo nombre corresponde a "Smith":
	
	```wl
	Customer.Filter(Name, "Smith")
	```

	El cliente "Durán" no se seleccionará.

- para implementar **un filtro genérico sobre un valor**, debe hacerlo:

	- completar el límite inferior con la constante *hMinVal* para darle el valor mínimo.

	- completar el límite superior con la constante *hMaxVal* para darle el valor máximo.


 Por ejemplo, para seleccionar los clientes cuyo apellido comienza con "Smith":
	
	```wl
	Customer.Filter(Name, "Smith" + hMinVal, "Smith" + hMaxVal)
	```

	Se seleccionarán los clientes "Durá" y "Durán".


Observaciones:

- La constante *hMinVal* es equivalente a Charact( 0).

- La constante *hMaxVal* es equivalente a Charact( 255).



<a name="NOTE0_2"></a>


### Filtro e iteración filtrada
<a name="filtro_iteracion_filtrada_ELTPARAGRAPHE000342"></a>

Después de ejecutar la función **&lt;Fuente&gt;.Filter**, la navegación del archivo de datos debe realizarse en el elemento devuelto por la función **&lt;Fuente&gt;.Filter**. El filtro será ignorado si se utiliza otro elemento para recorrer el archivo de datos.

Cuando se define y habilita un filtro en un archivo de datos (vista o consulta), todos los registros leídos corresponden al filtro. Si no hay ninguna otra Record que corresponda al filtro durante la iteración:

- [&lt;Fuente&gt;.Out](../WDLang4/1000024605.md) devuelve <u><u><u><u>True</u></u></u></u>.

- la actual Record corresponde a la última Record leída con el filtro.




Por ejemplo:

| En un archivo de datos filtrado, después de la función: | el actual Record es: |
| --- | --- |
| HReadFirst | el primer archivo Record correspondiente al filtro |
| HReadLast | el último archivo Record correspondiente al filtro |
| **HReadNext** (or **HForward**) | el siguiente Record (o el siguiente n-ésimo Record) correspondiente al filtro |
| **HReadPrevious** (o **HBackward**) | el anterior Record (o el anterior n-ésimo Record) correspondiente al filtro |


<a name="NOTE0_3"></a>


### Condición de selección
<a name="condicion_seleccion_ELTPARAGRAPHE000392"></a>

La sintaxis general de una condición tiene el siguiente formato:

"ApellidoCli&gt;'Durá' y (CódigoPos=34 o CódigoPos=32)"

Los operadores soportados dependen del tipo de los elementos utilizados en la condición:


|   |   |   |
| --- | --- | --- |
| &gt; | Mayor que | Válido para todos los tipos |
| &gt;= | Mayor que o igual a | Válido para todos los tipos |
| &lt; | Menor que | Válido para todos los tipos |
| &lt;&gt; | Diferente | Válido para todos los tipos |
| &lt;= | Menor que o igual a | Válido para todos los tipos |
| ] | Contiene: distingue mayúsculas y minúsculas | Válido solo para cadenas |
| ]= | Comienza por: distingue mayúsculas y minúsculas | Válido solo para cadenas |
| ~] | Contiene: no distingue entre mayúsculas y minúsculas | Válido solo para cadenas |
| ~~ | Igualdad muy flexible: no distingue entre minúsculas y mayúsculas, ignora los espacios antes y después de la cadena, acentos en minúsculas, espacios y puntuación dentro de las cadenas. | Válido solo para cadenas |
| ~= | Casi igual a: ignora espacios a la derecha, acentos, y mayúsculas y minúsculas | Válido solo para cadenas |
| = | Estrictamente igual a | Válido para todos los tipos |

![Java](https://doc.pcsoft.fr/ext/images/us/JAVA.png) Los operadores ~~ y ~= no deben utilizarse. Estos operadores no están permitidos.

**Notas sobre la condición de selección**:

- Las cuerdas constantes deben estar encerradas en comillas simples.

- Si el nombre de la posición contiene comillas simples, deben ser dobladas. 
	Por ejemplo: ‘Elemento‘‘con‘‘comillas‘

- Las comparaciones entre strings se realizan según los parámetros especificados para los índices.

- Los memos binarios y las claves compuestas no pueden formar parte de una condición de selección. 
	Para las claves compuestas, se recomienda utilizar la primera sintaxis. No se puede utilizar la siguiente sintaxis:
	
	```wl
	FileName.Filter("COMPKEY~]'AAA' AND COMPKEY]='" + ...
		FileName.BuildKeyValue(COMPKEY, 0) + "'")
	```


- Si una cadena de caracteres (constante o Variable) contiene una sola cita, ésta debe estar precedida por una barra invertida ( \\).

- Para optimizar la iteración, utilice [&lt;Fuente&gt;.StatCalculate](../WDLang4/1000025064.md) en el archivo de datos antes de crear el filtro. El motor HFSQL analiza la condición de selección y utiliza estas estadísticas para determinar qué elementos se utilizarán para optimizar la iteración realizada en el archivo de datos.

- Esta condición de selección puede ser una cadena de caracteres Ansi o Unicode.



<a name="NOTE0_4"></a>


### Habilitar/Deshabilitar un filtro
<a name="habilitardeshabilitar_filtro_ELTPARAGRAPHE000509"></a>

[&lt;Fuente&gt;.DeactivateFilter](../WDLang4/1000024218.md) se utiliza para desactivar un filtro.

[&lt;Fuente&gt;.ActivateFilter](../WDLang4/1000023969.md) se utiliza para volver a habilitar un filtro.

El filtro se borra cuando se cierra el archivo de datos (consulta o vista) ([&lt;Fuente&gt;.Close](../WDLang4/1000024958.md) por ejemplo).

Un único filtro puede existir en un momento dado en un archivo de datos (consulta o vista). Si la función **&lt;Fuente&gt;.Filter** se utiliza varias veces, solo se tendrá en cuenta el último filtro: se borrarán los filtros anteriores.
<a name="NOTE0_5"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/us/WD.png)![Universal Windows 10 App](https://doc.pcsoft.fr/ext/images/us/UNIVERSALAPP.png)![Java](https://doc.pcsoft.fr/ext/images/us/JAVA.png)![Código de Usuario (UMC)](https://doc.pcsoft.fr/ext/images/us/MCU.png)![HFSQL Classic](https://doc.pcsoft.fr/ext/images/us/HF.png)![HFSQL Client/Server](https://doc.pcsoft.fr/ext/images/us/HFCS.png)![Procedimientos almacenados](https://doc.pcsoft.fr/ext/images/us/PS.png) 

### Filtro en una clave compuesta
<a name="filtro_una_clave_compuesta_ELTPARAGRAPHE000542"></a>

Se pueden utilizar varios métodos para implementar un filtro en una clave compuesta:

- Método 1: Utilizar una lista de valores en la función **&lt;Fuente&gt;.Filter**.

- Método 2: Utilizando la declaración [FOR EACH](../Motscles/1510013.md).

- Método 3: Llamando a [&lt;Fuente&gt;.BuildKeyValue](../WDLang4/1000024205.md).




Para más detalles sobre cómo utilizar las teclas compuestas en los filtros, véase [Claves compuestas y filtros](../WDLang4/3044178.md).

**Ejemplo de utilización del método 1: Utilizando una lista de valores**.

El valor de la clave compuesta sobre la que se realizará el filtro set se puede construir directamente en **&lt;Fuente&gt;.Filter** utilizando la siguiente sintaxis:


```txt
HFilter(<File name>, <Name of composite key>, 
	[<List of values for the lower bound of composite key>], 
	[<List of values for the upper bound of composite Key>])
```


**Ejemplo**: Buscar todos los registros del archivo CLIENTE cuyos apellidos y nombres están comprendidos entre "Arias" y "Barrera" y "Pablo" y "Teresa".

```wl
Customer.Filter(LastNameFirstName, ["AA", "Philomene"], ["Barnaby", "Tartuffe"])
```
 En este ejemplo, el filtro devuelve "AA", "Zorro" mientras que "Philomene", "Zorro" no.

**Ejemplo**: Buscar todos los registros del archivo de Tareas cuyas tareas estén incluidas entre el 15/03/2021 00:00 y el 25/03/2021 00:00.

```wl
Tasks.Filter(TaskStarDateTaskStartTime, [20210315,0000], [20210325,0000])
```

<a name="NOTE0_6"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/us/WD.png)![Java](https://doc.pcsoft.fr/ext/images/us/JAVA.png)![Código de Usuario (UMC)](https://doc.pcsoft.fr/ext/images/us/MCU.png)![Procedimientos almacenados](https://doc.pcsoft.fr/ext/images/us/PS.png)![OLE DB](https://doc.pcsoft.fr/ext/images/us/OLEDB.png)![Conectores Nativos](https://doc.pcsoft.fr/ext/images/us/AN.png) 

### Archivos de datos no HFSQL
<a name="archivos_datos_hfsql_ELTPARAGRAPHE000598"></a>

- El filtro se puede crear a partir de cualquier elemento (clave o no clave).

- El filtro se activa automáticamente cuando se ejecuta **&lt;Fuente&gt;.Filter**.

- Los cambios realizados con **&lt;Fuente&gt;.Filter** y [&lt;Fuente&gt;.DeactivateFilter](../WDLang4/1000024218.md) sólo se tienen en cuenta cuando se utilizan las siguientes funciones [&lt;Fuente&gt;.ReadFirst](../WDLang4/1000025022.md)/[&lt;Fuente&gt;.First](../WDLang4/1000025048.md), [&lt;Fuente&gt;.ReadLast](../WDLang4/1000025020.md)/[&lt;Fuente&gt;.Last](../WDLang4/1000024217.md) o [&lt;Fuente&gt;.ReadSeekFirst](../WDLang4/1000025034.md)/[&lt;Fuente&gt;.ReadSeekLast](../WDLang4/1000025024.md).




<a name="XComponent"></a>

## Componente:
wd280hf.dll
