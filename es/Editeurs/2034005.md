


## Funciones SQL que pueden utilizarse en las consultas SQL
			



<a name="NOTE1"></a>
<a name="NOTE1_1"></a>


## Presentación
<a name="presentacion_ELTTEXTE003010"></a>
Las siguientes funciones SQL pueden utilizarse en las consultas escritas en código SQL (clasificadas por tema):


|   |   |
| --- | --- |
| <br><br>- extraer caracteres:<br><br><br> | <br><br>- [ELT](#SQL_ELT)<br><br>- [EXTRACTVALUE](#SQL_EXTRACTVALUE)<br><br>- [IZQUIERDA](#SQL_LEFT)<br><br>- [DERECHO](#SQL_RIGHT)<br><br>- [MID](#SQL_MID), <br><br>- [SPLIT_PART](#SQL_SPLITPART)<br><br>- [SUBSTR](#SQL_MID) y [SUBCADENA](#SQL_MID)<br><br><br> |
| <br><br>- borrar caracteres:<br><br><br> | <br><br>- [BTRIM](#SQL_BTRIM)<br><br>- [LTRIM](#SQL_LTRIM)<br><br>- [RTRIM](#SQL_RTRIM)<br><br>- [TRIM](#SQL_TRIM)<br><br><br> |
| <br><br>- personajes sustitutos:<br><br><br> | <br><br>- [OVERLAY](#SQL_OVERLAY)<br><br>- [SUSTITUIR](#SQL_REPLACE)<br><br>- [REVERSE](#SQL_REVERSE)<br><br>- [TRADUCIR](#SQL_TRANSLATE)<br><br><br> |
| <br><br>- fusionar cadenas:<br><br><br> | <br><br>- [CONCAT](#SQL_CONCAT)<br><br>- [GROUP_CONCAT](#SQL_GROUP_CONCAT)<br><br>- [STRING_AGG](#SQL_STRING_AGG)<br><br><br> |
| <br><br>- relleno de la cadena:<br><br><br> | <br><br>- [LPAD](#SQL_LPAD)<br><br>- [REPETIR](#SQL_REPEAT)<br><br>- [RPAD](#SQL_RPAD)<br><br>- [ESPACIO](#SQL_SPACE)<br><br><br> |
| <br><br>- convertir en cadena:<br><br><br> | <br><br>- [TO_CHAR](#SQL_TO_CHAR)<br><br>- [CHAR](#SQL_CHAR)<br><br>- [CRH](#SQL_CHR)<br><br>- [CAST](#SQL_CAST)<br><br>- [CONVERTIR](#SQL_CONVERT)<br><br><br> |
| <br><br>- cambiar el caso de una cadena:<br><br><br> | <br><br>- [INITCAP](#SQL_INITCAP)<br><br>- [LOWER](#SQL_LOWER)<br><br>- [SUPERIOR](#SQL_UPPER)<br><br>- [LCASE](#SQL_LCASE)<br><br>- [UCASE](#SQL_UCASE)<br><br><br> |
| <br><br>- longitud de la cadena:<br><br><br> | <br><br>- [LEN](#SQL_LEN)y [LONGITUD](#SQL_LENGTH)<br><br>- CHARACTER_LENGTH, CHAR_LENGTH y BYTE_LENGTH<br><br><br> |
| <br><br>- posición del string:<br><br><br> | <br><br>- [INSTR](#SQL_INSTR)<br><br>- [CAMPO](#SQL_FIELD)<br><br>- [FIND_IN_set](#SQL_FIND_IN_SET)<br><br>- [PATINDEX](#SQL_PATINDEX)<br><br>- [POSICIÓN](#SQL_POSITION)<br><br><br> |
| <br><br>- número de registros en un archivo:<br><br><br> | <br><br>- [CUENTA](#SQL_COUNT)<br><br><br> |
| <br><br>- calcular valores numéricos:<br><br><br> | <br><br>- [AVG](#SQL_AVG)<br><br>- [MÁX](#SQL_MAX)<br><br>- [MÍN](#SQL_MIN)<br><br>- [SUMA](#SQL_SUM)<br><br>- [CADA](#SQL_EVERY)<br><br><br>Consulte la [funciones matemáticas SQL](../Editeurs/2034002.md). |
| <br><br>- seleccionar los primeros o los últimos n registros n registros:<br><br><br> | <br><br>- [ARRIBA](#SQL_TOP)<br><br>- [FONDO](#SQL_BOTTOM)<br><br>- [LÍMITE](#SQL_LIMIT)<br><br><br> |
| <br><br>- Código ASCII<br><br><br> | <br><br>- [ASCII](#SQL_ASCII)<br><br><br> |
| <br><br>- Miscelánea<br><br><br> | <br><br>- [UNICODE](#SQL_UNICODE)<br><br>- [USUARIO_ACTUAL](#SQL_CURRENT_USER)<br><br>- [SYSTEM_USER](#SQL_SYSTEM_USER)<br><br>- [NOMBRE DE USUARIO](#SQL_USER_NAME)<br><br><br> |
| <br><br>- phonetic<br><br><br> | <br><br>- [SOUNDEX, SUENA COMO](#SQL_SOUNDEX, SOUND LIKE)<br><br>- [SOUNDEX2, SONIDO2 COMO](#SQL_SOUNDEX2, SOUND2 LIKE)<br><br><br> |
| <br><br>- gestión de datos<br><br><br> | <br><br>- [ADD_MONTHS](#SQL_ADD_MONTHS)<br><br>- [ÚLTIMO DÍA](#SQL_LAST_DAY)<br><br>- [MESES_ENTRE](#SQL_MONTHS_BETWEEN)<br><br>- [NEW_TIME](#SQL_NEW_TIME)<br><br>- [PRÓXIMO_DÍA](#SQL_NEXT_DAY)<br><br>- [RONDA](#SQL_ROUND)<br><br>- [SYSDATE](#SQL_SYSDATE)<br><br>- [TRUNC](#SQL_TRUNC)<br><br>- [DÍA](#SQL_DAY)<br><br>- [DAYOFMONTH](#SQL_DAYOFMONTH)<br><br>- [DAYOFWEEK](#SQL_DAYOFWEEK)<br><br>- [DAYOFYEAR](#SQL_DAYOFYEAR)<br><br>- [FECHA_ACTUAL](#SQL_CURRENT_TIMESTAMP)<br><br>- [GETDATE](#SQL_GETDATE)<br><br>- [ES UNA BUENA IDEA.](#SQL_GETUTCDATE)<br><br>- [ISDATE](#SQL_ISDATE)<br><br>- [MES DE MES](#SQL_EOMONTH)<br><br>- [DATEADD](#SQL_DATEADD)<br><br>- [DATEDIFF](#SQL_DATEDIFF), [DATEDIFF_BIG](#SQL_DATEDIFF)<br><br>- [FECHA DE LAS PARTES](#SQL_DATETIMEFROMPARTS), [DATEFROMPARTS](#SQL_DATEFROMPARTS), [DATEPART](#SQL_DATEPART)<br><br>- [MES](#SQL_YEAR_MONTH), [AÑO](#SQL_YEAR_MONTH)<br><br><br> |
| <br><br>- Funciones de comparison<br><br><br> | <br><br>- [COALESCE](#SQL_COALESCE)<br><br>- [EL MÁS GRANDE](#SQL_GREATEST)<br><br>- [IFNULL, ISNULL](#SQL_NVL_IF_NULL_IS_NULL)<br><br>- [NULLIF](#SQL_NULLIF)<br><br>- [MENOS](#SQL_LEAST)<br><br>- [NVL](#SQL_NVL_IF_NULL_IS_NULL)<br><br><br> |
| <br><br>- Declaración condicional<br><br><br> | <br><br>- [DECODE](#SQL_DECODE)<br><br>- [MAY/MIN](#SQL_CASE)<br><br><br> |
| <br><br>- "Búsqueda de"texto completo<br><br><br> | <br><br>- [PARTIDO CONTRA](#SQL_MATCH AGAINST)<br><br><br> |
| <br><br>- Verificación<br><br><br> | <br><br>- [MD5](#SQL_MD5)<br><br>- [SHA y SHA1](#SQL_SHA)<br><br><br> |
| <br><br>- Expresión regular<br><br><br> | <br><br>- [REGEXP o NO REGEXP (negación)](#SQL_REGEXP)<br><br>- [RLIKE o NO RLIKE (negación)](#SQL_REGEXP)<br><br>- [~ o! ~ (negación)](#SQL_REGEXP)<br><br>- [REGEXP_LIKE o NOT REGEXP_LIKE (negación)](#SQL_REGEXP)<br><br><br> |
| <br><br>- Funciones y operadores Bitwise<br><br><br> | <br><br>- [BITAND, BITOR, BITXOR, BITNOT](#SQL_BITS)<br><br>- [BITANDNOT](#SQL_BITS)<br><br><br> |
| <br><br>- Operadores de JSON<br><br><br> | <br><br>- [JSON_OBJETO](#SQL_JSONOBJECT), [JSON_OBJECTAGG](#SQL_JSONOBJECTAGG)<br><br>- [JSON_ARRAY](#SQL_JSONARRAY), [JSON_ARRAYAGG](#SQL_JSONARRAYAGG)<br><br>- [ES JSON](#SQL_ISJSON)<br><br>- [JSON_EXISTE](#SQL_JSONEXISTS)<br><br>- [JSON_VALOR](#SQL_JSONVALUE)<br><br>- [JSON_CUESTA](#SQL_JSONQUERY)<br><br><br> |


Para más detalles sobre las funciones SQL, consulte la documentación específica de SQL.

Para conocer todos los comandos de SQL (funciones, cláusulas, operadores, etc.) que pueden utilizarse en una consulta SQL gestionada por HFSQL, consulte [Comandos que se pueden utilizar en una consulta SQL gestionada por HFSQL](../Editeurs/2034006.md).

**Observaciones**:

- Estas instrucciones se pueden utilizar:

	- en el código SQL de las consultas creadas en el editor de consultas. Estas consultas se ejecutan con la función [HExecuteQuery](../WDLang4/3044080.md).

	- en el código SQL de las consultas ejecutadas con la función de WLanguage [HExecuteSQLQuery](../WDLang4/3044084.md).




- A menos que se indique lo contrario, estas funciones pueden utilizarse con todos los tipos de fuentes de datos (Oracle, Access, SQL Server, etc.).






<a name="NOTE2"></a>
<a name="NOTE2_1"></a>


## Funciones SQL
<a name="funciones_sql_ELTTEXTE003040"></a>


### Expresión escalar
<a name="expresion_escalar_ELTPARAGRAPHE000452"></a>

Cada parámetro pasado a una de estas funciones SQL corresponde a una expresión (llamada "expresión escalar").

Una expresión puede corresponder a:

- a ***constant***: cadena de caracteres, entero, real, carácter, ... Por ejemplo: 125, 'A', 'Doe'.

- un ***nombre de artículo***.

- los ***resultado de otra función SQL***.

- a ***cálculo en una expresión***. Por ejemplo: "MyItem1+LEN(MyItem2)+1"



<a name="SQL_ELT"></a>
**ELT**
**ELT** devuelve la enésima cadena de caracteres encontrada en una lista de cadenas.

**Formato de uso**:


```txt
ELT(String Number, String1, String2, String3, ...)
```


**Ejemplo**: El siguiente código SQL se utiliza para seleccionar la primera cadena de la lista:


```sql
SELECT ELT(1, 'ej', 'Heja', 'hej', 'foo')
```

<a name="SQL_EXTRACTVALUE"></a>
**EXTRACTVALUE**
**EXTRACTVALUE** se utiliza para cadenas manipular XML. Esta función devuelve el texto (CDATA) del primer nodo de texto que es hijo del elemento correspondiente a la expresión XPATH. Si se encuentran varias correspondencias, el contenido del primer nodo de texto hijo de cada nodo correspondiente a la expresión XPATH se devuelve en el formato de una cadena delimitada por caracteres de espacio. 

**Formato de uso**:


```txt
EXTRACTVALUE(XML fragment, XPATH expression)
```


&lt;Fragmento XML&gt; debe ser un fragmento XML válido. Debe contener una raíz única. 

**Ejemplo**: El siguiente código se utiliza para contar los elementos encontrados: 


```sql
SELECT ExtractValue('<a><b/></a>', 'count(/a/b)') 
FROM CUSTOMER 
WHERE CUUNIKKEY=1
```

<a name="SQL_LEFT"></a>


### IZQUIERDA
<a name="izquierda_ELTPARAGRAPHE000502"></a>**LEFT** extrae la parte izquierda (es decir, los primeros caracteres) de una expresión.
![Conectores Nativos](https://doc.pcsoft.fr/ext/images/us/AN.png) Esta función no se puede utilizar en una fuente de datos PostgreSQL.

**Formato de uso**:


```txt
LEFT(Initial expression, Number of characters to extract)
```


**Ejemplo**: El siguiente código SQL se utiliza para listar los estados de los clientes:


```sql
SELECT LEFT(ZipCode, 2)
FROM CUSTOMER
```

<a name="SQL_RIGHT"></a>


### DERECHO
<a name="derecho_ELTPARAGRAPHE000520"></a>

**RIGHT** extrae la parte derecha (es decir, los últimos caracteres) de una expresión.

**Formato de uso**:


```txt
RIGHT(Initial expression, Number of characters to extract)
```


**Ejemplo**: El siguiente código SQL se utiliza para extraer los últimos cinco caracteres del nombre de los clientes:


```sql
SELECT RIGHT(Name, 5)
FROM CUSTOMER
```

<a name="SQL_MID"></a>


### MID, SUBSTR y SUBSTRING
<a name="mid_substr_substring_ELTPARAGRAPHE000535"></a>

**MID, SUBSTR y SUBSTRING** se utilizan para extraer una subcadena encontrada en el contenido de una expresión a partir de una posición determinada.

Si la posición dada corresponde a:

- un número negativo, la extracción comenzará desde el final de la cadena.

- 0, la extracción comenzará desde el principio de la cadena (equivalente a la posición 1).




Si el valor absoluto de la posición dada (devuelto por [ABS](../Editeurs/2034002.md)) es mayor que el número de caracteres encontrados en la expresión inicial, se devuelve una cadena vacía.

**Ejemplo**: El siguiente código SQL se utiliza para extraer las ciudades cuyo segundo carácter es'A':


```sql
SELECT 
	ZIPCODES.IDCedex AS IDCedex,	
	ZIPCODES.ZipCode AS ZipCode,	
	ZIPCODES.City AS City,	
	SUBSTR(ZIPCODES.City, 2, 1) AS Expression1
FROM 
	ZIPCODES
WHERE 
	SUBSTR(ZIPCODES.City, 2, 1) = 'A'
```

<a name="NOTE2_5"></a>


### MID
<a name="mid_ELTPARAGRAPHE000556"></a>

**MID** sólo puede utilizarse en una fuente de datos Access.

**Formato de uso**:


```txt
MID(Initial expression, Start position, Number of characters to extract)
```


**Ejemplo**: El siguiente código SQL se utiliza para extraer los caracteres 3 y 4 del nombre de los clientes:


```sql
SELECT MID(Name, 3, 2)
FROM CUSTOMER
```

<a name="NOTE2_6"></a>


### SUBSTR
<a name="substr_ELTPARAGRAPHE000571"></a>

**SUBSTR** sólo puede utilizarse en una fuente de datos Oracle, HFSQL Classic o HFSQL Client/Server.

**Formato de uso**:


```txt
SUBSTR(Initial expression, Start position, Number of characters to extract)
```


**Ejemplo**: El siguiente código SQL se utiliza para extraer los caracteres 3 y 4 del nombre de los clientes:


```sql
SELECT SUBSTR(Name, 3, 2)
FROM CUSTOMER
```

<a name="SQL_SPLITPART"></a>
**SPLIT_PART**
**SPLIT_PART** divide una cadena de caracteres según el separador especificado y devuelve la enésima parte de la cadena.

**Formato de uso**:


```txt
SPLIT_PART(Initial Expression, Delimiter, Number of the Part to Extract)
```


**Ejemplo**: El siguiente código SQL se utiliza para extraer las 3 primeras palabras correspondientes a la Address:


```sql
SELECT split_part(ADDRESS,' ',1), split_part(ADDRESS,' ',2),split_part(ADDRESS,' ',3) 
FROM CUSTOMER 
WHERE CUUNIKKEY=2
```

<a name="SQL_BTRIM"></a>


### BTRIM
<a name="btrim_ELTPARAGRAPHE000605"></a>

**BTRIM** borra una cadena de caracteres que se encuentra al principio o al final de una cadena. 

**Formato de uso**:


```txt
BTRIM(<Source string>, [<String to delete>])
```


**Ejemplo**: Borre la cadena "AB" de la cadena "ABRACADABRA".


```sql
BTRIM('ABRACADABRA','AB')
```
En este ejemplo, el resultado es 'RCDR'.
<a name="SQL_LTRIM"></a>


### LTRIM
<a name="ltrim_ELTPARAGRAPHE000621"></a>

**LTRIM** devuelve una cadena de caracteres:

- sin caracteres de espacio a la izquierda.

- sin una lista de personajes.




Los caracteres se borran de izquierda a derecha. Esta eliminación distingue entre mayúsculas y minúsculas (en minúsculas / mayúsculas). Esta eliminación se detiene cuando se encuentra un carácter que no pertenece a la lista especificada.

Las eliminaciones de caracteres específicos no se pueden realizar en una fuente de datos Access o SQL Server.

**Formato de uso**:


```txt
-- Deleting the space characters found on the left
LTRIM(Initial expression)
-- Deleting a list of characters
LTRIM(Initial expression, Characters to delete)
```


**Ejemplo**: El nombre de los clientes está precedido por el título de los clientes ("Sr.", "Sra." o "Sra.").. El siguiente código SQL se utiliza para:

- eliminar el título de cada nombre (las letras "M", "r" y "s", así como el carácter de punto).

- eliminar el carácter de espacio que se encuentra delante del nombre (carácter de espacio que se encontraba entre el título y el nombre).



```sql
-- Deleting characters
SELECT LTRIM(Name, 'Ms.')
FROM CUSTOMER
-- Deleting the space character
SELECT LTRIM(Name)
FROM CUSTOMER
```
En este ejemplo:

| Si el nombre del cliente es: | La cadena devuelta es: |
| --- | --- |
| 'Srta. DOE | "DOE |
| 'Sr. "CLARK | CLARK. |
| 'La señora. Davis | Davis". |


<a name="SQL_RTRIM"></a>


### RTRIM
<a name="rtrim_ELTPARAGRAPHE000664"></a>

**RTRIM** devuelve una cadena de caracteres:

- sin espacios a la derecha.

- sin una lista de personajes.




Los caracteres se borran de derecha a izquierda. Esta eliminación distingue entre mayúsculas y minúsculas (en minúsculas / mayúsculas). Esta eliminación se detiene cuando se encuentra un carácter que no pertenece a la lista especificada.

Las eliminaciones de caracteres específicos no se pueden realizar en una fuente de datos Access o SQL Server.

**Formato de uso**:


```txt
-- Deleting the space characters found on the right
RTRIM(Initial expression)
-- Deleting a list of characters
RTRIM(Initial expression, Characters to delete)
```


**Ejemplo**: El siguiente código SQL se utiliza para borrar los caracteres "E", "U" y "R" que se encuentran a la derecha de los nombres de los clientes:


```sql
SELECT RTRIM(Name, 'EUR')
FROM CUSTOMER
```
En este ejemplo:

| Si el nombre del cliente es: | La cadena devuelta es: |
| --- | --- |
| DUVALEUR". | DUVAL****. |
| DRAFUREUR" (DIBUJANTE) | DRAF. |
| Galteur | Galteur |
| "FOURMALTE | "FOURMALTE |
| BENUR. | BEN |


<a name="SQL_TRIM"></a>


### TRIM
<a name="trim_ELTPARAGRAPHE000712"></a>

**MIC** devuelve una cadena de caracteres:

- sin espacios a la izquierda y a la derecha.

- sin una cadena de caracteres que se encuentre al principio y al final de la cadena.

- sin una cadena de caracteres que se encuentre al principio de la cadena.

- sin una cadena de caracteres que se encuentra al final de la cadena.




Los caracteres se borran de derecha a izquierda. Esta eliminación distingue entre mayúsculas y minúsculas (en minúsculas / mayúsculas). Esta eliminación se detiene cuando se encuentra un carácter que no pertenece al string especificado.

**Formato de uso**:


```txt
-- Deleting the space characters on the right ant on the left
TRIM(Initial expression)
-- Deleting a character string found at the beginning or at the end of a string
TRIM(Initial expression, String to delete)
-- OR
TRIM(BOTH String to delete FROM Initial expression)
-- Deleting a character string found at the beginning of a string
TRIM(LEADING String to delete FROM Initial expression)
-- Deleting a character string found at the end of a string
TRIM(TRAILING String to delete FROM Initial expression)
```

<a name="SQL_OVERLAY"></a>


### OVERLAY
<a name="overlay_ELTPARAGRAPHE000732"></a>

**OVERLAY** sustituye una cadena por otra. 

**Formato de uso**:


```txt
OVERLAY(<Source string> PLACING <String to replace> 
FROM <Start position> [FOR <Length>])
```


Ejemplo: Se utiliza el siguiente código SQL para sustituir "Verde" por "Rojo".: 


```sql
SELECT OVERLAY('Green apple' PLACING 'Red' FROM 7) FROM Product
```

<a name="SQL_REPLACE"></a>


### SUSTITUIR
<a name="sustituir_ELTPARAGRAPHE000747"></a>

**REEMPLAZAR** devuelve una cadena de caracteres:

- reemplazando todas las ocurrencias de una palabra encontrada en una cadena por otra palabra.

- sustituyendo todas las apariciones de una palabra encontrada en una cadena.




La sustitución se realiza de derecha a izquierda. Este reemplazo distingue entre mayúsculas y minúsculas (mayúsculas / minúsculas). Esta sustitución se detiene cuando se encuentra un carácter que no pertenece a la cadena especificada.

**Formato de uso**:


```txt
-- Replacing all the occurrences of a word by another word
REPLACE(Initial expression, String to replace, New string)
-- Deleting all the occurrences of a word
REPLACE(Initial expression, String to delete)
```

<a name="SQL_REVERSE"></a>
**REVERSE**
**RETROCESO** devuelve un string en el que el orden de los caracteres es el orden inverso del string inicial. 

**Formato de uso**:


```txt
REVERSE(Initial string)
```

<a name="SQL_TRANSLATE"></a>


### TRADUCIR
<a name="traducir_ELTPARAGRAPHE000776"></a>

**TRADUCIR** devuelve una cadena de caracteres reemplazando todos los caracteres especificados por otros caracteres. Si un carácter a reemplazar no tiene un carácter correspondiente, este carácter se elimina.

La sustitución se realiza de derecha a izquierda. Este reemplazo distingue entre mayúsculas y minúsculas (mayúsculas / minúsculas).

**Formato de uso**:


```txt
-- Replace characters
TRANSLATE(Initial expression, Characters to replace, New characters)
```


Ejemplo: Se utiliza el siguiente código SQL para reemplazar:

- el carácter "é" por el carácter "e".

- el carácter "è" por el carácter "e".

- el carácter "a" por el carácter "a".

- el carácter "ù" por el carácter "u".





```sql
SELECT TRANSLATE(MyControl, 'éèàù', 'eeau')
FROM MyTable
```

<a name="SQL_CONCAT"></a>


### CONCAT
<a name="concat_ELTPARAGRAPHE000798"></a>

**CONCAT** concatena varias cadenas.

**Formato de uso**:


```txt
CONCAT(String 1, String 2 [,..., String N])
```


![Conectores Nativos](https://doc.pcsoft.fr/ext/images/us/AN.png) CONCAT no es compatible con Sybase.




<a name="SQL_GROUP_CONCAT"></a>


### GROUP_CONCAT
<a name="groupconcat_ELTPARAGRAPHE000816"></a>

**GROUP_CONCAT** concatena los valores no nulos de un elemento de una serie de registros en una cadena.

Cada valor puede separarse utilizando un separador específico (espacios, ";", etc.). 

Esta función permite agrupar los resultados en una Line.

Si se utiliza la sentencia GROUP BY, los distintos valores pueden agruparse por un criterio diferente.

**Formato de uso**:


```txt
GROUP_CONCAT(<Column name> SEPARATOR <Separator>)
```


donde: 

- &lt;Nombre de columna&gt; representa el elemento que contiene los valores a agrupar.

- &lt;Separador&gt; representa el carácter que separa cada valor.




**Ejemplo**: El siguiente código SQL obtiene la lista de días de la semana y días del fin de semana, cada uno en una Line. Los días van separados por punto y coma. 

El "DÍA DE LA SEMANA" que maneja tabla es el siguiente: 

| Tipo de día | NombreDía |
| --- | --- |
| Entre semana | lunes |
| Entre semana | martes |
| Entre semana | miércoles |
| Entre semana | jueves |
| Entre semana | viernes |
| Fin de semana | sábado |
| Fin de semana | domingo |






```sql
SELECT DayType, GROUP_CONCAT(DayName SEPARATOR ';')
FROM DAYOFWEEK
GROUP BY DayType
```


El resultado se mostrará de la siguiente manera: 


```txt
'Weekday', 'Monday;Tuesday;Wednesday;Thrusday;Friday'
'Weekend', 'Saturday;Sunday'
```





<a name="SQL_STRING_AGG"></a>


### STRING_AGG
<a name="stringagg_ELTPARAGRAPHE000885"></a>

**STRING_AGG** se usa para concatenar cadenas no nulas de una lista de valores.

**Formato de uso**:


```txt
STRING_AGG(string, separator)
```
**Ejemplo**: 

El siguiente código devuelve en una sola cadena la lista de modos de entrega separados por ";".


```sql
select string_agg(ltext,';') as str from delivery
```


Contenido del fichero de entrega: 

- Empresa de transporte

- Entrega urgente

- Certificado

- captar




Resultado devuelto por la función STRING_AGG: "Empresa de transporte;Entrega urgente;Certificado;Recogida". 
<a name="SQL_LPAD"></a>


### LPAD
<a name="lpad_ELTPARAGRAPHE000910"></a>

**LPAD** devuelve una cadena cuyo tamaño está definido. Para alcanzar el tamaño solicitado, la cadena se rellena a la izquierda:

- por caracteres de espacio.

- por un carácter o por una cadena determinada.




**Formato de uso**:


```txt
-- Completion with space characters
LPAD(Initial expression, Length)
-- Completion with a character
LPAD(Initial expression, Length, Character)
-- Completion with a character string
LPAD(Initial expression, Length, Character string)
```

<a name="SQL_REPEAT"></a>
**REPEAT**
**REPEAT** devuelve una cadena de caracteres que contiene n veces el repetition de la cadena inicial. 

- Si n es menor o igual que 0, la función devuelve una cadena vacía. 

- Si la cadena inicial o n es NULL, la función devuelve NULL. 




**Formato de uso**:


```txt
REPEAT(Initial String, n)
```


**Ejemplo**: El siguiente código se utiliza para repetir el nombre de la Contact 3 veces: 


```sql
SELECT REPEAT(CONTACTNAME,14) 
FROM CUSTOMER  
WHERE CUUNIKKEY=10
```

<a name="SQL_RPAD"></a>


### RPAD
<a name="rpad_ELTPARAGRAPHE000944"></a>

**RPAD** devuelve una cadena cuyo tamaño está definido. Para alcanzar el tamaño solicitado, la cadena se rellena a la derecha:

- por caracteres de espacio.

- por un carácter o por una cadena determinada.




**Formato de uso**:


```txt
-- Completion with space characters
RPAD(Initial expression, Length)
-- Completion with a character
RPAD(Initial expression, Length, Character)
-- Completion with a character string
RPAD(Initial expression, Length, Character string)
```

<a name="SQL_SPACE"></a>
**ESPACIO**
**ESPACIO** devuelve una cadena que contiene caracteres en espacio N. 

**Formato de uso**:


```txt
SPACE(N)
```

<a name="SQL_TO_CHAR"></a>
**TO_CHAR**
**TO_CHAR** se utiliza para convertir en cadena de caracteres: 

- una hora de cita,

- un valor numérico.




**Formato de uso**:

**1. Convertir un valor de fecha:** 


```txt
TO_CHAR(<DateTime value>, <DataTime format> [, <DateTime options>])
```


En esta sintaxis: 

- &lt;FechaFormato&gt; puede corresponder a uno de los siguientes elementos: 

	- "-", "/", ",", ".", ";", ":"

	- "text": caracteres de puntuación (separadores) para una fecha y/o una hora.

	- AD, A.D..: Indicador de la era de AD para una fecha (Después de Jesucristo)

	- AM, A.M..: Indicador de meridiano AM para el tiempo (Meridiano Ante)

	- BC, B.C.: Indicador de la era BC para una fecha (Antes de Jesucristo)

	- Siglo CC o SCC: 

		- Si los dos últimos dígitos del siglo sobre 4 dígitos están incluidos entre 01 y 99 (inclusive), el siglo está representado por los dos últimos dígitos del año.

		- Si los dos últimos dígitos del siglo sobre 4 dígitos son 00, el siglo está representado por los dos primeros dígitos del año..
						Por ejemplo, la declaración de 2002 02 ; la declaración de 2000 20.




- D: Número del día de la semana (1-7). 

- DÍA: Día en letras. 

- DD: Número del día del mes (1-31).

- DDD: Número del día del año (1-366).

- DY: Día abreviado en letras

- FF [1..9]: Fracciones de segundos. El dígito representa el número de dígitos que representan la fracción de segundo. Ejemplos:

	- HH:MI:SS.FF*.

	- SELECT TO_CHAR(SYSTIMESTAMP, 'SS.FF3') desde dual;

- El parámetro &lt;Opciones fecha/hora&gt; es una cadena de caracteres que contiene las siguientes palabras clave: 

	- "NLS_DATE_LANGUAGE=idioma en es"

	- "NLS_NUMERIC_CHARACTERS ='dg'": dg' es una cadena de 2 caracteres cuyo primero corresponde al separador decimal y el segundo al separador de grupo (entre mil y cien, por ejemplo)..
			Ejemplo: NLS_DATE_LANGUAGE=*french*, NLS_NUMERIC_CHARACTERS =*, **







**2. Convertir un valor numérico**: 


```txt
TO_CHAR(<Numeric value>, <Numeric format> [, <Numeric options>])
```


- El parámetro &lt;Formato numérico&gt; puede corresponder a uno de los siguientes elementos: 

	- , (coma). Posicionar una coma en la ubicación especificada. Ejemplo: 9,999

	- . (punto). Posicionar un punto en la ubicación especificada. Ejemplo: 99.99

	- 0. Rellena con ceros antes o después. Ejemplo: 0999 ó 9990

	- 9. Representa dígitos. Ejemplo: 9999

	- B. Sustituye ceros por espacios. Ejemplo: B9999

	- C. Posicione el símbolo de moneda según el estándar ISO cuando se utiliza el parámetro NLS_ISO_CURRENCY.. Ejemplo: C999

	- D. Indica la posición del separador decimal cuando se utiliza el parámetro NLS_NUMERIC_CHARACTER.. El (.) es el separador de Default. Ejemplo: 99D99

	- EEEE. Devuelve un valor en formato científico. Ejemplo: 9.9EEEEEE

	- G. Indica el separador de miles cuando se utiliza el parámetro NLS_NUMERIC_CHARACTER. Puede especificar varios miles de separadores. Ejemplo: 9G999

	- L. Indica la posición del símbolo de moneda cuando se utiliza el parámetro NLS_ISO_CURRENCY.. Ejemplo: L999

	- MI. Coloca el signo - después de valores negativos. Ejemplo: 9999MI

	- PR. Encierra los valores negativos entre corchetes angulares. Ejemplo: 9999PR

	- rn o RN. Devuelve el valor en mayúsculas o minúsculas.

	- S. Indica el signo +/- Positivo o Negativo. Ejemplo: S9999

	- U. Indica el símbolo de la moneda del euro cuando se utiliza el parámetro NLS_DUAL_CURRENCY.. Ejemplo: U9999

	- V. Devuelve el valor en potencia de 10. Ejemplo 999V99

	- X. Devuelve el valor en formato hexadecimal. Ejemplo: XXXX




- En esta sintaxis, el parámetro &lt;Opciones numéricas&gt; es una cadena que contiene las siguientes palabras clave: 

	- "NLS_CURRENCY='moneda en nosotros'"

	- "NLS_NUMERIC_CHARACTERS ='dg'": dg' es una cadena de 2 caracteres cuyo primero corresponde al separador decimal y el segundo al separador de grupo (entre mil y cien, por ejemplo)..
			Ejemplo: NLS_CURRENCY='$', NLS_NUMERIC_CHARACTERS='dg







Observación: En Default, la lengua, la moneda y los separadores están definidos por la nación actual.
<a name="SQL_CHAR"></a>
**CHAR**
CHAR se utiliza para convertir un código ASCII (entero) en carácter.


**Formato de uso**:


```txt
CHAR(<ASCII Code>)
```
&lt;código ASCII&gt; es un número y corresponde al carácter ASCII a convertir, entre 0 y 255. De lo contrario, el carácter devuelto por la función es NULL.

El resultado de la función es el carácter correspondiente al código ASCII de &lt;código ASCII&gt;.. 

**Observación**: El resultado depende del personaje actual set.
<a name="SQL_CHR"></a>
**CRH**
CHR se utiliza para convertir un código ASCII (entero) en un carácter.


```txt
CHR(<ASCII Code>)
```
&lt;código ASCII&gt; es un número y corresponde al carácter ASCII a convertir, entre 0 y 255. De lo contrario, el carácter devuelto por la función es NULL.

El resultado de la función es el carácter correspondiente al código ASCII de &lt;código ASCII&gt;.. 

**Observaciones**: 

- El resultado depende del personaje actual set.

- En UTF8, el número entero enviado se interpreta como un "punto de código"; en caso contrario, el carácter devuelto corresponde al módulo de caracteres 256.



<a name="SQL_CAST"></a>
**ENG**
CAST se utiliza para convertir un dato de un tipo a otro.


```txt
CAST(Expression AS Type)
```


- &lt;Expresión&gt; representa el valor a convertir.

- &lt;Type&gt; representa el nuevo tipo en el que se convierte la expresión. Los tipos disponibles son:





|   |   |
| --- | --- |
| CHARACTER | Cadena de caracteres |
| CHARACTER(Tamaño) | String on size |
| VARCHAR(Tamaño) | String on size |
| CHARACTER VARYING(Tamaño) | String on size |
| CHAR VARYING(Tamaño) | String on size |
| NVARCHAR(Tamaño) | Unicode string on size |
| VARCHAR(Tamaño) BINARY | Binary string on size |
| BINARY(Tamaño) | Binary string on size |
| VARBINARY(Tamaño) | Binary string on size |
| BLOB | Memo binario |
| CLOB | Nota de texto |
| TEXTO | Nota de texto |
| NCLOB | Nota de Unicode |
| NTEXT | Nota de Unicode |
| NUMBER(Precisión) | Integro |
| NUMBER(Precisión, escala) | Integro |
| DECIMAL(Precisión) | Real |
| DECIMAL(Precisión, escala) | Real |
| TINYINT UNSIGNED | Un entero de 1 byte sin firmar |
| SMALLINT UNSIGNED | Un entero de 2 bytes sin firmar |
| INTEGER UNSIGNED | Un entero de 4 bytes sin firmar |
| BIGINT UNSIGNED | Un entero de 8 bytes sin firmar |
| TINYINT | Firmado un entero de 1 byte |
| SMALLINT | Firmado un entero de 2 bytes |
| INTEGER | Firmado un entero de 4 bytes |
| BIGINT | Firmado un entero de 8 bytes |
| FLOAT | 4 bytes reales |
| REAL | 8 bytes reales |
| DOUBLE PRECISION | 8 bytes reales |
| MONEY | Moneda |
| FECHA | FECHA |
| FECHA | Fecha y hora |
| TIEMPO | momento |

El resultado de la función es el valor convertido.

Ejemplo: 


```sql
CAST(126.12 AS INTEGER)
```
Este código devuelve: "126". 
<a name="SQL_CONVERT"></a>
**CONVERT**


CONVERTENCIA se utiliza para convertir una cadena de caracteres de un personaje set a otro.

**Formato de uso**:


```txt
CONVERT(Text to Convert, Charset Used, New Charset)
```


**Ejemplo**: Convertir una cadena de UTF-8 a LATIN1: 


```sql
SELECT CONVERT('text in utf8', 'UTF8', 'LATIN1')
```


Observación: Esta función no está disponible para las consultas SQL ejecutadas en archivos HFSQL en Android. 
<a name="SQL_INITCAP"></a>
**INITCAP**
**INITCAP** devuelve una cadena de caracteres donde la primera letra de cada palabra se escribe en mayúsculas y todas las demás letras se escriben en minúsculas. 

**Formato de uso**:


```txt
INITCAP(<String>)
```


Ejemplo: 


```sql
INITCAP ('grEat Weather today')
```
Este código devuelve: 'Hace Buen Clima'. 
<a name="SQL_LOWER"></a>


### LOWER
<a name="lower_ELTPARAGRAPHE001311"></a>

**LOWER** convierte una expresión en minúsculas.

**LOWER** no puede utilizarse en una fuente de datos Access.

**Formato de uso**:


```txt
LOWER(Initial Expression)
```


**Ejemplo**: El siguiente código SQL se utiliza para convertir el nombre de los clientes en caracteres en minúsculas:


```sql
SELECT LOWER(FirstName)
FROM CUSTOMER
```

<a name="SQL_UPPER"></a>


### SUPERIOR
<a name="superior_ELTPARAGRAPHE001328"></a>

**UPPER** convierte una expresión en mayúsculas.

**UPPER** no puede utilizarse en una fuente de datos de Access.

**Formato de uso**:


```txt
UPPER(Initial Expression)
```


**Ejemplo**: El siguiente código SQL se utiliza para convertir las ciudades de los clientes en caracteres mayúsculas:


```sql
SELECT UPPER(City)
FROM CUSTOMER
```

<a name="SQL_LCASE"></a>
**LCASE**
**LCASE** devuelve una cadena con todos los caracteres en minúsculas según el carácter actual set.

**Formato de uso**:


```txt
LCASE(Initial Expression)
```


**Ejemplo**: El siguiente código SQL se utiliza para convertir las ciudades de los clientes en caracteres minúsculos:


```sql
SELECT LCASE(City)
FROM CUSTOMER
```

<a name="SQL_UCASE"></a>
**UCASE**
**UCASE** devuelve una cadena con todos los caracteres en mayúsculas según el set actual de caracteres.

**Formato de uso**:


```txt
UCASE(Initial Expression)
```


**Ejemplo**: El siguiente código SQL se utiliza para convertir las ciudades de los clientes en caracteres mayúsculas:


```sql
SELECT UCASE(City)
FROM CUSTOMER
```

<a name="NOTE2_17"></a>


### LONGITUD/LONGITUD
<a name="longitudlongitud_ELTPARAGRAPHE001379"></a>

**LEN y LENGTH** devuelven el tamaño (el número de caracteres) de una expresión.

Este tamaño incluye todos los caracteres, incluyendo los espacios y el 0 binario.
<a name="SQL_LEN"></a>


### LEN
<a name="len_ELTPARAGRAPHE001388"></a>

**LEN** puede utilizarse en todos los tipos de fuentes de datos, excluyendo las fuentes de datos de Oracle. Para las fuentes de datos de Oracle, utilice**LENGTH**.

**Formato de uso**:


```txt
LEN(Initial Expression)
```


**Ejemplo**: El siguiente código SQL se utiliza para averiguar el tamaño de los nombres de los clientes:


```sql
SELECT LEN(Name)
FROM CUSTOMER
```

<a name="SQL_LENGTH"></a>


### LONGITUD
<a name="longitud_ELTPARAGRAPHE001403"></a>

**LENGTH** sólo puede utilizarse en una fuente de datos Oracle.

**Formato de uso**:


```txt
LENGTH(Initial Expression)
```


**Ejemplo**: El siguiente código SQL se utiliza para averiguar el tamaño de los nombres de los clientes:


```sql
SELECT LENGTH(Name)
FROM CUSTOMER
```

<a name="SQL_INSTR"></a>


### INSTR
<a name="instr_ELTPARAGRAPHE001418"></a>

**INSTR** devuelve la posición de una cadena de caracteres en una expresión.

**INSTR** sólo puede utilizarse en una fuente de datos Oracle o en una fuente de datos que soporte el estándar SQL-92.

**Formato de uso**:


```txt
INSTR(Initial Expression, String to Find, Start Position, Occurrence)
```


**Ejemplo**: El siguiente código SQL se utiliza para averiguar la posición de la primera aparición de la letra "T" en las ciudades de los clientes:


```sql
SELECT INSTR(City, 'T', 1, 1)
FROM CUSTOMER
```

<a name="SQL_FIELD"></a>
**CAMPO**
**CAMPO** devuelve el índice de la cadena buscada en la lista.

Si no se encuentra la cadena, la función devuelve 0. 

**Formato de uso**:


```txt
FIELD(String to Find, String1, String2, ...)
```

<a name="SQL_FIND_IN_SET"></a>
**FIND_IN_set**
**FIND_IN_set** devuelve la posición de una cadena en una lista de valores.

Si no se encuentra la cadena, la función devuelve 0. 

**Formato de uso**:


```txt
FIND_IN_SET(<String to Find>, <List of Values>)
```


El parámetro &lt;Lista de valores&gt; corresponde a una cadena de caracteres que contiene los valores separados por una coma. 

Ejemplo: El siguiente código devuelve 3: 


```sql
FIND_IN_SET('Red','Blue,Yellow,Red,Green')
```

<a name="SQL_PATINDEX"></a>


### PATINDEX
<a name="patindex_ELTPARAGRAPHE001471"></a>

**PATINDEX** devuelve la posición de la primera aparición de un string correspondiente a un valor especificado (con caracteres genéricos).

Los caracteres comodín autorizados son:

- '%': representa cero, uno o más caracteres.

- '_': representa un solo carácter.




Estos caracteres genéricos se pueden combinar.

**PATINDEX** puede utilizarse en una fuente de datos HFSQL Classic o SQL Server.

**Formato de uso**:


```txt
PATINDEX(Value to Find, Expression)
```


**Ejemplo**: El tabla a continuación presenta la posición de la primera ocurrencia encontrada de acuerdo a los valores buscados:

   |   | --- | --- |
| --- | --- |
|   | Valor buscado |
| **Nombre de la ciudad** | '%E%' | '%E_' | %AR%. |
| MONTPELLIER | 6 | 10 | 0 |
| PARÍS | 0 | 0 | 2 |
| TARBES | 5 | 5 | 2 |
| TOULOUSE | 8 | 0 | 0 |
| VIENA | 3 | 0 | 0 |


<a name="SQL_POSITION"></a>


### POSICIÓN
<a name="posicion_ELTPARAGRAPHE001580"></a>

**POSITION** devuelve la posición de una cadena de caracteres en una expresión.

**Formato de uso**:


```txt
POSITION(String to find IN Initial expression)
POSITION(String to find IN Initial expression, Start position)
```


Ejemplo:


```wl
TestQRY is Data Source
sSQLCode is string = [
SELECT POSITION( 'No' IN Name ) As NamePos
FROM cooperator
LIMIT 0 , 30
]

IF NOT HExecuteSQLQuery(TestQRY, MyConnection, hQueryWithoutCorrection, sSQLCode) THEN 
	Error(HErrorInfo())
END
FOR EACH TestQRY 
	Trace(TestQRY.NamePos)
END
```

<a name="SQL_COUNT"></a>


### CUENTA
<a name="cuenta_ELTPARAGRAPHE001595"></a>

**CUENTA** retornos:

- el número de registros seleccionados en un archivo.

- el número de valores no nulos de un elemento.

- el número de valores diferentes y valores no nulos de un artículo.




**Formato de uso**:


```txt
COUNT(*)
COUNT(Item)
COUNT(DISTINCT Item)
```


**Ejemplos**:

- El siguiente código SQL se utiliza para averiguar el número de productos que se encuentran en el archivo del producto:
	
	```sql
	SELECT COUNT(*)
	FROM PRODUCT
	```


- El siguiente código SQL se utiliza para averiguar el número de productos a los que se aplica un tipo de IVA del 5,5 %:
	
	```sql
	SELECT COUNT(VATRate)
	FROM PRODUCT
	WHERE VATRate = '5.5'
	```


- El siguiente código SQL se utiliza para averiguar el número de tipos de IVA diferentes y no nulos:
	
	```sql
	SELECT COUNT(DISTINCT PRODUCT.VATRate)
	FROM PRODUCT
	```




<a name="SQL_AVG"></a>


### AVG
<a name="avg_ELTPARAGRAPHE001622"></a>

**AVG** calcula:

- la media de una set de valores no nulos.

- el promedio de un conjunto de valores diferentes y no nulos.




**Formato de uso**:


```txt
AVG(Item) 
AVG(DISTINCT Item)
```


**Ejemplos**:

- El siguiente código SQL se utiliza para averiguar el salario medio de los empleados:
	
	```sql
	SELECT AVG(Salary)
	FROM EMPLOYEE
	```


- El siguiente código SQL se utiliza para conocer la media de los diferentes salarios de los empleados:
	
	```sql
	SELECT AVG(DISTINCT Salary)
	FROM EMPLOYEE
	```




<a name="SQL_MAX"></a>


### MÁX
<a name="max_ELTPARAGRAPHE001645"></a>

**MAX** devuelve el mayor de los valores encontrados en un elemento para todos los registros seleccionados en el fichero.

El MAX utilizado en una consulta sin agrupación debe devolver un solo Record. Si la consulta contiene agrupaciones, se devolverá un Record por cada agrupación.

Si la fuente de datos contiene Record s, el Record devuelto por la consulta contendrá el valor máximo.

Si la fuente de datos no contiene Record, el valor de MAX en el Record devuelto es NULL.

**Formato de uso**:


```txt
MAX(Item) 

MAX(DISTINCT Item)
```


**Ejemplo**: El siguiente código SQL se utiliza para averiguar el salario máximo de los empleados:


```sql
SELECT MAX(Salary)
FROM EMPLOYEE
-- Equivalent to:
-- SELECT MAX(DISTINCT Salary)
-- FROM EMPLOYEE
```

<a name="SQL_MIN"></a>


### MÍN
<a name="min_ELTPARAGRAPHE001666"></a>

**MIN** devuelve el menor de los valores no nulos encontrados en un elemento para todos los registros seleccionados en el fichero.

**Formato de uso**:


```txt
MIN(Item)

MIN(DISTINCT Item)
```


**Ejemplo**: El siguiente código SQL se utiliza para averiguar el salario mínimo de los empleados:


```sql
SELECT MIN(Salary)
FROM EMPLOYEE
-- Equivalent to:
-- SELECT MIN(DISTINCT Salary)
-- FROM EMPLOYEE
```

<a name="SQL_SUM"></a>


### SUMA
<a name="suma_ELTPARAGRAPHE001681"></a>

**SUMA** retornos:

- la suma de los valores no nulos encontrados en un ítem para todos los registros seleccionados en el archivo.

- la suma de los valores diferentes y no nulos encontrados en un elemento para todos los registros seleccionados en el fichero. 




**Formato de uso**:


```txt
SUM(Item)

SUM(DISTINCT Item)
```


**Ejemplos**:

- El siguiente código SQL se utiliza para averiguar la suma total de los salarios:
	
	```sql
	SELECT SUM(Salary)
	FROM EMPLOYEE
	```


- El siguiente código SQL se utiliza para averiguar la suma total de los diferentes salarios:
	
	```sql
	SELECT SUM(DISTINCT Salary)
	FROM EMPLOYEE
	```





**Observación**: El artículo manejado por**SUMA** no debe coincidir con el resultado de una operación. Por lo tanto, la siguiente sintaxis genera un error:

```sql
SELECT (A*B) AS C, SUM C
FROM MYFILE
```


Esta sintaxis debe ser sustituida por la siguiente:

```sql
SELECT (A*B) AS C, SUM(A*B)
FROM MYFILE
```

<a name="SQL_EVERY"></a>


### CADA
<a name="cada_ELTPARAGRAPHE001714"></a>

**TODOS** es una función agregada (como SUM por ejemplo), lo que significa que las funciones actúan sobre un grupo de datos y devuelven un valor.

**TODOS** beneficios: 

- <u><u><u><u>True</u></u></u></u> si todos los argumentos recibidos se han verificado y son verdaderos.

- <u><u><u><u>False</u></u></u></u> si al menos uno de los argumentos no ha sido verificado.




**Formato de uso**:


```txt
EVERY(Expression 1, Expression 2, ..., Expression N)
```


**Ejemplo**:
El siguiente código SQL se utiliza para get la lista de empresas con empleados cuyo salario es superior a 10000:


```sql
SELECT company.name, every(employee.salary > 10000) as rich 
FROM company NATURAL JOIN employee GROUP BY company.name
```

<a name="SQL_TOP"></a>


### ARRIBA
<a name="arriba_ELTPARAGRAPHE001741"></a>

**TOP** devuelve los primeros n registros del resultado de la consulta.

**TOP** no puede utilizarse en una fuente de datos Oracle o PostgreSQL.

**Formato de uso**:


```txt
TOP Number of the last selected record
```


**Ejemplo**: El siguiente código SQL se utiliza para listar los 10 mejores clientes:


```sql
SELECT TOP 10 SUM(ORDERS.TotalIncTax) AS TotalIncTax,
CUSTOMER.CustomerName
FROM CUSTOMER, ORDERS
WHERE CUSTOMER.CustNum = ORDERS.CustNum
GROUP BY CustomerName
ORDER BY TotalIncTax DESC
```


**Observación**: 

- Le recomendamos que utilice**TOP** en una consulta ordenada. De lo contrario, los Record devueltos por**TOP** serán seleccionados según su número de Record.

- Usted tiene la capacidad de pasar un parámetro a**TOP**. El parámetro puede ser: 

	- definido en el editor de consultas. Para obtener más información, consulte [Consulta de selección: Visualización de los primeros/últimos n registros](../Editeurs/2032022.md). 

	- definido directamente en el editor de código. Por ejemplo: 



	```sql
	SELECT TOP {pMaxNumberCustomers}
	Customer.CustomerID AS CustomerID,
	Customer.LastName AS LastName,
	Customer.FirstName AS FirstName,
	Customer.Email AS Email,
	Customer.FidelityBonus AS FidelityBonus
	FROM
	Customer
	```




<a name="SQL_BOTTOM"></a>


### FONDO
<a name="fondo_ELTPARAGRAPHE001773"></a>

**BOTTOM** devuelve los últimos n registros encontrados en el resultado de una consulta.

**BOTTOM** sólo puede utilizarse en una fuente de datos HFSQL.

**Formato de uso**:


```txt
BOTTOM Number of the last selected record
```


**Ejemplo**: El siguiente código SQL se utiliza para listar los 10 peores clientes:


```sql
SELECT BOTTOM 10 SUM(ORDERS.TotalIncTax) AS TotalIncTax,
CUSTOMER.CustomerName
FROM CUSTOMER, ORDERS
WHERE CUSTOMER.CustNum = ORDERS.CustNum
GROUP BY CustomerName
ORDER BY TotalIncTax DESC
```


**Observación**: 

- Se recomienda utilizar**BOTTOM** en una consulta ordenada. De lo contrario, los Record devueltos por**BOTTOM** serán seleccionados según su número de Record.

- Usted tiene la capacidad de pasar un parámetro a**ABAJO**. El parámetro puede ser: 

	- definido en el editor de consultas. Para obtener más información, consulte [Consulta de selección: Visualización de los primeros/últimos n registros](../Editeurs/2032022.md). 

	- definido directamente en el editor de código. 






<a name="SQL_LIMIT"></a>


### LÍMITE
<a name="limite_ELTPARAGRAPHE001803"></a>

**LÍMITE** devuelve los primeros n registros del resultado de la consulta.

**LIMIT** no puede utilizarse en una fuente de datos Oracle o PostgreSQL.

**Formato de uso**:


```txt
LIMIT Number of the last selected record
```


**Ejemplo**: El siguiente código SQL se utiliza para listar los 10 mejores clientes:


```sql
SELECT SUM(ORDERS.TotalIncTax) AS TotalIncTax,
CUSTOMER.CustomerName
FROM CUSTOMER, ORDERS
WHERE CUSTOMER.CustNum = ORDERS.CustNum
GROUP BY CustomerName
ORDER BY TotalIncTax DESC
LIMIT 10
```


**Observación**: 

- No se recomienda utilizar**LIMIT** en una consulta ordenada. De lo contrario, los Record devueltos por**TOP** serán seleccionados según su número de Record.

- Usted tiene la capacidad de pasar un parámetro a**LÍMITE**. El parámetro puede ser: 

	- definido en el editor de consultas. Para obtener más información, consulte [Consulta de selección: Visualización de los primeros/últimos n registros](../Editeurs/2032022.md). 

	- definido directamente en el editor de código. 






<a name="SQL_ASCII"></a>


### ASCII
<a name="ascii_ELTPARAGRAPHE001833"></a>

**ASCII** devuelve el código ASCII:

- de un personaje. 

- del primer carácter encontrado en una cadena.




Si el carácter o el string corresponde a un string vacío ("""),**ASCII** devuelve 0.

**Formato de uso**:


```txt
-- ASCII code of character
ASCII(Character)
-- ASCII code of first character found in a string
ASCII(Character string)
```

<a name="SQL_UNICODE"></a>


### UNICODE
<a name="unicode_ELTPARAGRAPHE001849"></a>

**UNICODE** devuelve el valor entero definido por el estándar Unicode:

- de un personaje. 

- del primer carácter encontrado en una cadena.




**Formato de uso**:


```txt
-- Unicode code of character
UNICODE(Character)
-- Unicode code of first character found in a string
UNICODE(Character string)
```

<a name="SQL_CURRENT_USER"></a>


### USUARIO_ACTUAL
<a name="usuarioactual_ELTPARAGRAPHE001865"></a>

**CURRENT_USER** devuelve el nombre de usuario de la conexión actual.

**Formato de uso**:


```txt
CURRENT_USER()
```


**Ejemplo**: El siguiente código actualiza al autor de la modificación realizada en CUSTOMER tabla: 


```sql
UPDATE CUSTOMER SET USER=CURRENT_USER() WHERE CUSTOMERID=1
```

<a name="SQL_SYSTEM_USER"></a>


### SYSTEM_USER
<a name="systemuser_ELTPARAGRAPHE001882"></a>

**SYSTEM_USER** devuelve el nombre de usuario de la conexión actual.

**Formato de uso**:


```txt
SYSTEM_USER()
```


**Ejemplo**: El siguiente código actualiza al autor de la modificación realizada en CUSTOMER tabla: 


```sql
UPDATE CUSTOMER SET USER=SYSTEM_USER() WHERE CUSTOMERID=1
```

<a name="SQL_USER_NAME"></a>


### NOMBRE_DE_USUARIO
<a name="nombredeusuario_ELTPARAGRAPHE001899"></a>

**USER_NAME** devuelve el nombre de usuario de la conexión actual.

**Formato de uso**:


```txt
USER_NAME()
```


**Ejemplo**: El siguiente código actualiza al autor de la modificación realizada en CUSTOMER tabla: 


```sql
UPDATE CUSTOMER SET USER=USER_NAME() WHERE CUSTOMERID=1
```

<a name="SQL_SOUNDEX, SOUND LIKE"></a>


### SOUNDEX, SUENA COMO
<a name="soundex_suena_como_ELTPARAGRAPHE001914"></a>

**SONIDO** y**SONIDO COMO** devuelve la representación fonética de una cadena de caracteres (basada en un algoritmo inglés).

**Formato de uso**:


```txt
SOUNDEX(String)

SOUND LIKE(String)
```


**Ejemplo**: El siguiente código SQL se utiliza para listar los clientes cuyo nombre fonéticamente corresponde a "Henry":


```sql
SELECT CUSTOMER.CustomerLastName
FROM CUSTOMER 
WHERE SOUNDEX(CUSTOMER.CustomerName) = SOUNDEX('Henry')
```



```sql
SELECT CUSTOMER.CustomerLastName
FROM CUSTOMER 
WHERE CUSTOMER.CustomerName SOUND LIKE 'Henry'
```


Observación: SOUNDEX utilizado en diferentes bases de datos (HFSQL, Oracle, MySQL, ....) puede devolver resultados diferentes según la base de datos utilizada.. 

![Conectores Nativos](https://doc.pcsoft.fr/ext/images/us/AN.png) SOUND LIKE no está soportado por Oracle, MySQL, Progress o Informix. 

SOUNDEX no es compatible con Informix. 
<a name="SQL_SOUNDEX2, SOUND2 LIKE"></a>


### SOUNDEX2, SONIDO2 COMO
<a name="soundex2_sonido2_como_ELTPARAGRAPHE001939"></a>

**SOUNDEX2** y**SONIDO2 COMO** devuelve la representación fonética de una cadena de caracteres (basada en un algoritmo cercano al francés).

**Formato de uso**:


```txt
SOUNDEX2(String)

SOUND2 LIKE(String)
```


**Ejemplo**: El siguiente código SQL se utiliza para listar los clientes cuya ciudad fonéticamente corresponde a "Montpellier":


```sql
SELECT CUSTOMER.CityName
FROM CUSTOMER 
WHERE SOUNDEX2(CUSTOMER.CityName) = SOUNDEX2('Montpellier')
```



```sql
SELECT CUSTOMER.CityName
FROM CUSTOMER 
WHERE CUSTOMER.CityName SOUND2 LIKE 'Montpellier'
```


![Conectores Nativos](https://doc.pcsoft.fr/ext/images/us/AN.png) SOUNDEX2 y SOUNDEX2 LIKE no son compatibles con Oracle, SQL Server, MySQL, Progress, Informix o DB2.. 
<a name="SQL_ADD_MONTHS"></a>


### ADD_MONTHS
<a name="addmonths_ELTPARAGRAPHE001960"></a>

**AÑADIR_MESES** se utiliza para añadir varios meses a una fecha específica.

**Formato de uso**:


```txt
ADD_MONTHS(Date,Number of months)
```


**Ejemplo**: El siguiente código SQL se utiliza para seleccionar los pedidos realizados en abril de 2003.


```sql
SELECT ORDDATE,
	ADD_MONTHS('20070203',2) AS AM 
FROM ORDERS
```


![Conectores Nativos](https://doc.pcsoft.fr/ext/images/us/AN.png) ADD_MONTHS no es soportado por SQL Server, MySQL, Informix, DB2 o Sybase.
<a name="SQL_LAST_DAY"></a>


### ÚLTIMO DÍA
<a name="ultimo_dia_ELTPARAGRAPHE001979"></a>

**ÚLTIMO DÍA** se utiliza para averiguar la fecha del último día del mes especificado.

**Formato de uso**:


```txt
LAST_DAY(Date)
```


**Ejemplo**: El siguiente código SQL se utiliza para seleccionar los pedidos realizados en febrero de 2008: 


```sql
SELECT LAST_DAY('20080203') as LD,
	ORDDATE 
FROM ORDERS
WHERE ORDERS.CUUNIKKEY=2 order by ORDDATE
```


![Conectores Nativos](https://doc.pcsoft.fr/ext/images/us/AN.png) Informix, DB2 o Sybase no soportan LAST_DAY.
<a name="SQL_DAY"></a>


### DÍA
<a name="dia_ELTPARAGRAPHE002000"></a>

**DÍA** devuelve el día del mes, es decir, un número incluido entre 1 y 31.

**Formato de uso**:


```txt
DAY(Date)
```

<a name="SQL_DAYOFMONTH"></a>


### DAYOFMONTH
<a name="dayofmonth_ELTPARAGRAPHE002013"></a>

**DÍA MES** devuelve el día del mes (incluido entre 1 y 31).

**Formato de uso**:


```txt
DAYOFMONTH(Date)
```

<a name="SQL_DAYOFWEEK"></a>


### DAYOFWEEK
<a name="dayofweek_ELTPARAGRAPHE002026"></a>

**DÍA DE LA SEMANA** devuelve el día de la semana (1 para el domingo, 2 para el lunes, etc.). 

**Formato de uso**:


```txt
DAYOFWEEK(Date)
```

<a name="SQL_DAYOFYEAR"></a>


### DAYOFYEAR
<a name="dayofyear_ELTPARAGRAPHE002039"></a>

**DÍA DEL AÑO** devuelve el día del año (incluido entre 1 y 366). 

**Formato de uso**:


```txt
DAYOFYEAR(Date)
```

<a name="SQL_EOMONTH"></a>


### MES DE MES
<a name="mes_mes_ELTPARAGRAPHE002052"></a>

**EOMONTH** devuelve el último día del mes de la fecha especificada. 

**Formato de uso**:


```txt
EOMONTH(Start date [, Number of months to add ] )
```
donde: 

- Fecha de inicio: Fecha para la que se devuelve el último día del mes.

- Número de meses a añadir: Número de meses que hay que añadir a la fecha de inicio antes de calcular el último día del mes. 



<a name="SQL_YEAR_MONTH"></a>


### AÑO y MES
<a name="ano_mes_ELTPARAGRAPHE002069"></a>

Las funciones**YEAR** y**MONTH** permiten obtener el año y el mes de una fecha, respectivamente. 

**Formato de uso**:


```txt
YEAR date
```



```txt
MONTH date
```


donde la fecha corresponde a: 

- la fecha escrita: AÑO - MES - DÍA (AAAAMMDD o AAAAMM-DD)

- A Partial DATE. en este caso, los datos que faltan se representan con 0

- sólo un año (YEAR)

- sólo un año y un mes (AÑO-MES)




Observación: 

- Las fechas se decodifican de izquierda a derecha: para que una fecha sea válida, toda la información disponible debe ser válida. 

- Si el formato no es válido, la función devuelve NULL. 



<a name="SQL_CURRENT_TIMESTAMP"></a>


### FECHA_ACTUAL
<a name="fechaactual_ELTPARAGRAPHE002096"></a>

**CURRENT_TIMESTAMP** devuelve la hora local del servidor (en formato datetime). 

**Formato de uso**:


```txt
CURRENT_TIMESTAMP()
```

<a name="SQL_GETDATE"></a>


### GETDATE
<a name="getdate_ELTPARAGRAPHE002109"></a>

**GETDATE** devuelve la hora local del servidor (en formato datetime). 

**Formato de uso**:


```txt
GETDATE()
```

<a name="SQL_GETUTCDATE"></a>


### ES UNA BUENA IDEA.
<a name="una_buena_idea_ELTPARAGRAPHE002122"></a>

**GETUTCDATE** devuelve la hora UTC del servidor (en formato datetime). 

**Formato de uso**:


```txt
GETUTCDATE()
```

<a name="SQL_DATEADD"></a>


### DATEADD
<a name="dateadd_ELTPARAGRAPHE002135"></a>

**DATEADD** añade un valor a la fecha de inicio y devuelve la nueva fecha.  

**Formato de uso**:


```txt
DATEADD(Part to add, number, date )
```
donde: 

- Parte a añadir: Parte de la fecha a la que se añadirá el número. Este parámetro puede ser: 
	

| Fecha parte | Abreviaturas |
| --- | --- |
| año | yy, yyyy |
| trimestre | qq, q |
| mes | mm, m |
| día del año | dy, y |
| día	 | dd, d |
| semana | wk, ww |
| entre semana | dw, en |
| hora | hh |
| minuto	 | mi, n |
| segundo	 | ss, s |
| milisegundo | ms |
| microsegundo | mcs |
| nanosegundo | ns |



- Número: número entero correspondiente al número de unidades a añadir. 

- salir con: fecha o fecha-hora a utilizar. 



<a name="SQL_DATEDIFF"></a>


### DATEDIFF y DATEDIFF_BIG
<a name="datediff_datediffbig_ELTPARAGRAPHE002211"></a>

**DATEDIFF** calcula la diferencia entre dos fechas en una unidad determinada. El valor de retorno es un entero con signo. 

**DATEDIFF_BIG** calcula la diferencia entre dos fechas en una unidad determinada. El valor de retorno es un entero grande con signo. 

**Formato de uso**:


```txt
DATEDIFF(Part used, Start date, End date) 

DATEDIFF_BIG(Part used, Start date, End date)
```
donde: 

- Parte utilizada: Parte de la fecha en la que se realizará el cálculo. Este parámetro puede ser: 
	

| Fecha parte | Abreviaturas |
| --- | --- |
| año | yy, yyyy |
| trimestre | qq, q |
| mes | mm, m |
| día del año | dy, y |
| día	 | dd, d |
| semana | wk, ww |
| entre semana | dw, en |
| hora | hh |
| minuto	 | mi, n |
| segundo	 | ss, s |
| milisegundo | ms |
| microsegundo | mcs |
| nanosegundo | ns |



- Fecha de inicio: fecha de inicio o fecha-hora para el cálculo. 

- Fecha de finalización: fecha de finalización o fecha-hora para el cálculo. 



<a name="SQL_DATEPART"></a>


### DATEPART
<a name="datepart_ELTPARAGRAPHE002289"></a>

**DATEPART** devuelve el entero correspondiente a la parte solicitada de la fecha-hora especificada.  

**Formato de uso**:


```txt
DATEPART(Part used, date)
```
donde: 

- Parte utilizada: Parte de la fecha a extraer. Este parámetro puede ser: 
	

| Fecha parte | Abreviaturas |
| --- | --- |
| año | yy, yyyy |
| trimestre | qq, q |
| mes | mm, m |
| día del año | dy, y |
| día	 | dd, d |
| semana | wk, ww |
| entre semana | dw, en |
| hora | hh |
| minuto	 | mi, n |
| segundo	 | ss, s |
| milisegundo | ms |
| microsegundo | mcs |
| nanosegundo | ns |



- Fecha de inicio: fecha o fecha-hora utilizada. 



<a name="SQL_DATETIMEFROMPARTS"></a>


### FECHA DE LAS PARTES
<a name="fecha_las_partes_ELTPARAGRAPHE002364"></a>

**DATETIMEFROMPARTS** devuelve un valor datetime que corresponde a los elementos especificados. 

**Formato de uso**:


```txt
DATETIMEFROMPARTS(Year, Month, Day, Hours, Minutes, Seconds, Milliseconds)
```

<a name="SQL_DATEFROMPARTS"></a>


### DATEFROMPARTS
<a name="datefromparts_ELTPARAGRAPHE002377"></a>

**DATEFROMPARTS** devuelve un valor de fecha que corresponde a los elementos especificados. 

**Formato de uso**:


```txt
DATETIMEFROMPARTS(Year, Month, Days)
```

<a name="SQL_MONTHS_BETWEEN"></a>


### MESES_ENTRE
<a name="mesesentre_ELTPARAGRAPHE002388"></a>

**MESES_ ENTRE** se utiliza para averiguar el número de meses entre dos fechas especificadas.

**Formato de uso**:


```txt
MONTHS_BETWEEN(Date1, Date2)
```


**Ejemplo**: El siguiente código SQL se utiliza para seleccionar los pedidos realizados entre dos fechas: 


```sql
SELECT ORDDATE,
	MONTHS_BETWEEN('20070203','20070102') AS MB 
FROM ORDERS
```


**Ejemplo**: El siguiente código SQL se utiliza para seleccionar a los clientes según su edad: 


```sql
SELECT CUSTOMER.CUSTOMERID,
	CUSTOMER.LASTNAME,CUSTOMER.FIRSTNAME,   
    -- Number of months divided by 12 in real: number of years
	CAST(MONTHS_BETWEEN(SYSDATE,CUSTOMER.DATE_OF_BIRTH)/12 AS FLOAT) AS Age
FROM 
	CUSTOMER
WHERE 
	-- customers over 18 only
	Age >= 18
```


![Conectores Nativos](https://doc.pcsoft.fr/ext/images/us/AN.png) MONTHS_BETWEEN no es compatible con MySQL, Informix, DB2 o Sybase.
<a name="SQL_NEW_TIME"></a>


### NEW_TIME
<a name="newtime_ELTPARAGRAPHE002411"></a>

**TIEMPO_NUEVO** se utiliza para averiguar una fecha después de convertir su zona horaria.

**Formato de uso**:


```txt
NEW_TIME(Date, Time Zone 1, Time Zone 2)
```


**Ejemplo**: 


```sql
SELECT NEW_TIME('200311010145', 'AST', 'MST') as NTI 
FROM CUSTOMER
```


Observación: Si los husos horarios corresponden a una cadena vacía ("""), el resultado será un valor de DateTime de 0.

![Conectores Nativos](https://doc.pcsoft.fr/ext/images/us/AN.png) NEW_TIME no es compatible con SQL Server, MySQL, Progress, Informix, DB2 o Sybase.
<a name="SQL_NEXT_DAY"></a>


### PRÓXIMO_DÍA
<a name="proximodia_ELTPARAGRAPHE002432"></a>

**PRÓXIMO_DÍA** se utiliza para averiguar el primer día de la semana siguiente a la fecha o el día especificado.

**Formato de uso**:


```txt
NEXT_DAY(Date, Day)
```


**Ejemplo**: 


```sql
SELECT NEXT_DAY('20071007','Sunday') AS NXD 
FROM CUSTOMER
```


![Conectores Nativos](https://doc.pcsoft.fr/ext/images/us/AN.png) NEXT_DAY no es compatible con SQL Server, MySQL, Progress, Informix, DB2 o Sybase.. 
<a name="SQL_ROUND"></a>


### RONDA
<a name="ronda_ELTPARAGRAPHE002451"></a>

**RONDA** se utiliza para redondear la fecha al formato especificado.

**Formato de uso**:


```txt
ROUND(Date, Format)
```


**Ejemplo**: 


```sql
SELECT ORDDATE,
	ROUND(ORDDATE,'YYYY') AS TR 
FROM ORDERS
```


![Conectores Nativos](https://doc.pcsoft.fr/ext/images/us/AN.png) ROUND no está soportado por Progress, DB2 y Sybase. 
<a name="SQL_SYSDATE"></a>


### SYSDATE
<a name="sysdate_ELTPARAGRAPHE002470"></a>

**SÍDATE** se utiliza para averiguar la fecha y la hora actuales.

**Formato de uso**:


```txt
SYSDATE
```


**Ejemplo**: 


```sql
SELECT SYSDATE as SY FROM CUSTOMER WHERE CUSTOMERID=1
```


![Conectores Nativos](https://doc.pcsoft.fr/ext/images/us/AN.png) SYSDATE no es compatible con Informix y Sybase.
<a name="SQL_TRUNC"></a>


### TRUNC
<a name="trunc_ELTPARAGRAPHE002489"></a>

**TRUNC** se utiliza para truncar la fecha al formato especificado.

**Formato de uso**:


```txt
TRUNC(Date, Format)
```
El parámetro "Formato" puede corresponder a los siguientes valores: 

- Siglo: "CC" o "SCC"

- año: "Y", "YEAR", "YY", "YYY", "YYYY", "SYEAR", "SYYYY"

- Año ISO: "I," "IY," "IYY," "IYYYY.": ISOAño

- Trimestre: "Q"

- Mes: "MM", "MON", "MES"

- Primer día del mes que es el mismo día de la semana: "W"

- Primer día de la semana: "D","DÍA","DY".

- jornada: "DD","DDD","J".

- Hora: "HH", "HH12", "HH24"

- Minutos: "MI"




**Ejemplo**: 


```sql
SELECT ORDDATE,
TRUNC(ORDDATE) AS TR 
FROM ORDERS 
WHERE ORDUNIKKEY
```


![Conectores Nativos](https://doc.pcsoft.fr/ext/images/us/AN.png) TRUNC no es soportado por SQL Server, MySQL, Progress, DB2 y Sybase.
<a name="SQL_ISDATE"></a>


### ISDATE
<a name="isdate_ELTPARAGRAPHE002522"></a>

**ISDATE** se utiliza para determinar si una expresión corresponde a una fecha. Esta función devuelve: 

- 1 si la expresión corresponde a una fecha o fecha-hora

- 0 de lo contrario. 




**Formato de uso**:


```txt
ISSDATE(Expression)
```


**Ejemplo**: 


```sql
SELECT Date, ISDATE(Date) FROM Order WHERE OrderID=50
```

<a name="SQL_COALESCE"></a>


### COALESCE
<a name="coalesce_ELTPARAGRAPHE002540"></a>

**COALESCE** se usa para encontrar la primera expresión no nula entre sus argumentos. 

**Formato de uso**:


```txt
COALESCE(Param1, Param2, ...)
```


**Ejemplo**: 


```sql
SELECT COALESCE(hourly_wage, salary, commission) AS Total_Salary FROM wages
```


![Conectores Nativos](https://doc.pcsoft.fr/ext/images/us/AN.png) COALESCE no cuenta con el apoyo de Progress o Informix.
<a name="SQL_GREATEST"></a>
**GRAN PRUEBA**
**GREATEST** devuelve el mayor valor de los elementos pasados como parámetro. 

**Formato de uso**:


```txt
GREATEST(Param1, Param2, ...)
```

<a name="SQL_LEAST"></a>
**CARGA**
**LEAST** devuelve el valor más bajo de los elementos pasados como parámetro. 

**Formato de uso**:


```txt
LEAST(Param1, Param2, ...)
```

<a name="SQL_NVL_IF_NULL_IS_NULL"></a>


### NVL, IFNULL, ISNULL
<a name="nvl_ifnull_isnull_ELTPARAGRAPHE002585"></a>

**NVL** se utiliza para sustituir los valores nulos de una columna por un valor de sustitución. ISNULL e IFNULL son idénticos.

ISNULL se utiliza en SQL Server e IFNULL se utiliza en bases de datos MySQL o Progress.

**Formato de uso**:


```txt
NVL(Column name, Substitution value)
```


**Ejemplo**: 


```sql
SELECT hourly_wage AS R1,NVL(hourly_wage,0) AS Total FROM wages
```

<a name="SQL_NULLIF"></a>


### NULLIF
<a name="nullif_ELTPARAGRAPHE002602"></a>

**NULLIF** devuelve un valor NULL si las dos expresiones especificadas son iguales.

**Formato de uso**:


```txt
NULLIF(expression1, expression2)
```

<a name="SQL_DECODE"></a>


### DECODE
<a name="decode_ELTPARAGRAPHE002613"></a>

**DECODE** sirve para conocer el modo de funcionamiento de un IF .... THEN... Declaración ELSE.

**Formato de uso**:


```txt
DECODE(Column_Name, Compared value 1, Returned value 1, [Compared value 2, ...
		Returned value 2][, Default value])
```


**Ejemplo**: Según el cliente seleccionado, devuelve el nombre correspondiente al identificador especificado.: 


```sql
SELECT CUSTOMER_NAME, 
DECODE(CUSTOMER_ID, 10000, 'Customer 1',10001,'Customer 2',10002,'Customer 3','Other')
FROM CUSTOMER
```


![Conectores Nativos](https://doc.pcsoft.fr/ext/images/us/AN.png) DECODE no es compatible con SQL Server, MySQL, Progress, Informix, DB2, Sybase y ACCESS.
<a name="SQL_CASE"></a>


### MAY/MIN
<a name="maymin_ELTPARAGRAPHE002632"></a>

**CASO** sirve para conocer el modo de funcionamiento de un IF .... THEN... Declaración ELSE.

**Formato de uso**:


```txt
CASE Column_Name WHEN Compared value 1 THEN Returned value 1 [WHEN compared value 2 THEN ...
		Returned value 2][ELSE Default returned value] END
```



```txt
CASE WHEN Condition 1 THEN Returned value 1 [WHEN Condition 2 THEN Returned value 2] ...
		[ELSE Default returned value] END
```


**Ejemplo**: Devuelve "tres" si el ítem corresponde a "3" Devuelve "cuatro" si el ítem corresponde a "4" y devuelve "otro" en los demás casos.: 


```sql
SELECT itmInt, CASE itmInt WHEN 3 THEN 'three' WHEN 4 THEN 'four' ELSE 'other' END
```



```sql
SELECT itmInt, CASE WHEN itmInt=3 THEN 'three' WHEN itmInt=4 THEN 'four' ELSE 'other' END
```

<a name="SQL_MATCH AGAINST"></a>


### PARTIDO CONTRA
<a name="partido_contra_ELTPARAGRAPHE002651"></a>

El**MATCH CONTRA ** se utiliza para averiguar la pertinencia del Record durante una búsqueda de texto completo.

**Formato de uso**:


```txt
MATCH(List of items) AGAINST [ALL] Value
```


Donde: 

- **Lista de artículos** corresponde a la lista de elementos de índice separados por comas (el orden de los elementos no es importante)

- **Valor** corresponde al valor buscado en los diferentes ítems. Este parámetro puede corresponder a un valor literal o a un nombre de parámetro. El valor de búsqueda puede contener los siguientes elementos:





|   |   |
| --- | --- |
| **aspecto** | **Significado** |
| Una sola palabra | Se buscará la palabra especificada. La pertinencia aumentará si el texto contiene esta palabra.<br><br>Ejemplo: "WINDEV" busca "WINDEV". |
| Dos palabras separadas por un espacio en blanco | Busca una de las palabras.<br><br>Ejemplo: "WINDEV WEBDEV" busca los textos que contienen "WINDEV" o "WEBDEV". |
| Una palabra precedida por el signo "+ | La palabra especificada es obligatoria.<br><br>Ejemplo: "+WINDEV" busca los textos que necesariamente contienen "WINDEV". |
| Una palabra precedida por el signo "- | La palabra especificada no debe encontrarse en el texto.<br><br>Ejemplo: "-Índice" busca los textos que no contienen "Índice". |
| Una palabra precedida por el signo "~ | Si el texto contiene la palabra especificada, la relevancia se reducirá. |
| Una o más palabras entre comillas | Las palabras especificadas se buscan en el grupo y en orden.<br><br>Atención: si "Ignorar las palabras menos que" difiere de "0", no se buscarán las palabras entre comillas de un tamaño inferior al especificado. |
| Una palabra seguida del signo "\*" ". | El tipo de búsqueda realizada es "Comienza con" la palabra especificada. |

[ALL] se utiliza para forzar la sustitución de los caracteres de espacio por "+" en el valor buscado.

**Ejemplo**: En este ejemplo, EDT_Find es un control Campo de entrada y ConnectedUserID es un Variable.


```wl
MyQuery is string = [
SELECT * FROM Contact
WHERE MATCH(Contact.LastName, Contact.FirstName, Contact.HTMLComment, 
Contact.RoughTextComment, Contact.Comments, Contact.Phone, Contact.Office, 
Contact.Cell, Contact.Email, Contact.MSN, Contact.Internet_site, Contact.Country,
		Contact.FaxNum, Contact.City)
AGAINST ('
]
MyQuery = MyQuery + EDT_Find + [
')	
AND Contact.UserID =	
]
MyQuery = MyQuery + ConnectedUserID + [
ORDER BY LastName DESC
]

HExecuteSQLQuery(QRY_SRCH, hQueryDefault, MyQuery)
FOR EACH QRY_SRCH
	TableAddLine(TABLE_Contact_by_category, ...
	QRY_SRCH.ContactID,QRY_SRCH.CategoryID, ConnectedUserID, ...
	QRY_SRCH.LastName, QRY_SRCH.FirstName) 
END
CASE ERROR: 
	Error(HErrorInfo())
```
Para más detalles sobre la búsqueda de texto completo, véase [Búsqueda e índice de texto completo](../WDLang4/3044375.md).
<a name="SQL_MD5"></a>
**MD5**
**MD5** calcula la suma de comprobación MD5 de la cadena pasada como parámetro. El valor devuelto es un entero hexadecimal de 32 caracteres que puede utilizarse como clave hash, por ejemplo. 

**Formato de uso**:


```txt
MD5(String)
```

<a name="SQL_SHA"></a>
**SHA y SHA1**
SHA y SHA1 calculan la suma de comprobación SHA1 de 160 bits de la cadena pasada como parámetro según el estándar RFC 3174 (Secure Hash Algorithm). El valor devuelto es una cadena hexadecimal de 40 caracteres o NULL si el argumento es NULL. Esta función se puede utilizar para guardar las teclas. 

**Formato de uso**:


```txt
SHA(String)

SHA1(String)
```

<a name="SQL_REGEXP"></a>
**REGEXP** o**RLIKE** o**~** o**REGEXP_LIKE**


El propósito de**REGEXP** o**RLIKE** o**~** o**REGEXP_LIKE** es evaluar una expresión regular dentro de una consulta SQL.

**Formato de uso**:


```txt
string REGEXP expression
```



```txt
string RLIKE expression
```



```txt
string ~ expression
```



```txt
REGEXP_LIKE(string, expression)
```
donde: 

- corresponde a la cadena que debe ser evaluada.

- corresponde a la expresión regular.




El resultado de la función es un booleano: 

- <u><u><u><u> True</u></u></u></u> si la cadena corresponde a la expresión regular.

- <u><u><u><u>False</u></u></u></u> en caso contrario.




**Observación**: En una expresión regular, el carácter "\\" se utiliza para especificar un formato específico. Por lo tanto, "\\r" corresponde a un retorno de carro y "\\n" a una envoltura de Line...

**Ejemplos**: En estos ejemplos, la cadena "abcde" se compara con una expresión regular.


```wl
sQuery = "SELECT 'abcde' REGEXP 'a[bcd]{3}e' AS result"
QRY is Data Source
HExecuteSQLQuery(QRY, hQueryDefault, sQuery)
HReadFirst(QRY)
let bResult = QRY.result
// bResult is set to True
```



```wl
sQuery = "SELECT 'abcde' REGEXP 'a[bcd]{2}e' AS result"
HExecuteSQLQuery(QRY, hQueryDefault, sQuery)
HReadFirst(QRY)
bResult = QRY.result
// bResult is set to False
```

<a name="SQL_BITS"></a>


### Operadores y funciones Bitwise
<a name="operadores_funciones_bitwise_ELTPARAGRAPHE002800"></a>

Los siguientes son operadores a nivel de bits: 

- & 

- | 

- ^ 

- ~ 

- &lt;&lt; 

- &gt;&gt;




Las funciones correspondientes son las siguientes: 

- BITAND, 

- BITOR, 

- BITXOR,

- BITNOT, 

- BITANDNOT.




Ejemplo: 


```wl
dsQuery is Data Source
sSQL is string = [
SELECT 
	1 | 2 AS op_or,						-- 3
	BITOR(1, 2) AS fct_or,					-- 3
	3 & 6 AS op_and,						-- 2
	BITAND(3, 6) AS fct_and,					-- 2
	~CAST(240 AS TINYINT) AS op_not,				-- 15
	BITNOT(CAST(240 AS TINYINT)) AS fct_not,			-- 15
	5 ^ 6 AS op_xor,						-- 3
	BITXOR(5, 6) AS fct_xor,					-- 3
	BITANDNOT(3,1) AS fct_andnot,				-- 2
	1 << 2 AS sl,							-- 4
	16 >> 2 AS sr							-- 4
]

HExecuteSQLQuery(dsQuery, sSQL)

Trace("Expected:")
Trace("3 - 3 - 2 - 2 - 15 - 15 - 3 - 3 - 2 - 4 - 4")
Trace("Received:")
FOR EACH dsQuery
	Trace(Replace(HRecordToString(dsQuery), TAB, " - "))
END
```

<a name="SQL_ISJSON"></a>


### ES JSON XXX
<a name="json_xxx_ELTPARAGRAPHE002828"></a>

Los comandos "IS JSON xxx" se utilizan para determinar si un elemento es:

- un contenido JSON (IS JSON),

- un contenido JSON que representa un objeto (IS JSON OBJECT),

- un contenido JSON que representa un array (IS JSON ARRAY),

- ...




**Formato de uso**:


```txt
IS [NOT] JSON [OBJECT|ARRAY|SCALAR|VALUE] (expression)
```
El comando devuelve 1 si la expresión contiene datos válidos, 0 en caso contrario. 

Ejemplo:


```sql
SELECT
	Product.Characteristics IS JSON AS ItemISJSON,
	Product.Characteristics IS JSON OBJECT AS ItemISJSONOBJECT,
	Product.Characteristics IS JSON ARRAY AS ItemISJSONARRAY,
	Product.Characteristics IS JSON SCALAR AS ItemISJSONSCALAR,
	Product.Characteristics IS JSON VALUE AS ItemISJSONVALUE
FROM
	Product
```

<a name="SQL_JSONVALUE"></a>


### JSON_VALOR
<a name="jsonvalor_ELTPARAGRAPHE002851"></a>

El comando SQL "JSON_VALUE" obtiene el valor de un elemento contenido en el elemento JSON.
**Formato de uso**:


```txt
JSON_VALUE(expression, path)
```
 donde: 

- corresponde a un texto Variable que contiene JSON

- ruta corresponde al Property para extraer. 




Ejemplo:

```sql
SELECT
	Product.Reference,
	Product.Name,
	Product.Characteristics,
	JSON_VALUE(Product.Characteristics, 
		'$.brand' DEFAULT 'no brand' ON ERROR) AS Brand
FROM
	Product
```

<a name="SQL_JSONQUERY"></a>


### JSON_CUESTA
<a name="jsoncuesta_ELTPARAGRAPHE002872"></a>

El comando SQL "JSON_QUERY" extrae un objeto o un array de una cadena JSON.
**Formato de uso**:


```txt
JSON_QUERY(expression, path)
```
 donde: 

- corresponde a una Variable que contiene un texto JSON

- ruta especifica el objeto o la array a extraer. 




Ejemplo: 


```sql
SELECT
	Product.Reference,
	Product.Name,
	Product.Characteristics,
	JSON_QUERY(Product.Characteristics, '$.colors' ) AS Colors
FROM
	Product
```

<a name="SQL_JSONEXISTS"></a>


### JSON_EXISTE
<a name="jsonexiste_ELTPARAGRAPHE002893"></a>

El comando SQL "JSON_EXISTS" permite get los registros con un elemento JSON que contiene un valor determinado. 

**Formato de uso**:


```txt
JSON_EXISTS(expression, filter)
```
 donde: 

- corresponde a una Variable que contiene un texto JSON

- El filtro corresponde a los datos que hay que extraer. 




Ejemplo: 


```sql
SELECT
	Product.Reference,
	Product.Name,
	Product.Characteristics
FROM
	Product
WHERE
	JSON_EXISTS(Product.Characteristics, '$.heel?(@ == true)')
```

<a name="SQL_JSONOBJECT"></a>


### JSON_OBJETO
<a name="jsonobjeto_ELTPARAGRAPHE002915"></a>

El comando SQL "JSON_OBJECT" devuelve un objeto JSON de cualquier elemento. El contenido recuperado de JSON es un objeto. 

Ejemplo: 
```sql
SELECT
Contact.ContactID,
JSON_OBJECT('FullName': Contact.lastname+' '+Contact.firstname, 
		'Address': Address+' '+PostalCode+' '+city+' '+country) 
		AS JSONContent
FROM
	Contact
WHERE
	ContactID <= 3
```





<a name="SQL_JSONOBJECTAGG"></a>


### JSON_OBJECTAGG
<a name="jsonobjectagg_ELTPARAGRAPHE002928"></a>

El comando SQL "JSON_OBJECTAGG" devuelve un objeto JSON que contiene pares clave-valor para cada clave y valor específicos en una set de valores SQL.

Ejemplo: 
```sql
SELECT
JSON_OBJECTAGG(Contact.lastname+' '+Contact.firstname VALUE Address+' '+
		PostalCode+' '+city+' '+country) AS JSONContent
FROM
	Contact
WHERE
	ContactID <= 3
```

<a name="SQL_JSONARRAY"></a>


### JSON_ARRAY
<a name="jsonarray_ELTPARAGRAPHE002940"></a>

El comando SQL "JSON_ARRAY" devuelve un JSON array de cualquier elemento. El contenido de JSON recuperado es un array ( [xxx, ...] ). 

Ejemplo: 
```sql
SELECT
Contact.ContactID,
JSON_ARRAY(Contact.lastname+' '+Contact.firstname) AS JSONContent
FROM
	Contact
WHERE
	ContactID <= 3
```

<a name="SQL_JSONARRAYAGG"></a>


### JSON_ARRAYAGG
<a name="jsonarrayagg_ELTPARAGRAPHE002955"></a>

El comando SQL "JSON_ARRAYAGG" devuelve una array JSON que contiene pares clave-valor para cada clave y valor específicos en una set de valores SQL. El contenido de JSON recuperado es un array ( [xxx, ...] ). 

Ejemplo: 
```sql
SELECT country, 
JSON_ARRAYAGG(customer.name) 
FROM customer 
GROUP BY country -> [ "romaric", "bob", "joe" ]
```



