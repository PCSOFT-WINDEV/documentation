


## Procedimientos automáticos
			



<a name="NOTE1"></a>
<a name="NOTE1_1"></a>


## Presentación
<a name="presentacion_ELTTEXTE000391"></a>
La programación de temporizadores, subprocesos y procedimientos retardados es ahora gestionada automáticamente por el entorno.

Ya no es necesario programar los procesos y sincronizarlos a través del código de WLanguage, todo lo que tiene que hacer es configurar las opciones del procedimiento automatizado.

No más [TimerSys](../WDLang1/3015006.md), [Timer](../WDLang1/3015008.md), [ThreadExecute](../WDLang1/3077024.md), ... Estas funciones siguen estando disponibles para la compatibilidad con versiones anteriores.

Algunos ejemplos de procesos que se pueden definir sin una sola línea de código:

- ejecutar un procedimiento cada 10 segundos (marque una casilla de correo electrónico, compruebe la presencia de un archivo en la red, ....)

- lo mismo, pero comenzando 5 minutos después de que se ejecuta el programa.

- ejecutar el procedimiento en una tarea en segundo plano (en un hilo), sin esperar a su valor de retorno.






<a name="NOTE2"></a>
<a name="NOTE2_1"></a>


## ¿Cómo proceder?
<a name="¿como_proceder_ELTTEXTE000415"></a>


### Automatización de un procedimiento
<a name="automatizacion_procedimiento_ELTPARAGRAPHE000044"></a>

Automatizar un procedimiento:

1. Mostrar el código del procedimiento.

2. Abre la ventana de descripción de las automatizaciones del procedimiento:

	- Haga clic en ![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=7&name=Proc_auto_Ico.gif) en la barra de procedimiento.

	- Seleccione "Configurar los procesos automatizados del procedimiento" de el menú contextual de procedimiento (panel "Explorador del proyecto").

	- Seleccione "Propiedades" de el menú contextual de procedimiento en el panel "Código".




3. En la ventana que aparece, seleccione el tipo de automatización: 

	- [Temporizador/procedimiento retardado](#NOTE2_2),

	- [Hilo](#NOTE2_3),

	- [Hilo principal](#NOTE2_4),






<a name="NOTE2_2"></a>


### Caso de temporizador/Procedimientos programados
<a name="caso_temporizadorprocedimientos_programados_ELTPARAGRAPHE000083"></a>

Las opciones son las siguientes: 

- Número de veces: El procedimiento de <br>![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=7&name=Timer_Comment.gif)
 T puede ser ejecutado:

	- ***en cuanto***: el procedimiento se detendrá automáticamente después de su ejecución.

	- ***en varias ocasiones***: el procedimiento se ejecutará varias veces en un fila. En este caso, se pueden espaciar las ejecuciones de procedimiento. Se implementará automáticamente un temporizador.




- El espacio entre las llamadas: Para una ejecución múltiple o infinita, esta opción permite definir el retraso entre 2 ejecuciones. 

	- ***un número infinito de veces***: el procedimiento se ejecutará un número interminable de veces. En este caso, se pueden espaciar las ejecuciones de procedimiento. Se implementará automáticamente un temporizador. 




- Puede configurar las llamadas de procedimiento subsiguientes: 

	- **Ignore el temporizador y ejecute el procedimiento inmediatamente**: 
			En este caso, sólo un temporizador está funcionando. Cualquier otra llamada ejecuta inmediatamente el procedimiento. 
			Ejemplo: actualización automática cada minuto, se ejecuta inmediatamente si se presiona F5. 

	- **Disparar un nuevo temporizador**: 
			En este caso, varios temporizadores funcionan simultáneamente. 
			Ejemplo: trigger un sondeo sobre los elementos pasados como parámetros.

	- **Reiniciar el temporizador existente**: 
			El temporizador actual se detiene y luego se reinicia, el retraso antes de la siguiente ejecución se pone a cero.. 
			Ejemplo: trigger una operación cuando el usuario deja de escribir en el teclado. 




- Cuando: <br>![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=7&name=Timer_Quand.gif)
 El procedimiento se puede llevar a cabo:

	- ***de inmediato***: el procedimiento se ejecuta tan pronto como se llama en el código.

	- ***con un arranque automático***: el procedimiento se ejecuta automáticamente después del código de inicialización (de ventana, página o proyecto). 

	- ***más tarde***: el procedimiento se ejecuta después del período especificado. 
			Si la ejecución se retrasa, este intervalo de tiempo puede mantenerse (o no) para las futuras llamadas a este procedimiento.

	- ***al final del proceso que contiene la llamada***: el procedimiento se ejecuta cuando finaliza el proceso que contiene la llamada al procedimiento.

	- ***al final del evento que contiene la llamada***: el procedimiento se ejecuta cuando finaliza el proceso que contiene la llamada al procedimiento. Para más detalles, ver ["Al final del evento que contiene la llamada"](#NOTE3_3).








<a name="NOTE2_3"></a>


### Caja de rosca
<a name="caja_rosca_ELTPARAGRAPHE000135"></a>

Esta opción se utiliza para especificar si el procedimiento debe ejecutarse en una tarea en segundo plano (en un hilo).. 

Las opciones son las siguientes: 

- Número de veces: <br>![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=7&name=Thread_Comment.gif)
 El procedimiento puede:

	- estar en funcionamiento ***en cuanto***: el procedimiento se detendrá automáticamente después de su ejecución.

	- estar en funcionamiento ***en varias ocasiones***: el procedimiento se ejecutará varias veces en un fila. En este caso, se pueden espaciar las ejecuciones de procedimiento. Se implementará automáticamente un temporizador.

	- estar en funcionamiento ***un sinfín de veces***: el procedimiento se ejecutará un número interminable de veces. En este caso, se pueden espaciar las ejecuciones de procedimiento. Se implementará automáticamente un temporizador.

	- **usar HFSQL o no**: Esta opción se utiliza para especificar si el hilo debe acceder a los archivos de datos HFSQL. 
			Son posibles dos tipos de accesos: 

		- Copia completa de context: Copia utilizada del contexto de conexiones, posiciones, consultas, ....

		- Copia ligera del contexto: Se utiliza para copiar sólo el contexto de las conexiones.




- Cuando: <br>![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=7&name=Thread_Quand.gif)
 El procedimiento se puede llevar a cabo:

	- ***de inmediato***: el procedimiento se ejecuta tan pronto como se llama en el código y automáticamente después del código de inicialización (si se ha comprobado "Ejecución automática después del código de inicialización").

	- ***más tarde***: el procedimiento se ejecuta después del período especificado. 
			Si la ejecución se retrasa, este intervalo de tiempo puede mantenerse (o no) para las futuras llamadas a este procedimiento.

	- ***al final del proceso que contiene la llamada***: el procedimiento se ejecuta cuando finaliza el proceso que contiene la llamada al procedimiento.

	- ***al final del evento que contiene la llamada***: el procedimiento se ejecuta cuando finaliza el proceso que contiene la llamada al procedimiento. Para más detalles, ver ["Al final del evento que contiene la llamada"](#NOTE3_3).






<a name="NOTE2_4"></a>


### Caja de rosca principal
<a name="caja_rosca_principal_ELTPARAGRAPHE000173"></a>

Esta opción le permite llamar a un procedimiento en el hilo principal desde un hilo secundario. Esta opción se utiliza principalmente para acceder a la GUI. Esta opción es equivalente a [ExecuteMainThread](../WDLang1/1000019862.md).

<a name="NOTE3"></a>


## Observaciones
<a name="observaciones_ELTTEXTE000457"></a>
<a name="NOTE3_1"></a>


### Icono de los procedimientos automáticos
<a name="icono_los_procedimientos_automaticos_ELTPARAGRAPHE000187"></a>

Tan pronto como un procedimiento es automatizado, el icono de ![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=7&name=Proc_auto_Ico.gif) que se encuentra a la derecha en la barra de procedimientos se convierte en ![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=7&name=Proc_auto_Ico_Vert.gif)

El icono que se encuentra a la izquierda en la barra de procedimientos indica el tipo de automatización del procedimiento:

- proceso repetido: ![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=7&name=Proc_auto_boucle.gif)

- procedimiento diferido: ![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=7&name=Proc_auto_differe.gif)

- procedimiento repetido con rosca: ![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=7&name=Proc_auto_thread_boucle.gif)

- procedimiento ejecutado en una rosca: ![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=7&name=Proc_auto_thread.gif)

- procedimiento repetido con temporizador: ![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=7&name=Proc_auto_Ico_timer.gif)

- procedimiento repetido retardado en una rosca: ![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=7&name=Proc_auto_thread_boucle_dif.gif)



<a name="NOTE3_2"></a>


### Resumen tabla
<a name="resumen_tabla_ELTPARAGRAPHE000212"></a>

A continuación, tabla presenta los diferentes casos de ejecución de los procedimientos en función de las opciones automatizadas seleccionadas:

|   |   | Las siguientes llamadas sin mantener el intervalo de tiempo o el tiempo muerto | Las siguientes llamadas mientras se mantiene el intervalo de tiempo o el tiempo muerto |
| --- | --- | --- | --- |
| Procedimiento retardado (verificado"Retrasado") | 1ª llamada manual | Tiempo de espera y luego ejecutar el procedimiento... | Tiempo de espera y luego ejecutar el procedimiento... |
| Próximas convocatorias | Ejecute el procedimiento | Tiempo de espera y luego ejecutar el procedimiento... |
| Procedimiento retrasado, repetido con tiempo de espera (marcado como "retrasado", "infinito" y "espaciar las llamadas") | 1ª llamada manual | Tiempo muerto -&gt; Procedimiento -&gt; Tiempo muerto -&gt; Procedimiento ... | Tiempo muerto -&gt; Procedimiento -&gt; Tiempo muerto -&gt; Procedimiento ... |
| Próximas convocatorias | Ejecute el procedimiento (una sola vez) | Tiempo muerto -&gt; Procedimiento -&gt; Tiempo muerto -&gt; Procedimiento ... |
| Procedimiento retardado, ejecución automática ("Retraso" y"Ejecución automática...." comprobado) | 1ª llamada automática | Tiempo de espera y luego ejecutar el procedimiento... | Tiempo de espera y luego ejecutar el procedimiento... |
| Próximas convocatorias | Ejecute el procedimiento | Tiempo de espera y luego ejecutar el procedimiento... |
| Procedimiento retrasado, ejecutado automáticamente, repetido con tiempo de espera ("Retrasado", "Infinito", "Espaciar las llamadas" y "Ejecución automática..." comprobado) | 1ª llamada automática | Tiempo muerto -&gt; Procedimiento -&gt; Tiempo muerto -&gt; Procedimiento ... | Tiempo muerto -&gt; Procedimiento -&gt; Tiempo muerto -&gt; Procedimiento ... |
| Próximas convocatorias | Ejecute el procedimiento (una sola vez) | Tiempo muerto -&gt; Procedimiento -&gt; Tiempo muerto -&gt; Procedimiento ... |


<a name="NOTE3_3"></a>


### "Al final del evento que contiene la llamada"
<a name="final_del_evento_que_contiene_llamada_ELTPARAGRAPHE000280"></a>

Los procedimientos con la opción "Al final del evento que contiene la llamada" marcada, y llamada desde un procedimiento de devolución de llamada (procedimiento utilizado por [fListFile](../WDLang1/3036058.md), [Evento](../WDLang1/3015011.md), ...) se ejecutan al final de cada llamada a la devolución de llamada.

Ejemplo:


```txt
// -----------------
// standard case
// -----------------
Click of button
// beginning of button click code
Proc1
// beginning of Procedure1 code 
Proc2
// beginning of Procedure2 code 

Call to EndEvent procedure
// end of Proc2 code
// end of Proc1 code
// end of button click code 
Execution of EndEvent procedure
```



```txt
// -------------------
// callback case
// -------------------
Click of button
Proc1
Proc2
use of fListFile
Callback1 procedure
// beginning of code of Callback1 Procedure
CallbackProc2
// beginning of code of Callback2 Procedure
Call to ProcEndEvent
// end of ProcedureCallback2 code
// end of ProcedureCallback1 code
Execution of ProcEndEvent
ProcedureCallback1
// beginning of ProcedureCallback1 code
ProcedureCallback2
// beginning of ProcedureCallback2 code
Call to ProcEndEvent
// end of ProcedureCallback2 code
// end of ProcedureCallback1 code
Execution of ProcEndEvent
```

<a name="NOTE3_4"></a>


### Detener un procedimiento automático
<a name="detener_procedimiento_automatico_ELTPARAGRAPHE000299"></a>

Para detener un procedimiento automático, simplemente use [EndAutomatedProcedure](../WDLang1/3013034.md).
<a name="NOTE3_5"></a>


### Procedimiento con inicio automático de roscas
<a name="procedimiento_con_inicio_automatico_roscas_ELTPARAGRAPHE000309"></a>

Recordatorio: En WLanguage, por defecto, cada procedimiento crea una sección crítica automática. Por lo tanto, dos hilos no pueden ejecutar el mismo procedimiento al mismo tiempo.

Si un procedimiento que desencadena automáticamente un hilo se llama dos veces:

- en modo por defecto: se ejecuta el primer procedimiento y el segundo espera a que el primero se detenga antes de ejecutarse.

- en el modo ***threadCriticalSection*** (definido por [ThreadMode](../WDLang1/3077028.md)), los dos hilos se activan al mismo tiempo.



<a name="NOTE3_6"></a>


### Programación Orientada a Objetos (POO)
<a name="programacion_orientada_objetos_poo_ELTPARAGRAPHE000324"></a>

Cuando la automatización de un procedimiento se define en un método de clase para una ejecución sin fin por temporizador, se puede hacer una sola llamada para todas las instancias:

- si la automatización del método está configurada con "Perform the call only". : sólo una de las instancias de clase realizará la llamada al método a través del temporizador.

- si la automatización del método está configurada con "Start an additional timer" (Iniciar un temporizador adicional) : todas las instancias de clase realizarán la llamada al método para la instancia actual.


Si la automatización está configurada para una ejecución sin fin en un hilo, todas las instancias de clase realizarán una llamada al método para la instancia actual.
<a name="NOTE3_7"></a>





