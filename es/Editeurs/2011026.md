
## Editor de análisis : los diferentes tipos de artículos
			



<a name="NOTE1"></a>
<a name="NOTE1_1"></a>


## Tipos de artículos
<a name="tipos_articulos_ELTTEXTE000307"></a>
Los diferentes tipos de artículos propuestos en la editor de análisis son los siguientes:<br>![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=7&name=TypeRubrique%20-%20HC%20N%B0001.gif)


| escribir a máquina | Se usa para almacenar: |
| --- | --- |
| texto | caracteres alfanuméricos<br><br>- **String**: una cadena de caracteres que contiene hasta 65.535 caracteres. Esta cadena de caracteres está en formato Ansi.<br><br>- **Text memo**: una cadena de caracteres de 4 GB como máximo. El formato RTF es compatible. Este memorándum de texto está en formato Ansi.<br><br>- **Character**: un solo carácter (inicializado por un 0 binario, Charact( 0)).<br><br>- **Unicode**: una cadena de caracteres en formato Unicode.<br><br>- **Memo texto unicode**: una cadena de caracteres de 4 GB como máximo. Esta nota de texto está en formato Unicode.<br><br><br> |
| Numeric | un valor numérico<br><br>- **Entero con signo de 1 byte**: valor incluido entre -128 y 127<br><br>- **Entero con signo de 2 bytes**: valor comprendido entre -32,768 y 32,767<br><br>- **Entero con signo de 4 bytes**: valor comprendido entre <br>	-2,147,483,648 and 2,147,483,647<br><br>- **Entero con signo de 8 bytes**: incluido entre -9.223.372.036.854.775.808 y 9.223.372.036.854.775.807<br><br>- **Unsigned 1 byte entero**: valor incluido entre 0 y 255<br><br>- **Unsigned entero de 2 bytes**: valor incluido entre 0 y 65,535<br><br>- **Unsigned 4-byte integer**: valor incluido entre 0 y 4.294.967.296<br><br>- **Unsigned 8 bytes entero**: valor incluido entre 0 y 18.446.744.073.709.551.615<br><br>- **4 byte real**: valor comprendido entre -3,4e+38 y +3,4e+38<br><br>- **8 byte real**: valor comprendido entre -1,79e+308 y +1,79e+308<br><br>- **Decimal** (WLanguage numérico): un decimal puede contener hasta 38 dígitos significativos.<br><br><br> |
| Moneda | una moneda<br>Una moneda puede contener hasta 24 dígitos significativos (hasta 18 dígitos para la parte entera y hasta 6 dígitos para la parte decimal) y puede tener un valor entre -604 462 909 807 314 587,353 087 y +604 462 909 807 314 587,353 087. |
| salir con | una fecha o una duración<br><br>- **DATE (AAAAMMDD)**: una fecha en formato AAAAMMDDD (fechas incluidas entre el 01/01/0001 y el 31/12/9999)<br><br>- **Fecha y Hora**: una fecha y hora (incluida entre el 01/01/0001 a las 00:00 y el 31/12/9999 a las 23:59). La precisión es de hasta un milisegundo.<br><br>- **Duration**: una duración en milisegundos (incluida entre <br>	-9.223.372.036.854.775.808 y 9.223.372.036.854.775.807).<br><br><br> |
| momento | una vez<br><br>- **TIME (HH)**: Tiempo incluido entre las 00H y las 23H<br><br>- **Time (HHMM)**: Tiempo incluido entre las 00H00 y las 23H59. La precisión está al día.<br><br>- **Time (HHMMSS)**: Tiempo incluido entre 00H00min00ss y 23H59mn59ss. La precisión está a la altura de la segunda.<br><br>- **Time (HHMMSSCC)**: Tiempo incluido entre 00H00min00ss00hs y 23H59mn59ss59hs. La precisión es de hasta la décima de segundo.<br><br><br>**Consejo**: Para mantener una hora con una precisión de hasta la centésima de segundo, utilice el tipo "Fecha y hora". |
| booleano | un booleano (1: True y 0: False) |
| Sonido, imagen, binario, ... | un archivo binario o una cadena<br><br>- **Image (nota binaria)**: un archivo de Image<br><br>- **Sound( memorándum binario)**: un archivo de sonido<br><br>- **OLE (memo binario)**: un archivo OLE<br><br>- **Otro memo binario**: cualquier tipo de archivo<br><br>- Cadena **Binary**: una cadena en formato binario<br><br><br> |
| Casilla de verificación | un valor associated con un control Casilla de verificación<br><br>- **Casilla de verificación**: un booleano (1: True y 0: False)<br><br>- **Unsigned 1 byte entero**: valor incluido entre 0 y 255<br><br><br> |
| Botón de opción, List Box, Combo Box | un valor associated con un control Botón de opción, un control List Box o un control Combo Box. <br><br>Tiene la posibilidad de seleccionar el siguiente subtipo: <br><br>- **Entero de 1 byte**: un índice correspondiente a una lista de valores. El valor de este índice oscila entre -128 y 127<br><br>- **2-byte integer**: un índice correspondiente a una lista de valores. El valor de este índice oscila entre -32,768 y 32,767<br><br>- **4-byte integer**: un índice correspondiente a una lista de valores. El valor de este índice está entre <br>	-2,147,483,648 and 2,147,483,647<br><br>- **Unsigned 1 byte entero**: un índice correspondiente a una lista de valores. El valor de este índice va de 0 a 255<br><br><br> |
| ID automático | el identificador de cada archivo Record. <br>Su valor es actualizado automáticamente por el motor de la base de datos HFSQL.<br><br>- **Identificador automático (4 bytes)**: el identificador de cada Record (valor incluido entre 0 y 2.147.483.647)<br>	Este tipo corresponde al tipo "Identificador" de WINDEV 5.5<br><br>- **Identificador automático (8 bytes)**: el identificador de cada Record (valor incluido entre 0 y 9.223.372.036.854.775.807)<br><br>- **automatic UUID (128 bits)**: el identificador de cada Record corresponde a un UUID de 128 bits. En este caso, el UUID se utiliza para obtener un identificador único no secuencial.<br><br>- **automatic UUID (256 bits)**: el identificador de cada Record corresponde a un UUID de 256 bits. En este caso, el UUID se utiliza para obtener un identificador único no secuencial.<br><br><br><br><br>Observación: El mismo Record puede tener un automatic UUID y un identificador automatic (por ejemplo, para simplificar la migración). <br><br> |
| XML | una cadena de caracteres XML (4 GB máximo). Esta cadena se almacena como una nota de texto. |
| Índice de texto completo | los diferentes elementos del índice de texto completo. El índice de texto completo puede incluir posiciones de texto o posiciones de nota de texto.<br><br>Para más detalles sobre cómo crear un índice de texto completo en el análisis, véase [Búsqueda e índice de texto completo](../WDLang4/3044375.md). |
| Enumeración, Combinación | <br><br>- Enumeración: un valor entero entre los posibles valores definidos en la enumeración associated con el artículo.<br><br>- Combinación: un valor entero que representa una combinación de posibles valores definidos en la combinación associated con el artículo.<br><br><br><br><br>Para más detalles sobre cómo crear un elemento de Enumeración o Combinación, véase [Enumeración y Combinación de ítems](../Editeurs/9500222.md). |
| Fórmula | una cadena de caracteres en lenguaje SQL que representa una fórmula de cálculo. La fórmula puede utilizar funciones SQL y/o WLanguage (WL.). Sólo se almacena la fórmula, el valor se calcula cuando se accede a la Record en sólo lectura.<br><br>Por ejemplo, calcular la edad a partir del elemento DateOfBirth del archivo. El valor se calculará en el archivo de datos directamente. <br><br><pre><code>CAST(TO_CHAR(SYSDATE,'YYYY') AS int)<br>	- CAST(TO_CHAR(datenaissance, 'YYYY') AS int)</code></pre><br><br><br>Sin embargo, el valor calculado puede almacenarse en el archivo para evitar tener que volver a realizar el cálculo.<br><br>Tiene la capacidad de almacenar la fórmula en Unicode: el cálculo será más rápido pero un espacio mayor será ocupado por la fórmula.<br><br>Si se modifica el Record, se vuelve a ejecutar la fórmula de cálculo para actualizar la memoria intermedia del archivo de datos con el nuevo valor.<br><br>Atención: La gestión NULL cumple con el estándar SQL. Por ejemplo, si una expresión añade el valor NULL a un valor, el resultado corresponde al valor NULL. |
| Timestamp | una DateTime o una Fecha o una Hora que representa la fecha de creación del Record o la fecha de la última modificación realizada en el Record.<br><br>Es posible elegir: <br><br>- si se debe grabar la fecha de creación o la última fecha de modificación.<br><br>- si debe utilizarse la hora local o la hora UTC.<br><br><br><br><br>Este tipo de elemento también se denomina "elemento automatic DateTime". |
| UUID | a UUID. Un UUID (Universal Unique IDentifier) es un número aleatorio que se considera único. Un UUID es útil para identificar de manera fácil y confiable cualquier elemento.<br><br>Es posible elegir: <br><br>- un UUID de 128 bits. Este tipo de elemento UUID cumple con el estándar RFC 4122 en 128 bits. Sólo el UUID de 128 bits está estandarizado.<br><br>- un UUID de 256 bits. <br><br><br><br><br>Para gestionar un identificador automatic de tipo UUID (automatic aliado inicializado por HFSQL), es necesario utilizar un elemento de tipo "Identificador", con el subtipo "automatic UUID". <br><br>Observación: El interés principal de UUID es permitir la anonimización y la seudonimización, útil para el cumplimiento con el estándar RGPD. El UUID también le permite gestionar identificadores de criptocurrency. |
| JSON | una cuerda JSON. Este tipo de elemento puede contener NULL, una cadena vacía o una JSON válida.. JSON se verifica automáticamente cuando se escribe el Record. <br><br>Este tipo de elemento se utiliza con las funciones JSON SQL en particular. |
| Contraseña | una cadena utilizada como contraseña. <br><br>La cadena contenida en este elemento está salada y con hash. El resultado de estas operaciones se almacena en el artículo, así como la sal y el tipo de algoritmo utilizado. No es posible reconstruir la contraseña original con estos datos..  <br><br>Esta contraseña no puede ser mostrada al usuario.<br><br>Es posible elegir: <br><br>- la función de derivación de claves,<br><br>- el algoritmo de hash,<br><br>- el número de iteraciones,<br><br>- la longitud de salida. <br><br><br><br><br> Para obtener más información, consulte [Tipo de elemento: Contraseña segura](../Editeurs/9500235.md). |


**Observación**: Los elementos Unicode son gestionados por la biblioteca wdxxxuni.dll. Esta biblioteca no está disponible en WINDEV Mobile.


### Campos de tipo Array
<a name="campos_tipo_array_ELTPARAGRAPHE000235"></a>

Algunos tipos de artículos pueden corresponder a un array: el contenido del artículo será indexado.

Para definir una posición de Array: 

1. Crear un campo. Los siguientes tipos de artículos pueden corresponder a un array: Texto, Numérico, Moneda, Fecha, Hora, Booleano, Casilla de verificación. 

2. En el artículo description: 

	- Comprobar "Array" y especificar la dimensión array. 
			Atención: La dimensión array es fija. El espacio correspondiente se reserva incluso si la posición no está llena.

	- Se muestra el tamaño real del elemento.




3. Especificar (si es necesario) los valores de Default de cada elemento de array. 

4. Validar. 




**Observaciones**: 

- El primer índice comienza en 1. 

- La siguiente sintaxis se utiliza para los elementos de manipular array: &lt;Nombre de archivo&gt;.&lt;Nombre de elemento&gt;[&lt;Índice&gt;]

- Atención: Este tipo de elemento se conserva para la compatibilidad con versiones anteriores.. La mayoría de las bases de datos SQL no soportan este tipo de elementos. 





