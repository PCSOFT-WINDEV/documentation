


## sEvent( Función)



<a name="XUse"></a>
<a name="Use"></a>
<a name="description"></a>
Se ramifica un Event en un puerto serial.




<a name="Example1"></a>
<a name="sample_code"></a>

## Ejemplo


```wl
// Detect characters on COM1 port
sEvent(1, sEveCharReceived, "ReadCharacter")
```

```wl
// -- ReadCharacter procedure
PROCEDURE ReadCharacter(PortNum, EventNum)
Trace(sRead(1, sInEntryQueue(1)))
```

<a name="XSYNTAX"></a>
<a name="SYNTAX1"></a>

## Sintaxis

`<Result> = sEvent(<Port number> , <Event managed> , <WLanguage procedure>)`
---

**`<Result>: (booleano)`**



- <u><u><u><u>True</u></u></u></u> si se ejecutó la función,

- <u><u><u><u>False</u></u></u></u> en caso contrario. **sEvent** no tiene efecto si el puerto no ha sido abierto previamente en modo "gestión Event" (con [sOpen](../WDLang3/3062013.md)).




**`<Port number>: (Integro)`**



- Número del puerto serie (1, 2, 3, hasta 32 para COM1, COM2, COM3, ... COM32). 

- Número de puerto devuelto por [sOpen](../WDLang3/3062013.md) (si esta función fue llamada con un nombre de puerto).




**`<Event managed>: (Constante o combinación de constantes de tipo Integer)`**

Event para recuperar en el puerto:


|   |   |
| --- | --- |
| *sEveBreak*<br>(valor: 64) | Recibe una "línea de ruptura" Event |
| *sEveCharReceived*<br>(valor: 1) | Recibir un personaje |
| *sEveCTS*<br>(valor: 8) | Cambio de estado del CTS |
| *sEveDSR*<br>(valor: 16) | Cambio de estado de DSR |
| *sEveEntryQueue80*<br>(valor: 1024) | El búfer de entrada está lleno a 80%<br>![Java](https://doc.pcsoft.fr/ext/images/us/JAVA.png) Esta constante no está disponible. |
| *sEveError* <br>(valor: 128) | Detectar un error en el Line<br>![Java](https://doc.pcsoft.fr/ext/images/us/JAVA.png) Esta constante no está disponible. |
| *sEvePrinterError*<br>(valor: 512) | Error de impresora detectado<br>![Java](https://doc.pcsoft.fr/ext/images/us/JAVA.png) Esta constante no está disponible. |
| *sEveRing*<br>(valor: 256) | Detección de la señal "Ring" (anillo) |
| *sEveRLSD*<br>(valor: 32) | Cambio de estado del RLSD<br>![Java](https://doc.pcsoft.fr/ext/images/us/JAVA.png) Esta constante no está disponible. |
| *sEveTransmitCompleted*<br>(valor: 4) | El búfer de salida está vacío |



**`<WLanguage procedure>: (Nombre de Procedure)`**

Nombre del WLanguage Procedure llamado cada vez que se detecta el Event especificado. Este procedimiento tiene el siguiente formato:


```txt
PROCEDURE <Procedure name>(<Port number>, <Event number>)
```
donde &lt;Número de puerto&gt; corresponde al puerto donde ocurrió el Event

donde &lt;Número de evento&gt; corresponde a una de las constantes de evento.  



<a name="NOTE0"></a>
<a name="NOTE0_1"></a>

## Observaciones


### Detección de eventos e hilos
<a name="deteccion_eventos_hilos_ELTPARAGRAPHE000151"></a>

La detección de eventos se realiza en un hilo específico del WLanguage. La llamada al WLanguage Procedure se realiza en este thread. Por lo tanto, este Procedure está sujeto a las limitaciones de thread (especialmente para la visualización).

Para más detalles sobre los hilos, véase [Gestión de hilos](../WDLang1/3077026.md).
<a name="NOTE0_2"></a>


### Gestión de eventos muy próximos
<a name="gestion_eventos_muy_proximos_ELTPARAGRAPHE000163"></a>

Si se dispara otro Event durante el Procedure disparado por el Event, este último Event no será detectado. 

Si es probable que se desencadenen eventos muy cercanos, le aconsejamos que: 

- leer solo los datos del evento (con la función [sRead](../WDLang3/3062012.md)) en el procedimiento ejecutado con la función **sEvent**, 

- continuar el resto de la Process en otra thread.



<a name="NOTE0_3"></a>


### Desactivar uno o más eventos
<a name="desactivar_uno_mas_eventos_ELTPARAGRAPHE000180"></a>

Para desactivar la gestión de uno o varios eventos, utilice [sEndEvent](../WDLang3/3062008.md).
<a name="NOTE0_4"></a>


### Cerrar el puerto
<a name="cerrar_puerto_ELTPARAGRAPHE000190"></a>

Al cerrar el puerto, todos los eventos gestionados en este puerto se desactivan. Al volver a abrir el puerto, se debe volver a ejecutar la función **sEvent** para definir los eventos gestionados en este puerto.
![Java](https://doc.pcsoft.fr/ext/images/us/JAVA.png) 

### Utilización de una biblioteca externa: RXTX
<a name="utilizacion_una_biblioteca_externa_rxtx_ELTPARAGRAPHE000346"></a>

En Java, el uso de funciones para el manejo de los puertos serie y paralelo ([sOpen](../WDLang3/3062013.md), [sWrite](../WDLang3/3062009.md), [sRead](../WDLang3/3062012.md), ...) requiere la presencia de una biblioteca externa: RXTX. 

Esta biblioteca incluye un archivo Jar y una o más bibliotecas nativas que dependen del sistema operativo en el que se ejecuta la aplicación..
 
Para utilizar estas funciones: 

- el archivo Jar (RXTXComm.jar) debe: 

	- en el mismo directorio que la aplicación Java generada por WINDEV,

	- en el classpath de ejecución de la aplicación,

	- ser incluido directamente en la aplicación generada (de la asistente para la generación de la Java). 




- se deben encontrar las bibliotecas nativas correspondientes al sistema operativo en el que se ejecuta la aplicación: 

	- en el mismo directorio que la aplicación Java generada por WINDEV,

	- en la ruta de las librerías de aplicaciones (librarypath).







La biblioteca RXTX y su documentación pueden descargarse de: [http://users.frii.com/jarvi/rxtx/index.html](http://users.frii.com/jarvi/rxtx/index.html) (enlace válido en el momento de la publicación de esta documentación). 

**Atención**: La gestión de los puertos de infrarrojos no está disponible en Java. 

<a name="XComponent"></a>

## Clasificación Lógica de negocio / UI:
Lógica de negocio
## Componente:
wd280com.dll
