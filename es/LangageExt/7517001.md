
## Lenguaje externo: Programación en Visual Basic
			



<a name="NOTE1"></a>
<a name="NOTE1_1"></a>


## Presentación
<a name="presentacion_ELTTEXTE000210"></a>
Vamos a llamar a los elementos desarrollados en WINDEV (proyecto, ventanas, análisis, ... ) de Visual Basic. Este sistema se basa en el uso de las funciones declaradas en el wdxxxle.dll de WINDEV. El código WLanguage utilizado desde el lenguaje externo se compilará dinámicamente y se ejecutará durante la llamada.

**Este modo se ilustra en City.VBP** (en formato Visual Basic 6) suministrado en el subdirectorio "ExternalLanguages\\Basic" del directorio instalación de WINDEV.

Observaciones:

- Para migrar una aplicación desarrollada en WINDEV 5.5, consulte [Migración de una aplicación Visual Basic desarrollada en WINDEV 5.5 a WINDEV 28](../LangageExt/7517002.md).

- Esta interfaz con Visual Basic puede utilizarse hasta la versión 6 de Visual Basic (suministrada con Visual Studio 6).




<a name="NOTE2"></a>
<a name="NOTE2_1"></a>


## Implementación
<a name="implementacion_ELTTEXTE000234"></a>




### 1. Incluyendo los archivos de la interfaz Visual Basic de WINDEV
<a name="1_incluyendo_los_archivos_interfaz_visual_basic_windev_ELTPARAGRAPHE000031"></a>

Si está utilizando una base de datos en su aplicación, el primer paso consiste en generar su análisis. En la description de este análisis, especifique el lenguaje de programación utilizado así como el directorio que contendrá los archivos fuente.

A través de la generación se genera un esqueleto de programa (\*.bas). Esta operación también creará el archivo.gbl (ver abajo) requerido para usar sus archivos de datos.

Los siguientes archivos deben ser incluidos en un proyecto de Visual Basic para poder llamar a la interfaz de Visual Basic de WINDEV:
<br>![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=7&name=VisualBasic.gif)


Los archivos.glb y.bas que describen la estructura de los archivos de datos serán generados automáticamente por WINDEV al generar el análisis.
<a name="NOTE2_2"></a>


### 2. Incluyendo las declaraciones HFSQL
<a name="2_incluyendo_las_declaraciones_hfsql_ELTPARAGRAPHE000046"></a>

Los archivos .gbl y .bas correspondientes a la description de los archivos de análisis deben ser añadidos al proyecto Visual Basic. Las declaraciones de los ficheros de datos se incluyen en el fichero cuya extensión es.gbl (este fichero sustituye al.wdr creado por la versión anterior de WINDEV).

Por ejemplo, en el proyecto City.vbp (suministrado con WINDEV en el directorio "ExternalLanguages"), este archivo se llama "WD External language.gbl".

<a name="NOTE3"></a>
<a name="NOTE3_1"></a>


## Declaración e inicialización
<a name="declaracion_inicializacion_ELTTEXTE000264"></a>




### 1. Declarar el contexto HFSQL y los búferes de trabajo de cada archivo
<a name="1_declarar_contexto_hfsql_los_buferes_trabajo_cada_archivo_ELTPARAGRAPHE000058"></a>

Si la aplicación debe gestionar archivos de datos, se debe declarar un contexto de trabajo HFSQL, así como un búfer para cada archivo de datos.

Estas declaraciones se realizan mediante las siguientes líneas en el proyecto WD28 External Language.bas:


```txt
' Manage the context of the 3 HFSQL files
gCtx = EL_CreateHFContext(3) ' Structure of the CITY file
' Zip Codes & Cities
Type TYPECD
	ZIPCODE		As String * 5
	F_ZIPCODE	As String * 1
	CITY	As String * 30
	F_CITY	As String * 1
End Type
	Global CD As TYPECD
```



### 2. Inicialización de las DLLs de WINDEV
<a name="2_inicializacion_las_dlls_windev_ELTPARAGRAPHE000069"></a>

El primer paso antes de usar los elementos desarrollados en WINDEV es cargar las DLLs de WINDEV en la memoria e inicializarlas.

Estas operaciones se realizan mediante la llamada a **InitModule** en el ***callwd*** Procedure de la siguiente manera:


```txt
Call InitModule(WDCtx)
```





### 3. Inicialización de HFSQL
<a name="3_inicializacion_hfsql_ELTPARAGRAPHE000079"></a>

Si su aplicación está llamando a una base de datos, el acceso a HFSQL debe prepararse ahora.. La siguiente prueba se utiliza para comprobar si esta inicialización se realiza correctamente:


```txt
'Initialization of HF
Call Callwd("HFCTX")
If EL_HinitShare(gCtx,WDLong) = 0 Then
	MsgBox ("Error initializing the HF context.")
	Exit Sub
End If
```



### 4. Carga de la biblioteca WINDEV (WDL)
<a name="4_carga_biblioteca_windev_wdl_ELTPARAGRAPHE000086"></a>

La biblioteca WINDEV (extensión.WDL) contiene todos los elementos del proyecto (ventanas, informes, clases, consultas, análisis,...). Por lo tanto, debe ser cargado en la memoria para que sus componentes puedan ser llamados.

La operación de carga es realizada por callwd("Library,disk ....") como sigue:

**Atención**: Si la biblioteca a cargar contiene ventanas, el código de cada una de estas ventanas debe ser incluido en el correspondiente archivo ".WDW" ("Incluir el código compilado" debe ser comprobado en la pestaña "Detalles" de la description de cada ventana).


```txt
' Open the library
' if WDInt is not null, the library was not found!
Call callwd("LIBRA,disk,city.wdl")
If WDInt <> 0 Then
	' Library not found
	 Call callwd("Error,The CITY.WDL library must be found in the current directory.")
	' indicate to WINDEV that the program will be ended
	 Call HFDoneShare
	 Call WDEnd
	 Exit Sub
End If
```



### 5. Abrir el análisis del proyecto y asociar los búferes a los archivos de datos
<a name="5_abrir_analisis_del_proyecto_asociar_los_buferes_los_archivos_datos_ELTPARAGRAPHE000097"></a>

Abrir el análisis le permite llamar a los archivos de datos. Una vez que este análisis haya sido abierto por **/HOpenAnálisis**En el caso de que no haya ningún archivo de trabajo, todo lo que tiene que hacer es asociar los búferes de trabajo con los archivos descritos en este análisis:


```txt
'open the analysis
If HOpenAnalysis(gCtx, sAnalysisName, sPassword,"", "", "") = 0 Then
	MsgBox ("Error opening the analysis " + sAnalysisName)
	Exit Sub
End If
' HF buffer of the City file
Call EL_HDescribeRecord(gCtx, "CITY", 37, lArrItmCD(0), 2, sTypeCD, CD)
' HF buffer of the State file
Call EL_HDescribeRecord(gCtx, "STATE", 34, lArrItmDP(0), 2, sTypeDP, DP)
```


<a name="NOTE4"></a>
<a name="NOTE4_1"></a>


## Ejecutar códigos WINDEV desde el idioma externo
<a name="ejecutar_codigos_windev_desde_idioma_externo_ELTTEXTE000312"></a>




### 1. Código de inicialización del proyecto WINDEV
<a name="1_codigo_inicializacion_del_proyecto_windev_ELTPARAGRAPHE000109"></a>

Este código se utiliza para iniciar el proyecto WINDEV declarando las variables globales por ejemplo. Se ejecuta desde el idioma externo mediante **CallWD("Project, ProjectName")**. Por ejemplo:


```txt
CALLWD("PROJECT,City");
```





### 2. Llamar a un código de WLanguage
<a name="2_llamar_codigo_wlanguage_ELTPARAGRAPHE000117"></a>

Todas las funciones WLanguage se pueden llamar desde el idioma externo. El comportamiento de estas funciones WLanguage, así como los valores devueltos, son idénticos tanto si se llaman:

- de WINDEV o

- desde la interfaz del lenguaje externo




Para conocer los parámetros y los valores de retorno de una función WLanguage, consulte la ayuda en línea o la documentación sobre WLanguage.

La llamada a un WLanguage Procedure desde la interfaz externa se hace a través de **CallWD**. Por ejemplo:


```txt
' Open a WINDEV window
CALLWD("OPEN, menu.wdw")
```


Notará que el parámetro esperado por **Llame a CallWD** es una cadena de caracteres que contiene el código de WLanguage a ejecutar.

Al igual que WLanguage codificado en WINDEV, esta cadena no distingue entre mayúsculas y minúsculas (caracteres en mayúscula / minúscula). Por lo tanto, el comando "Info" también puede escribirse como "INFO".


### 3. Recuperación de los eventos lanzados en las ventanas WINDEV
<a name="3_recuperacion_los_eventos_lanzados_las_ventanas_windev_ELTPARAGRAPHE000135"></a>

La entrada en las ventanas WINDEV requiere recuperar los eventos desencadenados en estas ventanas.

Para recuperar los eventos de usuario (haga clic en un menú, en un botón,...), debe implementar un sistema basado en un bucle en su programa Visual Basic. Este bucle permanecerá Active mientras se abra la ventana WINDEV y se utilizará para interceptar cada acción del usuario.

Para averiguar el tipo de acción que realiza el usuario, tiene la posibilidad de utilizar una cadena de caracteres Variable (en WLanguage) llamada **'WDKey**'. Esta Variable será usada en su código WLanguage para señalar al programa Visual Basic qué botón ha sido pulsado por ejemplo. Esta cadena no tiene límite de tamaño y puede contener las instrucciones detalladas que se recuperarán de su código de Visual Basic.

**Ejemplo**: Código Visual Basic


```txt
' open the first window of the program that contains the menu
Call callwd("OPEN,menu.wdw")
' the program loops until the File Exit option
' is selected
While WDKey <> "ESC"
	' perform the input of the menu
	Call callwd("SCREEN,input")
	'---------------------------------------
	' Test of the selected option.
	'---------------------------------------
	If WDKey = "FE" then WDKey = "ESC" ' Exit
	If WDKey = "RN" Then Call SearchCity ' Search by City
	If WDKey = "RD" Then Call SearchState ' Search by State
	If WDKey = "DD" Then Call LstState ' Display list.
	If WDKey = "DI" Then Call LstPrint ' Print.
	If WDKey = "DC" Then Call LstConfig ' Configure printer
Wend
' close the window
Call callwd("CLOSE")
```


Código de "File .. Exit" de la ventana "Menu" de WINDEV (WLanguage):


```txt
WDKey="ESC"
```


Cuando el usuario hace clic en "File...Exit", **WDKey** será devuelto al código de Visual Basic para realizar la siguiente acción.

**Observación**: La variable **WDKey** siendo una cadena de caracteres, su contenido puede ser un description detallado de la acción a realizar. Por ejemplo, "Cerrar la aplicación".

<a name="NOTE5"></a>
<a name="NOTE5_1"></a>


## Finalización de la aplicación
<a name="finalizacion_aplicacion_ELTTEXTE000348"></a>
Para finalizar el uso de la interfaz externa, todo lo que tiene que hacer es llamar a **WDEnd** que no espera ningún parámetro. Por ejemplo:


```txt
WDEnd
```



