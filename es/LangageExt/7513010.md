
## Lenguaje externo: Programación en C++ (interfaz WDWDIAL)
			



<a name="NOTE1"></a>
<a name="NOTE1_1"></a>


## Presentación
<a name="presentacion_ELTTEXTE000225"></a>
Este tercer método utiliza la herencia de clases para interconectar fácilmente una aplicación C++ y WINDEV. Este modo de programación se recomienda si ya tiene una arquitectura basada en clases (MFC por ejemplo) para sus proyectos de desarrollo.

Las clases base provistas de esta interfaz utilizan las funciones descritas en el 2º método de la Background. Para obtener más información, consulte [Detalles de los comandos para la interfaz externa](../LangageExt/7513004.md)

Este modo se ilustra en:

- el proyecto VC60API.dsp (en formato Visual C++ 6) situado en el subdirectorio "ExternalLanguages\\C" del directorio WINDEV instalación.

- el proyecto BC50API.ide (en formato Borland C 5) situado en el subdirectorio "ExternalLanguages\\C" del directorio WINDEV instalación




Observación: Otros modos están disponibles para la programación en lenguaje externo. Para obtener más información, consulte [Los modos de programación de los lenguajes externos](../LangageExt/7510002.md)

<a name="NOTE2"></a>
<a name="NOTE2_1"></a>


## Implementación
<a name="implementacion_ELTTEXTE000249"></a>


### 1. Incluyendo los archivos de la interfaz C de WINDEV
<a name="1_incluyendo_los_archivos_interfaz_windev_ELTPARAGRAPHE000031"></a>

Los siguientes archivos deben ser incluidos en un proyecto que llame a esta interfaz. Esta lista presenta el ejemplo VC60Api.dsp proporcionado con WINDEV. El archivo llamado "WD External Language.h" es específico para este proyecto y no debe ser incluido en su propio proyecto.
<br>![](https://doc.pcsoft.fr/en-US/images/image.awp?langid=7&name=mode3.gif)


Las dos líneas siguientes deben encontrarse en el código del archivo principal.c de su proyecto C:


```txt
# include "WDWDial.h" // WINDEV language and objects
#include "HFContext.h" // HyperFileSQL DBMS
```

<a name="NOTE2_2"></a>


### 2. Incluyendo las declaraciones HyperFileSQL
<a name="2_incluyendo_las_declaraciones_hyperfilesql_ELTPARAGRAPHE000044"></a>

Se debe agregar una inclusión (#include) por cada archivo de datos declarado en el análisis del proyecto WINDEV. Las declaraciones de los ficheros de datos se incluyen en el fichero cuya extensión es.h (este fichero sustituye al.wdr creado por la versión anterior de WINDEV).

Por ejemplo, en el proyecto Vc60.dsp (proporcionado con WINDEV en el directorio "ExternalLanguages"), se utiliza la siguiente Line para gestionar los ficheros City y State:


```txt
#include "WD External language.h"
```


<a name="NOTE3"></a>
<a name="NOTE3_1"></a>


## Interfaz de C++ con WINDEV
<a name="interfaz_con_windev_ELTTEXTE000279"></a>


### 1. Declarar el contexto de HyperFileSQL y los búferes de trabajo de cada archivo:
<a name="1_declarar_contexto_hyperfilesql_los_buferes_trabajo_cada_archivo_ELTPARAGRAPHE000057"></a>

Si la aplicación debe gestionar archivos de datos, debe declararse un contexto de trabajo de HyperFileSQL, así como un búfer para cada archivo de datos.

Estas declaraciones se realizan en el proyecto Vc60API.dsp mediante las siguientes líneas:


```txt
CHFContext    gclHF; // Manage the HyperFileSQL context
StCITY       gstCity; // HF buffer of City file
StSTATE gstState;       // HF buffer of State file
```

<a name="NOTE3_2"></a>


### 2. Herencia
<a name="2_herencia_ELTPARAGRAPHE000068"></a>

El uso de las ventanas WINDEV desde el lenguaje C++ se realiza por herencia de la clase CWDDialog. La clase que hereda de CWDDialog interactuará automáticamente con el objeto gráfico de la ventana y los controles encontrados en esta ventana.. En la mayoría de los casos, se utiliza una clase por tipo de ventana WINDEV.

Ejemplo de herencia:


```txt
class CMenu:public CWDDialog
{
...
}
```

<a name="NOTE3_3"></a>


### 3. Constructor
<a name="3_constructor_ELTPARAGRAPHE000079"></a>

El constructor de la clase CWDDialog toma dos parámetros como se indica a continuación:


```txt
CWDDialog::CWDDialog(LPCSTR szNameWDW, HWND hWndParent)
```


Por lo tanto, el constructor de su clase debe pasar estos parámetros a CWDDialog cuando se le llama. Veamos el código para el constructor de la clase CMenu que se encuentra en el ejemplo VC60API.dsp:


```txt
CMenu::CMenu(LPCSTR szNameWDW, HWND hWndParent): CWDDialog (szNameWDW,hWndParent)
{
}
```


El constructor de la clase puede recibir parámetros adicionales. Vea el constructor de la clase CSearch en el proyecto VC60API.dsp.
<a name="NOTE3_4"></a>


### 4. MAPA de las acciones del usuario en las ventanas
<a name="4_mapa_las_acciones_del_usuario_las_ventanas_ELTPARAGRAPHE000094"></a>

El mecanismo de la clase CWDDialog se utiliza para asociar los eventos del usuario en la ventana WINDEV con los métodos de su clase (como [nWDSetCallbackSiguiente](../LangageExt/7513012.md)), pero de forma automatic.

Esto le permite incluir la gestión completa de la ventana dentro de su clase.. Para ello:

- crear los métodos correspondientes a los diferentes procesos que deben realizarse en su ventana

- declare el MAP (asociación método&lt;-&gt;evento)

- recuperar (si es necesario) las acciones base soportadas por la clase CWDDialog (opcional)




**Creación de los métodos**
Los métodos de su clase serán llamados automáticamente por el mecanismo interno de la clase heredada de CWDDialog. Por lo tanto, pueden encapsularse con el modo"protegido" en su declaración.

Ejemplo de la clase CMenu:


```txt
class CMenu:public CWDDialog
{
public:
CMenu(LPCSTR pszNameWDW, HWND hWndParent= NULL);
protected:
void Exit( void ) {Close();}
void FindCity( void );
void FindState( void );
void LstState( void );
void LstPrint( void );
void LstConfig( void );
void Find( void );
...
}
```


**Declarar el mapa**
La siguiente declaración se utiliza para asociar los métodos creados con los eventos de usuario. Los eventos corresponden, al igual que en el método anterior, al contenido de **WDKey** rellenando el código de WLanguage.

La primera declaración a hacer en la declaración de la clase window (después de la declaración de métodos) es la siguiente:


```txt
DECLARE_KEY_MAP(CMenu);
```


Entonces, todo lo que tienes que hacer es llenar el MAPA con el método<:-Event asociaciones de la siguiente manera (fuera de la declaración de la clase). Ejemplo tomado del proyecto VC60API.dsp:


```txt
START_KEY_MAP(CMenu)
{"FE", Exit},
{"RN", FindCity},
{"RD", FindState},
{"DD", LstState},
{"DI", LstPrint},
{"DC", LstConfig},
END_KEY_MAP()
```


**Recuperar las acciones de base soportadas por CWDDialog**
La clase CWDDialog tiene en cuenta las teclas Enter y Esc (comportamiento estándar para la validación y cancelación). Para recuperar estos eventos, puede heredar del mecanismo descrito en la clase base por la siguiente Line (que se encuentra al final de sus declaraciones de métodos): HERIT_KEY_MAP(CWDDialog)

Código de declaración completa de la clase CMenu:


```txt
class CMenu:public CWDDialog
{
public:
	CMenu(LPCSTR pszNameWDW, HWND hWndParent= NULL);
protected:
	void Exit( void ) {Close();}
	void FindCity( void );
	void FindState( void );
	void LstState( void );
	void LstPrint( void );
	void LstConfig( void );
	void Find( void );
	DECLARE_KEY_MAP(CMenu);
	INHERIT_KEY_MAP(CWDDialog); // Optional
};
START_KEY_MAP(CMenu)
	{"FE", Exit},
	{"RN", FindCity},
	{"RD", FindState},
	{"DD", LstState},
	{"DI", LstPrint},
	{"DC", LstConfig},
END_KEY_MAP()
```

<a name="NOTE3_5"></a>


### 5. Asociación entre un miembro de la clase y una ventana control
<a name="5_asociacion_entre_miembro_clase_una_ventana_control_ELTPARAGRAPHE000138"></a>

Este tipo de asociación permite vincular a un miembro de la clase con un control de la ventana gestionada por la clase. Esto puede funcionar:

- para recuperar automáticamente en un miembro el contenido de la control al validar (y salir) de la ventana

- para asignar automáticamente el contenido de un miembro en un control al abrir la ventana




Una asociación de este tipo se realiza mediante la llamada a tres macrocomandos utilizados para ello:

- crear el miembro de la clase que será relacionado a la control

- inicializar la gestión de las asociaciones control/miembros

- asociar la ventana control con el miembro del mismo nombre




La creación del miembro se realiza mediante la llamada a uno de los macrocomandos de la familia "DECLARE_MEMBER_INPUT_".. Por ejemplo, el macro comando DECLARE_MEMBER_INPUT crea un miembro entero que puede ser associated con un control entero.

Los macro-comandos "DECLARE_MEMBER_INPUT" se usan para declarar un miembro cuyo nombre corresponderá al nombre de la control en la ventana. El siguiente ejemplo se extrae de la declaración de la clase CSearch:


```txt
DECLARE_MEMBER_INPUT_INT(Occur,0) // Integer control whose value = 0
```


Un macro-comando está disponible para cada tipo de control (INT significa entero). Su lista es la siguiente (para más detalles, véase el archivo WDWDIAL.H):


```txt
// RADIO BUTTON
DECLARE_MEMBER_RADIOBUTTON(NAME, INITVAL)
// LIBELLE
DECLARE_MEMBER_STATIC(NAME, INITSTR, SIZE)
// STRING EDIT
DECLARE_MEMBER_EDIT_STR(NAME, INITSTR, SIZE)
// CSTRING STRING EDIT without size limit
DECLARE_MEMBER_EDIT_CSTRING(NAME, INITSTR)
// INTEGER EDIT
DECLARE_MEMBER_EDIT_INT(NAME, INITVAL)
// MULTIPLE CHECK BOX 
// Example:
//  DECLARE_MEMBER_TABCHECKBOX(CBOX1, 10, "x x x x x ")
// set of 10 check boxes initialized so that every other one is checked
DECLARE_MEMBER_ARRCHECKBOX(NAMEWDCONTROL, NUMBER, INITSTR)
// SIMPLE CHECK BOX
DECLARE_MEMBER_CHECKBOX(NAME, INITSTATE)
// STRING COMBO BOX
DECLARE_MEMBER_COMBO_STR(NAME, INITSTR, SIZE)
// STRING LIST BOX
DECLARE_MEMBER_LIST_STR(NAME, INITSTR, SIZE)
// CTString STRING COMBO BOX without size limit
DECLARE_MEMBER_COMBO_CSTRING(NAME, INITSTR)
// INTEGER COMBO BOX
DECLARE_MEMBER_COMBO_INT(NAME, INITVAL)
```


La gestión de los controles/miembros se inicia con la macro "DECLARE_MANAGE_AUTO. Ejemplo para la clase CSearch:


```txt
DECLARE_MANAGE_AUTO(CFind)
```


Por último, la asociación entre los controles de ventana y los miembros de la clase con el mismo nombre se realiza mediante los siguientes macrocomandos (ejemplo de la clase CFind):


```txt
START_MANAGE_AUTO(CFind)
MANAGE_AUTO(Occur)
// place the other control/member associations here
END_MANAGE_AUTO()
```


<a name="NOTE4"></a>
<a name="NOTE4_1"></a>


## Uso de HyperFileSQL en C++
<a name="uso_hyperfilesql_ELTTEXTE000327"></a>
Las funciones para acceder a los archivos de datos se pueden utilizar llamando a nWDExecute (véase el Definition de esta función). Sin embargo, la interfaz del lenguaje C++ proporciona una clase (CVHFContext) para administrar los archivos HyperFileSQL.

Esta clase interconecta el uso de las funciones estándar HyperFileSQL (funciones WLanguage H\*).

Para más detalles, consulte la ayuda en línea de WINDEV (WDLang.chm) y el archivo HFContext.cpp suministrado con el proyecto VC60API.dsp


