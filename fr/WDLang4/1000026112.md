


## &lt;Source&gt;.ExécuteRequêteSQLAsynchrone (Fonction)

***En anglais : &lt;Source&gt;.ExecuteSQLQueryAsynchronous***



<a name="XUtilisation"></a>
<a name="Utilisation"></a>
<a name="description"></a>
Exécute une requête SQL de manière asynchrone. Cette requête SQL peut correspondre : 

- au code SQL saisi directement dans la fonction **&lt;Source&gt;.ExécuteRequêteSQLAsynchrone**. 

- à une variable de type Requête SQL. 




Conditions d'utilisation : 

- **Ce mode est prévu pour des requêtes ayant un temps d'exécution de plusieurs secondes. Pour une  requête immédiate ou quasi immédiate, ce mécanisme ralentit "trop" la requête.** 

- La requête doit être de type "SELECT" : elle doit renvoyer des enregistrements. 

- L'exécution d'une requête en mode asynchrone peut être effectuée uniquement à partir du contexte principal. Dans les autres cas, il est nécessaire d'utiliser des threads.

- Cette fonction ne permet pas de passer les paramètres à une requête paramétrée. Les paramètres doivent être passés avant l'exécution de la requête.  




![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Il n'est pas possible d'exécuter des requêtes dont le code SQL contient des fonctions WLangage.
<a name="Exemple1"></a>
<a name="sample_code"></a>

## Exemple


```wl
REQ_WDRSQL est une Source de Données
REQ_WDRSQL.ExécuteRequêteSQLAsynchrone(MaConnexionCS2, hRequêteDéfaut, "SELECT * FROM CLIENT"
		MaProcedurePourChaqueEnregistrement, MaProcedureFinale) 


PROCÉDURE INTERNE MaProcedurePourChaqueEnregistrement(enreg est un enregistrement)
	Trace("Procédure de traitement de chaque Enregistrement" + enreg.NomRubrique)
FIN

PROCÉDURE INTERNE MaProcedureFinale(MonRes est un entier)
	Trace("Procédure de traitement du résultat final")
	SELON MonRes
		CAS heraOK : 
		Trace("La requête et le traitement des enregistrements se sont bien exécutés.")
		CAS heraAnnulée : 
		Trace("Un traitement a renvoyé Faux. La requête et les procédures ont été annulées.")
		AUTRE CAS : 
		Trace("Une procédure ou l'exécution de la requête a rencontré une erreur.")
	FIN
FIN
```

<a name="XSYNTAXE"></a>
<a name="SYNTAXE1"></a>

## Syntaxe

### Exécuter une requête SQL (sans connexion)

`<Résultat> = <Requête>.ExécuteRequêteSQLAsynchrone([<Mode>, ] <Texte de la requête en SQL> , <Procédure WLangage pour chaque enregistrement> [, <Procédure WLangage de fin>])`
---

**`<Résultat> : (booléen)`**



- <u><u><u><u>Vrai</u></u></u></u> si l'initialisation de la requête a été effectuée, 

- <u><u><u><u>Faux</u></u></u></u> dans le cas contraire. La fonction  [HErreur](../WDLang4/3044088.md) permet d'obtenir plus d'informations sur le problème rencontré.




**`<Requête> : (Source de données)`**



- Nom de la requête qui va être exécutée. Ce nom permet de manipuler par programmation le résultat de &lt;Texte de la requête en SQL&gt;. Si une requête de même nom est déjà déclarée, elle est remplacée par la nouvelle requête.

- Nom de la variable de type [Requête SQL](../Motscles/1514082.md) contenant le code SQL de la requête. Dans ce cas, le paramètre &lt;Texte de la requête en SQL&gt; ne doit pas être précisé.




**`<Mode> : (Constante optionnelle de type Entier)`**

Option pour l'initialisation de la requête :


|   |   |
| --- | --- |
| *hRequêteDéfaut*<br>(valeur par défaut) | Initialisation de la requête. |
| *hRequêteSansCorrection* | ![OLE DB](https://doc.pcsoft.fr/ext/images/fr/OLEDB.png)![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) Le moteur HFSQL n'effectue aucune vérification de la requête. Cette option doit être utilisée si la requête comporte des ordres spécifiques à un type de connexion (Oracle, SQL Server, ...).<br><br>Attention : si cette constante est utilisée :<br><br>- il est nécessaire de préciser le nom de la connexion (paramètre &lt;Connexion&gt;).<br><br>- la fonction suivante ne peut pas être utilisée sur la requête manipulée : [&lt;Source&gt;.Filtre](../WDLang4/1000024960.md).<br><br>- il n'est pas possible d'annuler une condition en l'affectant à NULL. <br><br>- il est conseillé de ne pas spécifier de rubrique de parcours dans les fonctions suivantes : [&lt;Source&gt;.Dernier](../WDLang4/1000024217.md), [&lt;Source&gt;.LitDernier](../WDLang4/1000025020.md), [&lt;Source&gt;.LitPremier](../WDLang4/1000025022.md), [&lt;Source&gt;.Premier](../WDLang4/1000025048.md), [&lt;Source&gt;.RechercheDernier](../WDLang4/1000025054.md), [&lt;Source&gt;.RecherchePremier](../WDLang4/1000025055.md).<br><br><br> |
| *hRequêteSansCorrectionHF* | ![HFSQL Classic](https://doc.pcsoft.fr/ext/images/fr/HF.png) Le moteur HFSQL n'effectue aucune vérification du format de fichier de données (complété par des espaces ou non). A utiliser si la requête manipule à la fois des fichiers de données HFSQL au format complété par des espaces et des fichiers de données HFSQL au format non complété par des espaces. |
| *hSansBind* | ![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) SQL Server, Oracle, Sybase : Permet d'exécuter une requête sans que le bind soit activé. |


![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Accès par JDBC : Ce paramètre peut prendre uniquement la valeur *hRequêteDéfaut*. Si une autre constante est utilisée, une erreur est générée.

**`<Texte de la requête en SQL> : (Chaîne de caractères)`**

Texte de la requête SQL à exécuter. Ce texte peut correspondre à une chaîne de caractères au format ANSI ou au format Unicode.  
![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Il n'est pas possible d'exécuter des requêtes dont le code SQL contient des fonctions WLangage. Ce paramètre n'est pas disponible si &lt;Nom de la requête&gt; correspond à une variable de type Requête SQL.

**`<Procédure WLangage pour chaque enregistrement> : (Nom de procédure)`**

Procédure WLangage (également nommée "callback") exécutée pour chaque enregistrement correspondant à la requête trouvée. Cette procédure est de la forme :

```txt
PROCEDURE <Nom de la procédure>(UnEnreg est un Enregistrement)
```
où &lt;UnEnreg&gt; est une variable de type [Enregistrement](../WDLang4/1000020962.md) correspondant à l'enregistrement en cours (pour la requête exécutée). 

Par défaut, le procédure renvoie <u><u><u><u>Vrai</u></u></u></u> et passe à l'enregistrement suivant. 

Si cette procédure renvoie <u><u><u><u>Faux</u></u></u></u>, la requête est annulée et la procédure &lt;Procédure WLangage de fin&gt; est exécutée.

**`<Procédure WLangage de fin> : (Nom de procédure optionnel)`**

Procédure WLangage (également nommée "callback") exécutée à la fin de l'exécution de la requête. Cette procédure est de la forme :

```txt
PROCEDURE <Nom de la procédure>(nRésultat est un entier)
```
où &lt;nRésultat&gt; est une constante de type Entier qui peut correspondre aux valeurs suivantes : 


|   |   |
| --- | --- |
| *heraAnnulée* | La procédure exécutée pour chaque enregistrement a renvoyé <u><u><u><u>Faux</u></u></u></u>. La requête et les différentes procédures ont été annulées. |
| *heraErreur* | La requête et/ou la procédure appelée pour chaque enregistrement ont rencontré une erreur. Il est possible de connaître l'erreur avec la fonction [HErreurInfo](../WDLang4/3044071.md). |
| *heraOK* | La requête et la procédure exécutée pour chaque enregistrement se sont correctement déroulées. |




<a name="SYNTAXE2"></a>

### Exécuter une requête SQL via une connexion

`<Résultat> = <Requête>.ExécuteRequêteSQLAsynchrone([<Connexion> [, <Mode>, ]] <Texte de la requête en SQL> , <Procédure WLangage pour chaque enregistrement> [, <Procédure WLangage de fin>])`
---

**`<Résultat> : (Booléen)`**



- <u><u><u><u>Vrai</u></u></u></u> si l'initialisation de la requête a été effectuée, 

- <u><u><u><u>Faux</u></u></u></u> dans le cas contraire. La fonction  [HErreur](../WDLang4/3044088.md) permet d'obtenir plus d'informations sur le problème rencontré.




**`<Requête> : (Source de données)`**



- Nom de la requête qui va être exécutée. Ce nom permet de manipuler par programmation le résultat de &lt;Texte de la requête en SQL&gt;. Si une requête de même nom est déjà déclarée, elle est remplacée par la nouvelle requête.

- Nom de la variable de type [Requête SQL](../Motscles/1514082.md) contenant le code SQL de la requête. Dans ce cas, le paramètre &lt;Texte de la requête en SQL&gt; ne doit pas être précisé.




**`<Connexion> : (Chaîne de caractères optionnelle ou variable de type Connexion)`**

Connexion utilisée pour exécuter la requête. Cette connexion correspond : 

- soit à une connexion définie sous l'éditeur d'analyses ou par programmation avec la fonction [HDécritConnexion](../WDLang4/3044205.md) ou [&lt;Variable Connexion&gt;.OuvreConnexion](../WDLang4/1000023962.md). 

- soit à une variable de type [Connexion](../WDLang4/1514073.md). 


Si ce paramètre ne correspond pas à une connexion existante, &lt;Résultat&gt; est à Faux.

**`<Mode> : (Constante optionnelle de type Entier)`**

Option pour l'initialisation de la requête :


|   |   |
| --- | --- |
| *hRequêteDéfaut*<br>(valeur par défaut) | Initialisation de la requête. |
| *hRequêteSansCorrection* | ![OLE DB](https://doc.pcsoft.fr/ext/images/fr/OLEDB.png)![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) Le moteur HFSQL n'effectue aucune vérification de la requête. Cette option doit être utilisée si la requête comporte des ordres spécifiques à un type de connexion (Oracle, SQL Server, ...).<br><br>Attention : si cette constante est utilisée :<br><br>- il est nécessaire de préciser le nom de la connexion (paramètre &lt;Connexion&gt;).<br><br>- la fonction suivante ne peut pas être utilisée sur la requête manipulée : [&lt;Source&gt;.Filtre](../WDLang4/1000024960.md).<br><br>- il n'est pas possible d'annuler une condition en l'affectant à NULL. <br><br>- il est conseillé de ne pas spécifier de rubrique de parcours dans les fonctions suivantes : [&lt;Source&gt;.Dernier](../WDLang4/1000024217.md), [&lt;Source&gt;.LitDernier](../WDLang4/1000025020.md), [&lt;Source&gt;.LitPremier](../WDLang4/1000025022.md), [&lt;Source&gt;.Premier](../WDLang4/1000025048.md), [&lt;Source&gt;.RechercheDernier](../WDLang4/1000025054.md), [&lt;Source&gt;.RecherchePremier](../WDLang4/1000025055.md).<br><br><br> |
| *hRequêteSansCorrectionHF* | ![HFSQL Classic](https://doc.pcsoft.fr/ext/images/fr/HF.png) Le moteur HFSQL n'effectue aucune vérification du format de fichier de données (complété par des espaces ou non). A utiliser si la requête manipule à la fois des fichiers de données HFSQL au format complété par des espaces et des fichiers de données HFSQL au format non complété par des espaces. |
| *hSansBind* | ![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) SQL Server, Oracle, Sybase : Permet d'exécuter une requête sans que le bind soit activé. |


![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Accès par JDBC : Ce paramètre peut prendre uniquement la valeur *hRequêteDéfaut*. Si une autre constante est utilisée, une erreur est générée.

**`<Texte de la requête en SQL> : (Chaîne de caractères)`**

Texte de la requête SQL à exécuter. Ce texte peut correspondre à une chaîne de caractères au format ANSI ou au format Unicode.  
![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Il n'est pas possible d'exécuter des requêtes dont le code SQL contient des fonctions WLangage. Ce paramètre n'est pas disponible si &lt;Nom de la requête&gt; correspond à une variable de type Requête SQL.

**`<Procédure WLangage pour chaque enregistrement> : (Nom de procédure)`**

Procédure WLangage (également nommée "callback") exécutée pour chaque enregistrement correspondant à la requête trouvée. Cette procédure est de la forme :

```txt
PROCEDURE <Nom de la procédure>(UnEnreg est un Enregistrement)
```
où &lt;UnEnreg&gt; est une variable de type [Enregistrement](../WDLang4/1000020962.md) correspondant à l'enregistrement en cours (pour la requête exécutée). 

Par défaut, le procédure renvoie <u><u><u><u>Vrai</u></u></u></u> et passe à l'enregistrement suivant. 

Si cette procédure renvoie <u><u><u><u>Faux</u></u></u></u>, la requête est annulée et la procédure &lt;Procédure WLangage de fin&gt; est exécutée.

**`<Procédure WLangage de fin> : (Nom de procédure optionnel)`**

Procédure WLangage (également nommée "callback") exécutée à la fin de l'exécution de la requête. Cette procédure est de la forme :

```txt
PROCEDURE <Nom de la procédure>(nRésultat est un entier)
```
où &lt;nRésultat&gt; est une constante de type Entier qui peut correspondre aux valeurs suivantes : 


|   |   |
| --- | --- |
| *heraAnnulée* | La procédure exécutée pour chaque enregistrement a renvoyé <u><u><u><u>Faux</u></u></u></u>. La requête et les différentes procédures ont été annulées. |
| *heraErreur* | La requête et/ou la procédure appelée pour chaque enregistrement ont rencontré une erreur. Il est possible de connaître l'erreur avec la fonction [HErreurInfo](../WDLang4/3044071.md). |
| *heraOK* | La requête et la procédure exécutée pour chaque enregistrement se sont correctement déroulées. |





<a name="NOTE0"></a>
<a name="NOTE0_1"></a>

## Remarques


### Texte de la requête SQL
<a name="texte_requete_sql_ELTPARAGRAPHE000550"></a>Si un nom de fichier de données ou un nom de rubrique contient des espaces, il est nécessaire d'entourer ces noms par des crochets dans le texte de la requête. Par exemple :

```sql
SELECT [Mon Fichier1].MaRubrique, [Mon Fichier1].[Ma rubrique1], MonFichier2.[Ma clé1]
FROM [Mon Fichier1], MonFichier2
WHERE [Mon Fichier1].[Ma clé1] = MonFichier2.[Ma clé1]
```

<a name="NOTE0_2A"></a>


### Exécuter une requête SQL paramétrée
<a name="executer_une_requete_sql_parametree_ELTPARAGRAPHE000562"></a>Une requête SQL peut contenir des paramètres. Pour exécuter ce type de requête SQL avec la fonction **&lt;Source&gt;.ExécuteRequêteSQLAsynchrone**, il faut : 

1. Dans le texte de la requête SQL, définir les différents paramètres en utilisant la notation {Nom du paramètre}. Par exemple : 
	```txt
	"SELECT * FROM client WHERE nom={p_nom}"
	```


2. Définir une variable de type **Source de données**. Le nom de cette variable doit correspondre au paramètre &lt;Nom de la requête&gt; de la fonction **&lt;Source&gt;.ExécuteRequêteSQLAsynchrone**. 
	Exemple : 
	
	```wl
	MaRequête est une Source de Données
	```


3. Spécifier la valeur des paramètres, via la syntaxe suivante : 
	
	```txt
	<Variable Source de données>.<Nom Paramètre1> = xxx
	<Variable Source de données>.<Nom Paramètre2> = xxx
	<Variable Source de données>.<Nom Paramètre3> = xxx
	```

	Exemple : 
	
	```wl
	MaRequête.p_nom = "Dupont"
	```


4. Exécuter la requête SQL avec la fonction **&lt;Source&gt;.ExécuteRequêteSQLAsynchrone**. Exemple : 
	
	```wl
	MaRequête.ExécuteRequêteSQLAsynchrone("SELECT * FROM client WHERE nom={p_nom}", maProcEnreg)
	```





**Remarque** : A chaque exécution de la requête paramétrée, la structure des paramètres de la requête est ré-initialisée.


<a name="NOTE0_2B"></a>


### Injection SQL : Comment s'en prémunir ? 
<a name="injection_sql_comment_sen_premunir_ELTPARAGRAPHE000613"></a>L'injection SQL est une technique de piratage consistant à injecter du code SQL dans les paramètres des requêtes, forçant ainsi l'exécution de code SQL non désiré. 

Pour éviter l'injection SQL lors de l'exécution de requêtes via la fonction **&lt;Source&gt;.ExécuteRequêteSQLAsynchrone**, il est nécessaire d'utiliser des requêtes paramétrées et de ne pas concaténer des chaînes pour construire la requête. 

L'utilisation de paramètres permet de ne pas interpréter le contenu comme étant du code SQL. Cette technique rend donc impossible l'injection de code SQL et élimine de nombreux risques de piratage.


<a name="NOTE0_3"></a>
![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) 

### Jointures
<a name="jointures_ELTPARAGRAPHE000639"></a>Les jointures du type (A join B on x=y) join C on y=z ... ne sont pas gérées automatiquement par les Accès Natifs : il faut utiliser dans ce cas la constante *hRequêteSansCorrection*pour gérer ce type de jointure.

**Remarque** : Ces jointures sont gérées par le moteur HFSQL.
<a name="NOTE0_4"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png)![Code Utilisateur (MCU)](https://doc.pcsoft.fr/ext/images/fr/MCU.png)![OLE DB](https://doc.pcsoft.fr/ext/images/fr/OLEDB.png)![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) 

### Pourquoi utiliser la constante hRequêteSansCorrection ?
<a name="pourquoi_utiliser_constante_hrequetesanscorrection_ELTPARAGRAPHE000653"></a>Par défaut, WINDEV et WEBDEV interprètent les requêtes SQL :

- réalisées via un Accès Natif,

- réalisées sur OLEDB et sur ODBC via le provider OLE DB.




**Pour que la requête ne soit pas interprétée, utilisez la constante hRequêteSansCorrection.**

| HRequêteSansCorrection n'est pas spécifié | HRequêteSansCorrection est spécifié |
| --- | --- |
| Détermination automatique de la connexion associée aux fichiers de données présents dans la requête. | La connexion à utiliser doit être précisée dans la fonction **&lt;Source&gt;.ExécuteRequêteSQLAsynchrone**. |
| Remplacement de tous les signes propriétaires PC SOFT (exemple : ']=' commence par) par leur équivalent en SQL standard. | Aucun remplacement n'est effectué. Il est nécessaire d'utiliser les signes SQL standard. |
| Formatage des dates et des heures selon le format utilisée par la base de données utilisée.<br>Par exemple, les dates sont au format 'AAAAMMJJ' sous WINDEV et WEBDEV alors que sous Access, les dates sont au format #AAAAJJMM# ou #AAAAMMJJ# selon la langue du système. | Aucun formatage n'est effectué. Il est nécessaire d'utiliser le format reconnu par la base de données. |
| Formatage des flottants (le séparateur de décimal peut être '.' ou ',') | Aucun formatage des flottants n'est réalisé. |
| Selon la base de données utilisée, remplacement des noms d'alias par les noms complets des rubriques dans les clauses Where, Order by et Group by<br>Par exemple, le moteur JET (Access, DBase, ...) n'accepte pas de noms d'alias dans la clause Where d'une requête | Aucun remplacement n'est effectué. Il est nécessaire d'utiliser directement dans le code de la requête les noms complets des rubriques dans les clauses Where, Order by et Group by. |


![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) **Cas particulier : Oracle et SQL Server** : Si la requête à exécuter contient un script avec ":param" (Oracle) ou "@param" (SQL Server), il faut utiliser la combinaison de constantes *hRequêteSansCorrection* + *hSansBind* pour que la requête ne soit pas interprétée.
<a name="NOTE0_5"></a>


### Condition sur une clé composée dans une requête SQL
<a name="condition_sur_une_cle_composee_dans_une_requete_sql_ELTPARAGRAPHE000708"></a>Pour définir une condition sur une clé composée dans une requête SQL, **il faut préciser les conditions de chacune des composantes de la clé**.

Il ne faut pas tenter d'affecter directement la clé composée avec une valeur (en effet, les clés composées sont enregistrées sous forme de valeur binaire).

**Exemple** : La clé composée des rubriques NOM et PRENOM (rubrique NOMPRENOM) :

```sql
SELECT MonFichier.MaRubrique, MonFichier.MaRubrique1
FROM MonFichier
WHERE NomFichier.Nom = "Dupont" AND NomFichier.Prénom = "Florence"
```


<a name="XComposante"></a>

## Classification Métier / UI :
Code métier
## Composante :
wd280hf.dll
