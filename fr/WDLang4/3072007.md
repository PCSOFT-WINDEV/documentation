


## SQLExec (Fonction)

***En anglais : SQLExec***



<a name="XUtilisation"></a>
<a name="Utilisation"></a>
<a name="description"></a>
Nomme et exécute une requête SQL.

**Attention** : La fonction **SQLExec** ne lance pas le traitement de récupération du résultat en mémoire. La récupération du résultat est effectuée lors du premier appel à l'une des fonctions suivantes : [SQLPremier](../WDLang4/3072017.md), [SQLTable](../WDLang4/3072031.md) ou [SQLFetch](../WDLang4/3072011.md).

**Remarque** : Pour manipuler un mémo binaire dans une requête, utilisez le mot-clé ***WDMemoBinaire*** dans le texte de votre requête (pour plus de détails, consultez [les remarques](#NOTE0_5)).




<a name="Exemple1"></a>
<a name="sample_code"></a>

## Exemple
<a class="notetitle" target="_blank" href="$DOC$=1000003072007&name=sqlexec_fonction&product=WD">Voir des exemples supplémentaires</a>
![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png)![Code Utilisateur (MCU)](https://doc.pcsoft.fr/ext/images/fr/MCU.png)![HFSQL Classic](https://doc.pcsoft.fr/ext/images/fr/HF.png)![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png)![Hyper File 5.5](https://doc.pcsoft.fr/ext/images/fr/HF55.png)![OLE DB](https://doc.pcsoft.fr/ext/images/fr/OLEDB.png)![ODBC](https://doc.pcsoft.fr/ext/images/fr/ODBC.png)![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) 
```wl
// Connexion à la base de données
// (Fonction SQLConnecte ou SQLConnecteWS)

// Exécuter la requête et récupérer le résultat ligne à ligne 
i est un entier = 0
SQLExec("SELECT NOM, PRENOM, POSTE, PHOTO FROM CLIENT", "REQ1")
TANTQUE SQLAvance("REQ1") = 0  // Il y a encore une ligne à lire
	i++
	// Récupérer les données
	NOM[i] = SQLLitCol("REQ1", 1)
	PRENOM[i] = SQLLitCol("REQ1", 2)
	POSTE[i] = SQLLitCol("REQ1", 3)
	{"IMAGE"+i} = SQLLitMémo("REQ1", 4)
FIN
SQLFerme("REQ1")

// Déconnexion (fonction SQLDéconnecte)
```

<a name="XSYNTAXE"></a>
<a name="SYNTAXE1"></a>

## Syntaxe

### Exécuter une requête SQL

`<Résultat> = SQLExec(<Texte de la requête en SQL> , <Nom de la requête>)`
---

**`<Résultat> : (Booléen)`**



- <u><u><u><u>Vrai</u></u></u></u> si la requête a été exécutée, 

- <u><u><u><u>Faux</u></u></u></u> dans le cas contraire. Si la requête n'a pas été exécutée, le message d'erreur peut être connu grâce à la variable SQL.MesErreur, après l'exécution de la fonction [SQLInfoGene](../WDLang4/3072028.md).




**`<Texte de la requête en SQL> : (Chaîne de caractères)`**

Code SQL de la requête à exécuter.

**`<Nom de la requête> : (Chaîne de caractères)`**

Nom associé au texte de la requête. Correspond :

- soit au nom logique de la requête.

- soit au nom et au chemin complet de la requête (fichier ".WDR").


![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Le nom de la requête correspond uniquement au nom logique de la requête. 


<a name="SYNTAXE2"></a>

<a name="NOTE0"></a>
<a name="NOTE0_1"></a>

## Remarques


### Exécution de la requête
<a name="execution_requete_ELTPARAGRAPHE000170"></a>Les informations concernant l'exécution de la requête peuvent être connues grâce à la fonction [SQLInfoGene](../WDLang4/3072028.md). La variable SQL.NbCol contient le nombre de colonnes du résultat de la requête.

Après son exécution et son traitement, la requête doit être libérée grâce à la fonction [SQLFerme](../WDLang4/3072015.md).
<a name="NOTE0_2"></a>


### Récupération du résultat de la requête
<a name="recuperation_resultat_requete_ELTPARAGRAPHE000185"></a>Le résultat de la requête peut être :

- Transféré dans une table ou une liste (fonction [SQLTable](../WDLang4/3072031.md)).

- Transféré dans des champs ou des variables (fonction [SQLAssocie](../WDLang4/3072004.md)).

- Récupéré ligne par ligne (fonction [SQLFetch](../WDLang4/3072011.md)).



<a name="NOTE0_3"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png)![Code Utilisateur (MCU)](https://doc.pcsoft.fr/ext/images/fr/MCU.png)![HFSQL Classic](https://doc.pcsoft.fr/ext/images/fr/HF.png)![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png) 

### Requête de type INSERT
<a name="requete_type_insert_ELTPARAGRAPHE000207"></a>Lors de l'exécution d'une requête de type INSERT, la variable **SQL.IDAuto** contient l'identifiant automatique ajouté lors du précédent INSERT.
<a name="NOTE0_4"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png)![Code Utilisateur (MCU)](https://doc.pcsoft.fr/ext/images/fr/MCU.png)![HFSQL Classic](https://doc.pcsoft.fr/ext/images/fr/HF.png)![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png)![Hyper File 5.5](https://doc.pcsoft.fr/ext/images/fr/HF55.png)![OLE DB](https://doc.pcsoft.fr/ext/images/fr/OLEDB.png)![ODBC](https://doc.pcsoft.fr/ext/images/fr/ODBC.png)![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) 

### Gestion des mémos texte
<a name="gestion_des_memos_texte_ELTPARAGRAPHE000216"></a>Dans le paramètre &lt;Texte de la requête&gt;, un mémo texte s'utilise comme une variable texte. Par exemple :

```wl
// Requête avec condition sur un mémo texte dont la valeur est "Bon client" 
TexteRequête = "SELECT NOMCLI FROM CLIENT WHERE MEMOCLIENT = 'Bon client'"
SQLExec(TexteRequête, "REQ1")
```

<a name="NOTE0_5"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png)![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png)![Code Utilisateur (MCU)](https://doc.pcsoft.fr/ext/images/fr/MCU.png)![ODBC](https://doc.pcsoft.fr/ext/images/fr/ODBC.png)![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) 

### Gestion des mémos binaires
<a name="gestion_des_memos_binaires_ELTPARAGRAPHE000226"></a>Pour écrire un mémo binaire dans une table (avec un ordre SQL UPDATE ou INSERT), il faut utiliser la syntaxe suivante dans le texte de la requête :

- 
	```txt
	{WDMemoBinaire('<NomFichier>' [,'Fichier'])}
	```

	où : 

	- Fichier (valeur par défaut) indique que le mémo est un mémo binaire (issu d'un fichier). 

	- WDMemoBinaire est un mot réservé. 

	- &lt;NomFichier&gt; est le nom physique d'un fichier. 
			




- 
	```txt
	{WDMemoBinaire('<NomFichier>' [,'FichierTexte'])}
	```
 où : 

	- FichierTexte indique que le mémo est un mémo texte (issu d'un fichier).

	- WDMemoBinaire est un mot réservé.

	- &lt;NomFichier&gt; est le nom physique d'un fichier. 
			







Par exemple :

```wl
// Insertion du fichier C:\PHOTO\DUPONT.BMP dans un mémo binaire
TexteRequête = "INSERT INTO CLIENT VALUES ('DUPONT', 'Jean'," + ... 
	"{WDMemoBinaire('C:\PHOTO\DUPONT.BMP')})"
SQLExec(TexteRequête, "REQ1")
// Insertion du fichier C:\DOC\LETTRE.TXT dans un mémo texte
TexteRequête = "INSERT INTO CLIENT VALUES ('DUPUIS', 'Christophe'," + ... 
	"{WDMemoBinaire('C:\DOC\LETTRE.TXT', 'FichierTexte')})"
SQLExec(TexteRequête, "REQ1")
```

**Remarque** : L'insertion de mémos binaires sur un fichier HFSQL avec les fonctions SQL n'est pas possible et provoque une erreur. Le message d'erreur est le suivant : "Initialisation de la requête impossible. Caractère {WDMemBinaire( inattendu".
<a name="NOTE0_6"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png)![Code Utilisateur (MCU)](https://doc.pcsoft.fr/ext/images/fr/MCU.png)![HFSQL Classic](https://doc.pcsoft.fr/ext/images/fr/HF.png)![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png)![Hyper File 5.5](https://doc.pcsoft.fr/ext/images/fr/HF55.png) 

### Requête SQL (fonction SQLExec ou requêtes créées par l'éditeur de requêtes)
<a name="requete_sql_fonction_docparampagetitleshort_requetes_creees_par_editeur_requetes_ELTPARAGRAPHE000266"></a>Lors de l'utilisation des instructions SQL DELETE, INSERT ou UPDATE, aucun contrôle d'intégrité et aucun contrôle de doublons ne sont réalisés sur une base de données HFSQL. Cette fonctionnalité n'est pas disponible dans cette version.

**Solution** : Utilisez les fonctions HFSQL ([HSupprime](../WDLang4/3044018.md), [HAjoute](../WDLang4/3044147.md) ou [HModifie](../WDLang4/3044042.md)) sur vos fichiers de données. Le contrôle de l'intégrité et le contrôle des doublons seront automatiquement réalisés.

**Remarque** : Les fonctions [HExécuteRequête](../WDLang4/3044080.md) et [HExécuteRequêteSQL](../WDLang4/3044084.md) permettent de vérifier l'intégrité et les doublons sur une base de données HFSQL.
<a name="NOTE0_7"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png)![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png)![Code Utilisateur (MCU)](https://doc.pcsoft.fr/ext/images/fr/MCU.png)![HFSQL Classic](https://doc.pcsoft.fr/ext/images/fr/HF.png)![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png)![Hyper File 5.5](https://doc.pcsoft.fr/ext/images/fr/HF55.png)![OLE DB](https://doc.pcsoft.fr/ext/images/fr/OLEDB.png)![ODBC](https://doc.pcsoft.fr/ext/images/fr/ODBC.png)![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) 

### Comparaison de la syntaxe avec HExécuteRequêteSQL
<a name="comparaison_syntaxe_avec_hexecuterequetesql_ELTPARAGRAPHE000297"></a>La fonction [HExécuteRequêteSQL](../WDLang4/3044084.md) permet également d'exécuter une requête SQL. Les paramètres de ces deux fonctions sont identiques mais leur ordre est inversé : en effet, la fonction [HExécuteRequêteSQL](../WDLang4/3044084.md) précise en premier le nom de la requête, puis le texte de la requête (utilisant ainsi la même norme que toutes les fonctions HFSQL).

La syntaxe de la fonction **SQLExec** est conservée pour compatibilité.
<a name="NOTE0_71"></a>


### Fonction SQLExec et les threads
<a name="fonction_docparampagetitleshort_les_threads_ELTPARAGRAPHE000315"></a>Lors de l'exécution de la fonction **SQLExec** dans un thread secondaire, la connexion utilisée doit être effectuée dans le même thread : la connexion ne peut pas être effectuée dans le thread principal (projet ou fenêtre). La connexion réalisée via la fonction [SQLConnecte](../WDLang4/3072005.md) n'est pas partagée dans les autres threads.
<a name="NOTE0_8"></a>

<a name="XComposante"></a>

## Composante :
wd280hf.dll
