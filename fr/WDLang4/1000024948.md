
## &lt;Source&gt;.ExécuteRequêteSQL (Fonction)

***En anglais : &lt;Source&gt;.ExecuteSQLQuery***

<a name="XUtilisation"></a>
<a name="Utilisation"></a>
<a name="description"></a>
Initialise une requête écrite en langage SQL et déclare cette requête au moteur HFSQL. Cette requête peut correspondre : 

- au code SQL saisi directement dans la fonction **&lt;Source&gt;.ExécuteRequêteSQL**. 

- à une variable de type Requête SQL.


Le résultat de la requête pourra ensuite être parcouru. Si une requête de même nom existe déjà, cette requête est remplacée. Le résultat est re-calculé.

**Fonctionnalité spécifique à HFSQL** : Les requêtes SQL exécutées sur des bases de données HFSQL Classic, Mobile ou Client/Serveur peuvent contenir des fonctions WLangage. Pour plus de détails, consultez [Utiliser une fonction WLangage dans une requête SQL](../Motscles/1513004.md).

**Attention** : Pour se positionner sur le premier enregistrement du résultat de la requête, utilisez par exemple la fonction [&lt;Source&gt;.LitPremier](../WDLang4/1000025022.md).

Pour libérer les ressources d'une requête saisie dans la fonction **&lt;Source&gt;.ExécuteRequêteSQL**, utilisez : 

- la fonction [&lt;Source&gt;.AnnuleDéclaration](../WDLang4/1000024192.md).

- la fonction [&lt;Source&gt;.LibèreRequête](../WDLang4/1000025011.md).




**Remarque** : une requête ne pourra pas être initialisée si :

- le nom de la requête est déjà utilisée dans l'analyse en cours (nom de fichier de données ou nom défini par une des fonctions suivantes : [&lt;Source&gt;.Déclare](../WDLang4/1000024213.md), [&lt;Source&gt;.DéclareExterne](../WDLang4/1000024214.md), [&lt;Source&gt;.DécritFichier](../WDLang4/1000024215.md)).

- une erreur de syntaxe est trouvée dans la requête.




![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Il n'est pas possible d'exécuter des requêtes dont le code SQL contient des fonctions WLangage. 
<a name="Exemple1"></a>
<a name="sample_code"></a>

## Exemple


```wl
ReqClient est une Source de Données
// Initialisation de la requête "Client"
ReqClient.ExécuteRequêteSQL("SELECT NOM FROM CLIENT")
```


<a name="3044084_Exemple2"></a>

```wl
ReqTache est une Source de Données
// Initialisation de la requête "ReqTache"
// Cette requête utilise une fonction WLangage
// Cette requête sélectionne les tâches de plus de 5 jours
ReqTache.ExécuteRequêteSQL( ...
	"SELECT Tâche.Libellé FROM Tâche " +...
	"WHERE WL.DateDifférence(Tâche.DateDébut, Tâche.DateFin) > 5")
```


<a name="3044084_Exemple3"></a>

```wl
// Modification dynamique de la condition LIMIT d'une requête SQL

REQ est une Source de Données

sMaReq est une chaîne = [
SELECT * FROM
CODEPOSTAUX
%1
]

sMaReq = ChaîneConstruit(sMaReq, "LIMIT 1, 10")
SI PAS REQ.ExécuteRequêteSQL(hRequêteDéfaut, sMaReq) ALORS
	Erreur(HErreurInfo())
SINON
	Info("La requête contient " + HNbEnr(REQ) + " enregistrements.")
FIN
```

<a name="XSYNTAXE"></a>
<a name="SYNTAXE1"></a>

## Syntaxe

### Exécuter une requête SQL (sans connexion)

`<Résultat> = <Source>.ExécuteRequêteSQL([<Mode>, ] <Texte de la requête en SQL>)`
---

**`<Résultat> : (Booléen)`**



- <u><u><u><u>Vrai</u></u></u></u> si l'initialisation de la requête SQL a été effectuée, 

- <u><u><u><u>Faux</u></u></u></u> dans le cas contraire. La fonction [HErreurInfo](../WDLang4/3044071.md) permet d'obtenir plus d'informations sur le problème rencontré.




**`<Source> : (Type correspondant à la source)`**



- Nom de la requête qui va être exécutée. Ce nom permet de manipuler par programmation le résultat de &lt;Texte de la requête en SQL&gt;. Si une requête de même nom est déjà déclarée, elle est remplacée par la nouvelle requête.

- Nom de la variable de type [Requête SQL](../Motscles/1514082.md) contenant le code SQL de la requête. Dans ce cas, le paramètre &lt;Texte de la requête en SQL&gt; ne doit pas être précisé. 
	




**`<Mode> : (Constante optionnelle de type Entier)`**

Option pour l'initialisation de la requête :


|   |   |
| --- | --- |
| *hAvecFiltre*<br>(constante combinable avec les autres constantes) | Si ce paramètre est spécifié :<br><br>- le résultat de la requête correspond à une sélection d'enregistrements de type filtre si le moteur HFSQL le permet. Sinon, le résultat de la requête est une vue HFSQL.<br><br>- les opérations suivantes ne sont pas possibles : recherche sur le résultat de la requête, requête sur requête, vue sur requête, requête sur vue.<br><br>- les rubriques de parcours spécifiées lors du parcours du résultat ne sont pas prises en compte.<br><br>- la loupe n'est pas disponible sur les tables liées à une requête.<br><br>- la fonction [&lt;Source&gt;.NbEnr](../WDLang4/1000025040.md) ne peut pas être utilisée sur les requêtes. <br>	Attention : si cette option est précisée, l'utilisation de la constante *hModifieFichier* est automatique.<br><br><br>Si ce paramètre n'est pas spécifié (par défaut) :<br><br>- le résultat de la requête correspond à une vue HFSQL.<br><br>- il est possible de réaliser les opérations suivantes sur les requêtes : recherche sur le résultat de la requête, requête sur requête, vue sur requête, requête sur vue.<br><br>- les rubriques de parcours spécifiées lors du parcours du résultat sont prises en compte.<br><br>- la loupe est disponible sur les tables liées à une requête.<br><br>- la fonction [&lt;Source&gt;.NbEnr](../WDLang4/1000025040.md) peut être utilisée sur les requêtes.<br><br><br>![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Accès par JDBC : Cette constante n'est pas disponible. |
| *hAvecTransaction* | Seules les requêtes d'écriture (INSERT, UPDATE et DELETE) sont exécutées dans une transaction.<br><br>Une transaction est démarrée, les enregistrements sont bloqués en écriture pendant l'exécution de la requête et débloqués à la fin de son exécution, que la requête échoue ou non. La transaction est donc toujours terminée à la fin de l'exécution de la fonction **&lt;Source&gt;.ExécuteRequêteSQL**. Pour les requêtes d'écriture, il n'y a pas de source de données : l'appel de la fonction [&lt;Source&gt;.LibèreRequête](../WDLang4/1000025011.md) est inutile.<br><br>Si la requête ne peut pas se terminer normalement (blocage d'enregistrements, coupure de courant, ...), la transaction est annulée et les fichiers de données sont remis dans l'état avant l'exécution de la requête.<br><br>Remarque : l'exécution de la requête pourra être fortement ralentie.<br>![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Cette constante n'est pas disponible. |
| *hModifieFichier*<br>(constante combinable avec les autres constantes) | <br><br>- **Sur des fichiers de données HFSQL** : Lors de la modification du résultat de la requête (fonctions [&lt;Source&gt;.Ajoute](../WDLang4/1000024187.md), [&lt;Source&gt;.Ecrit](../WDLang4/1000024331.md), [&lt;Source&gt;.Modifie](../WDLang4/1000025038.md), [&lt;Source&gt;.Raye](../WDLang4/1000025051.md), [&lt;Source&gt;.Supprime](../WDLang4/1000025071.md)), ces modifications seront reportées dans les fichiers de données intervenant dans la requête. <br>	Si cette option n'est pas précisée, seul le résultat de la requête est modifié. <br>	Pour plus de détails sur la modification du résultat d'une requête, consultez [Modifier le contenu d'une requête](../WDLang4/3044234.md).<br><br>- **Sur des fichiers de données non HFSQL**, la constante *hModifieFichier* est inutile : les fichiers de données intervenant dans la requête sont automatiquement modifiés lors de la modification du résultat de la requête.<br><br><br>![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Accès par JDBC : Cette constante n'est pas disponible. |
| *hRequêteDéfaut*<br>(valeur par défaut) | Initialisation de la requête sans interruption. |
| *hRequêteInterruptible* | L'initialisation de la requête peut être interrompue avec la touche ECHAP.<br>![Universal Windows 10 App](https://doc.pcsoft.fr/ext/images/fr/UNIVERSALAPP.png) Cette constante n'est pas disponible.![Procédures stockées](https://doc.pcsoft.fr/ext/images/fr/PS.png) Cette constante est ignorée.![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Accès par JDBC : Cette constante n'est pas disponible.![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png) La touche Echap doit être utilisée sur le poste client. |
| *hRequêteSansCorrection* | ![OLE DB](https://doc.pcsoft.fr/ext/images/fr/OLEDB.png)![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) Le moteur HFSQL n'effectue aucune vérification de la requête. Cette option doit être utilisée si la requête comporte des ordres spécifiques à un type de connexion (Oracle, SQL Server, ...).<br><br>Attention : si cette constante est utilisée :<br><br>- il est nécessaire de préciser le nom de la connexion (paramètre &lt;Connexion&gt;).<br><br>- la fonction suivante ne peut pas être utilisée sur la requête manipulée : [&lt;Source&gt;.Filtre](../WDLang4/1000024960.md).<br><br>- il n'est pas possible d'annuler une condition en l'affectant à NULL. <br><br>- il est conseillé de ne pas spécifier de rubrique de parcours dans les fonctions suivantes : [&lt;Source&gt;.Dernier](../WDLang4/1000024217.md), [&lt;Source&gt;.LitDernier](../WDLang4/1000025020.md), [&lt;Source&gt;.LitPremier](../WDLang4/1000025022.md), [&lt;Source&gt;.Premier](../WDLang4/1000025048.md), [&lt;Source&gt;.RechercheDernier](../WDLang4/1000025054.md), [&lt;Source&gt;.RecherchePremier](../WDLang4/1000025055.md).<br><br><br> |
| *hRequêteSansCorrectionHF* | ![HFSQL Classic](https://doc.pcsoft.fr/ext/images/fr/HF.png) Le moteur HFSQL n'effectue aucune vérification du format de fichier de données (complété par des espaces ou non). A utiliser si la requête manipule à la fois des fichiers de données HFSQL au format complété par des espaces et des fichiers de données HFSQL au format non complété par des espaces.![Universal Windows 10 App](https://doc.pcsoft.fr/ext/images/fr/UNIVERSALAPP.png) Cette constante n'est pas disponible. |
| *hSansBind* | ![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) SQL Server, Oracle, Sybase : Permet d'exécuter une requête sans que le bind soit activé. |
| *hSansSablier* | Lors de la lecture du résultat de la requête, cette lecture peut être bloquée et un sablier apparaît par défaut. Cette constante permet de ne pas afficher de sablier dans ce cas. <br><br> |
| *hSQLUnicode* | Permet de spécifier que le texte de la requête doit être envoyé sous forme Unicode au serveur. |
| *hTemporise* | Pour les requêtes UPDATE et DELETE s'appliquant sur beaucoup d'enregistrements et étant relativement longues, cette constante permet de laisser la main aux autres applications utilisant les fichiers de données.<br>Dans ce cas :<br><br>- la requête s'exécute un peu plus lentement,<br><br>- le serveur de fichiers n'est pas saturé,<br><br>- les autres utilisateurs des fichiers de données peuvent continuer à y accéder sans rencontrer de blocage.<br><br><br>![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png)![OLE DB](https://doc.pcsoft.fr/ext/images/fr/OLEDB.png)![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) Cette constante est ignorée.<br><br>![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Accès par JDBC : Cette constante n'est pas disponible. |
| *hVérifieDoublon* | Active la gestion des doublons pendant l'exécution de la requête. Si une erreur de doublons est détectée, la requête n'est pas exécutée.<br>Cette constante force la constante *hAvecTransaction*. Une transaction est démarrée, les enregistrements sont bloqués en écriture pendant l'exécution de la requête et débloqués à la fin de son exécution, que la requête échoue ou non. Si l'application est arrêtée pendant l'exécution de la requête (coupure de courant par exemple), la transaction sera annulée à la prochaine utilisation des fichiers de données de la requête.<br>Remarque : l'exécution de la requête pourra être fortement ralentie.<br>![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png) Si la constante *hVérifieDoublon* n'est pas spécifiée, la gestion des doublons est débranchée. Or, si l'utilisateur n'a pas les droits pour débrancher la gestion des doublons (fonction [&lt;Variable Connexion&gt;.ModifieDroitBaseDeDonnées](../WDLang4/1000022707.md)) et si une gestion des doublons doit être réalisée, une erreur de droit est affichée.![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Accès par JDBC : Cette constante n'est pas disponible. |
| *hVérifieIntégrité* | Active la gestion de l'intégrité pendant l'exécution de la requête. Si une erreur d'intégrité est détectée, la requête n'est pas exécutée.<br>Cette constante force la constante **hAvecTransaction**. Une transaction est démarrée, les enregistrements sont bloqués en écriture pendant l'exécution de la requête et débloqués à la fin de son exécution, que la requête échoue ou non. Si l'application est arrêtée pendant l'exécution de la requête (coupure de courant par exemple), la transaction sera annulée à la prochaine utilisation des fichiers de données de la requête.<br>Remarque : l'exécution de la requête pourra être fortement ralentie.<br>![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png) Si la constante *hVérifieIntégrité* n'est pas spécifiée, la gestion de l'intégrité est débranchée. Or si l'utilisateur n'a pas les droits pour débrancher la gestion de l'intégrité (fonction [&lt;Variable Connexion&gt;.ModifieDroitBaseDeDonnées](../WDLang4/1000022707.md)) et si une gestion de l'intégrité doit être réalisée, une erreur de droit est affichée.![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Accès par JDBC : Cette constante n'est pas disponible. |

![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Accès par JDBC : Ce paramètre peut prendre uniquement la valeur *hRequêteDéfaut*. Si une autre constante est utilisée, une erreur est générée.

**`<Texte de la requête en SQL> : (Chaîne de caractères)`**

Texte de la requête SQL à exécuter. Ce texte peut correspondre à une chaîne de caractères au format ANSI ou au format Unicode.  
![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Il n'est pas possible d'exécuter des requêtes dont le code SQL contient des fonctions WLangage. Ce paramètre n'est pas disponible si &lt;Nom de la requête&gt; correspond à une variable de type Requête SQL.


<a name="SYNTAXE2"></a>

### Exécuter une requête SQL via une connexion

`<Résultat> = <Source>.ExécuteRequêteSQL([<Connexion> [, <Mode>, ]] <Texte de la requête en SQL>)`
---

**`<Résultat> : (Booléen)`**



- <u><u><u><u>Vrai</u></u></u></u> si l'initialisation de la requête SQL a été effectuée, 

- <u><u><u><u>Faux</u></u></u></u> dans le cas contraire. La fonction [HErreurInfo](../WDLang4/3044071.md) permet d'obtenir plus d'informations sur le problème rencontré.




**`<Source> : (Type correspondant à la source)`**



- Nom de la requête qui va être exécutée. Ce nom permet de manipuler par programmation le résultat de &lt;Texte de la requête en SQL&gt;. Si une requête de même nom est déjà déclarée, elle est remplacée par la nouvelle requête.

- Nom de la variable de type [Requête SQL](../Motscles/1514082.md) contenant le code SQL de la requête. Dans ce cas, le paramètre &lt;Texte de la requête en SQL&gt; ne doit pas être précisé. 
	




**`<Connexion> : (Chaîne de caractères optionnelle ou variable de type Connexion)`**

Connexion utilisée pour exécuter la requête. Cette connexion correspond : 

- soit à une connexion définie sous l'éditeur d'analyses ou par programmation avec la fonction [HDécritConnexion](../WDLang4/3044205.md) ou [&lt;Variable Connexion&gt;.OuvreConnexion](../WDLang4/1000023962.md). 

- soit à une variable de type [Connexion](../WDLang4/1514073.md). 


Si ce paramètre ne correspond pas à une connexion existante, &lt;Résultat&gt; est à Faux.

**`<Mode> : (Constante optionnelle de type Entier)`**

Option pour l'initialisation de la requête :


|   |   |
| --- | --- |
| *hAvecFiltre*<br>(constante combinable avec les autres constantes) | Si ce paramètre est spécifié :<br><br>- le résultat de la requête correspond à une sélection d'enregistrements de type filtre si le moteur HFSQL le permet. Sinon, le résultat de la requête est une vue HFSQL.<br><br>- les opérations suivantes ne sont pas possibles : recherche sur le résultat de la requête, requête sur requête, vue sur requête, requête sur vue.<br><br>- les rubriques de parcours spécifiées lors du parcours du résultat ne sont pas prises en compte.<br><br>- la loupe n'est pas disponible sur les tables liées à une requête.<br><br>- la fonction [&lt;Source&gt;.NbEnr](../WDLang4/1000025040.md) ne peut pas être utilisée sur les requêtes. <br>	Attention : si cette option est précisée, l'utilisation de la constante *hModifieFichier* est automatique.<br><br><br>Si ce paramètre n'est pas spécifié (par défaut) :<br><br>- le résultat de la requête correspond à une vue HFSQL.<br><br>- il est possible de réaliser les opérations suivantes sur les requêtes : recherche sur le résultat de la requête, requête sur requête, vue sur requête, requête sur vue.<br><br>- les rubriques de parcours spécifiées lors du parcours du résultat sont prises en compte.<br><br>- la loupe est disponible sur les tables liées à une requête.<br><br>- la fonction [&lt;Source&gt;.NbEnr](../WDLang4/1000025040.md) peut être utilisée sur les requêtes.<br><br><br>![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Accès par JDBC : Cette constante n'est pas disponible. |
| *hAvecTransaction* | Seules les requêtes d'écriture (INSERT, UPDATE et DELETE) sont exécutées dans une transaction.<br><br>Une transaction est démarrée, les enregistrements sont bloqués en écriture pendant l'exécution de la requête et débloqués à la fin de son exécution, que la requête échoue ou non. La transaction est donc toujours terminée à la fin de l'exécution de la fonction **&lt;Source&gt;.ExécuteRequêteSQL**. Pour les requêtes d'écriture, il n'y a pas de source de données : l'appel de la fonction [&lt;Source&gt;.LibèreRequête](../WDLang4/1000025011.md) est inutile.<br><br>Si la requête ne peut pas se terminer normalement (blocage d'enregistrements, coupure de courant, ...), la transaction est annulée et les fichiers de données sont remis dans l'état avant l'exécution de la requête.<br><br>Remarque : l'exécution de la requête pourra être fortement ralentie.<br>![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Cette constante n'est pas disponible. |
| *hModifieFichier*<br>(constante combinable avec les autres constantes) | <br><br>- **Sur des fichiers de données HFSQL** : Lors de la modification du résultat de la requête (fonctions [&lt;Source&gt;.Ajoute](../WDLang4/1000024187.md), [&lt;Source&gt;.Ecrit](../WDLang4/1000024331.md), [&lt;Source&gt;.Modifie](../WDLang4/1000025038.md), [&lt;Source&gt;.Raye](../WDLang4/1000025051.md), [&lt;Source&gt;.Supprime](../WDLang4/1000025071.md)), ces modifications seront reportées dans les fichiers de données intervenant dans la requête. <br>	Si cette option n'est pas précisée, seul le résultat de la requête est modifié. <br>	Pour plus de détails sur la modification du résultat d'une requête, consultez [Modifier le contenu d'une requête](../WDLang4/3044234.md).<br><br>- **Sur des fichiers de données non HFSQL**, la constante *hModifieFichier* est inutile : les fichiers de données intervenant dans la requête sont automatiquement modifiés lors de la modification du résultat de la requête.<br><br><br>![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Accès par JDBC : Cette constante n'est pas disponible. |
| *hRequêteDéfaut*<br>(valeur par défaut) | Initialisation de la requête sans interruption. |
| *hRequêteInterruptible* | L'initialisation de la requête peut être interrompue avec la touche ECHAP.<br>![Universal Windows 10 App](https://doc.pcsoft.fr/ext/images/fr/UNIVERSALAPP.png) Cette constante n'est pas disponible.![Procédures stockées](https://doc.pcsoft.fr/ext/images/fr/PS.png) Cette constante est ignorée.![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Accès par JDBC : Cette constante n'est pas disponible.![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png) La touche Echap doit être utilisée sur le poste client. |
| *hRequêteSansCorrection* | ![OLE DB](https://doc.pcsoft.fr/ext/images/fr/OLEDB.png)![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) Le moteur HFSQL n'effectue aucune vérification de la requête. Cette option doit être utilisée si la requête comporte des ordres spécifiques à un type de connexion (Oracle, SQL Server, ...).<br><br>Attention : si cette constante est utilisée :<br><br>- il est nécessaire de préciser le nom de la connexion (paramètre &lt;Connexion&gt;).<br><br>- la fonction suivante ne peut pas être utilisée sur la requête manipulée : [&lt;Source&gt;.Filtre](../WDLang4/1000024960.md).<br><br>- il n'est pas possible d'annuler une condition en l'affectant à NULL. <br><br>- il est conseillé de ne pas spécifier de rubrique de parcours dans les fonctions suivantes : [&lt;Source&gt;.Dernier](../WDLang4/1000024217.md), [&lt;Source&gt;.LitDernier](../WDLang4/1000025020.md), [&lt;Source&gt;.LitPremier](../WDLang4/1000025022.md), [&lt;Source&gt;.Premier](../WDLang4/1000025048.md), [&lt;Source&gt;.RechercheDernier](../WDLang4/1000025054.md), [&lt;Source&gt;.RecherchePremier](../WDLang4/1000025055.md).<br><br><br> |
| *hRequêteSansCorrectionHF* | ![HFSQL Classic](https://doc.pcsoft.fr/ext/images/fr/HF.png) Le moteur HFSQL n'effectue aucune vérification du format de fichier de données (complété par des espaces ou non). A utiliser si la requête manipule à la fois des fichiers de données HFSQL au format complété par des espaces et des fichiers de données HFSQL au format non complété par des espaces.![Universal Windows 10 App](https://doc.pcsoft.fr/ext/images/fr/UNIVERSALAPP.png) Cette constante n'est pas disponible. |
| *hSansBind* | ![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) SQL Server, Oracle, Sybase : Permet d'exécuter une requête sans que le bind soit activé. |
| *hSansSablier* | Lors de la lecture du résultat de la requête, cette lecture peut être bloquée et un sablier apparaît par défaut. Cette constante permet de ne pas afficher de sablier dans ce cas. <br><br> |
| *hSQLUnicode* | Permet de spécifier que le texte de la requête doit être envoyé sous forme Unicode au serveur. |
| *hTemporise* | Pour les requêtes UPDATE et DELETE s'appliquant sur beaucoup d'enregistrements et étant relativement longues, cette constante permet de laisser la main aux autres applications utilisant les fichiers de données.<br>Dans ce cas :<br><br>- la requête s'exécute un peu plus lentement,<br><br>- le serveur de fichiers n'est pas saturé,<br><br>- les autres utilisateurs des fichiers de données peuvent continuer à y accéder sans rencontrer de blocage.<br><br><br>![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png)![OLE DB](https://doc.pcsoft.fr/ext/images/fr/OLEDB.png)![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) Cette constante est ignorée.<br><br>![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Accès par JDBC : Cette constante n'est pas disponible. |
| *hVérifieDoublon* | Active la gestion des doublons pendant l'exécution de la requête. Si une erreur de doublons est détectée, la requête n'est pas exécutée.<br>Cette constante force la constante *hAvecTransaction*. Une transaction est démarrée, les enregistrements sont bloqués en écriture pendant l'exécution de la requête et débloqués à la fin de son exécution, que la requête échoue ou non. Si l'application est arrêtée pendant l'exécution de la requête (coupure de courant par exemple), la transaction sera annulée à la prochaine utilisation des fichiers de données de la requête.<br>Remarque : l'exécution de la requête pourra être fortement ralentie.<br>![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png) Si la constante *hVérifieDoublon* n'est pas spécifiée, la gestion des doublons est débranchée. Or, si l'utilisateur n'a pas les droits pour débrancher la gestion des doublons (fonction [&lt;Variable Connexion&gt;.ModifieDroitBaseDeDonnées](../WDLang4/1000022707.md)) et si une gestion des doublons doit être réalisée, une erreur de droit est affichée.![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Accès par JDBC : Cette constante n'est pas disponible. |
| *hVérifieIntégrité* | Active la gestion de l'intégrité pendant l'exécution de la requête. Si une erreur d'intégrité est détectée, la requête n'est pas exécutée.<br>Cette constante force la constante **hAvecTransaction**. Une transaction est démarrée, les enregistrements sont bloqués en écriture pendant l'exécution de la requête et débloqués à la fin de son exécution, que la requête échoue ou non. Si l'application est arrêtée pendant l'exécution de la requête (coupure de courant par exemple), la transaction sera annulée à la prochaine utilisation des fichiers de données de la requête.<br>Remarque : l'exécution de la requête pourra être fortement ralentie.<br>![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png) Si la constante *hVérifieIntégrité* n'est pas spécifiée, la gestion de l'intégrité est débranchée. Or si l'utilisateur n'a pas les droits pour débrancher la gestion de l'intégrité (fonction [&lt;Variable Connexion&gt;.ModifieDroitBaseDeDonnées](../WDLang4/1000022707.md)) et si une gestion de l'intégrité doit être réalisée, une erreur de droit est affichée.![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Accès par JDBC : Cette constante n'est pas disponible. |

![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Accès par JDBC : Ce paramètre peut prendre uniquement la valeur *hRequêteDéfaut*. Si une autre constante est utilisée, une erreur est générée.

**`<Texte de la requête en SQL> : (Chaîne de caractères)`**

Texte de la requête SQL à exécuter. Ce texte peut correspondre à une chaîne de caractères au format ANSI ou au format Unicode.  
![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Il n'est pas possible d'exécuter des requêtes dont le code SQL contient des fonctions WLangage. Ce paramètre n'est pas disponible si &lt;Nom de la requête&gt; correspond à une variable de type Requête SQL.



<a name="NOTE0"></a>
<a name="NOTE0_1"></a>

## Remarques


### Lecture des données lors de l'initialisation
<a name="lecture_des_donnees_lors_initialisation_ELTPARAGRAPHE001056"></a>Selon la requête (tris, groupes, ...), les données peuvent ou non être lues au moment de l'initialisation de la requête.

Remarque : La propriété [ExécutionTerminée](../Proprietes/2512117.md) permet de savoir si le remplissage de la requête est terminé (et donc si les lectures peuvent être effectuées sans blocage). 

Pour accéder aux rubriques de la requête, il faut déclarer une variable de type [Source de données](../WDLang4/1514053.md) (voir Exemple). La requête est alors libérée automatiquement lorsque la variable est détruite. Pour forcer la libération des ressources de cette requête, utilisez : 

- la fonction [&lt;Source&gt;.AnnuleDéclaration](../WDLang4/1000024192.md).

- la fonction [&lt;Source&gt;.LibèreRequête](../WDLang4/1000025011.md).



<a name="NOTE0_2"></a>


### Texte de la requête SQL
<a name="texte_requete_sql_ELTPARAGRAPHE001091"></a>Si un nom de fichier de données ou un nom de rubrique contient des espaces, il est nécessaire d'entourer ces noms par des crochets dans le texte de la requête. Par exemple :

```sql
SELECT [Mon Fichier1].MaRubrique, [Mon Fichier1].[Ma rubrique1], MonFichier2.[Ma clé1]
FROM [Mon Fichier1], MonFichier2
WHERE [Mon Fichier1].[Ma clé1] = MonFichier2.[Ma clé1]
```

<a name="NOTE0_2A"></a>


### Exécuter une requête SQL paramétrée
<a name="executer_une_requete_sql_parametree_ELTPARAGRAPHE001103"></a>Une requête SQL peut contenir des paramètres. Pour exécuter ce type de requête SQL avec la fonction **&lt;Source&gt;.ExécuteRequêteSQL**, il faut : 

1. Dans le texte de la requête SQL, définir les différents paramètres en utilisant la notation {Nom du paramètre}. Par exemple : 
	```txt
	"SELECT * FROM client WHERE nom={p_nom}"
	```


2. Définir une variable de type **Source de données**. Le nom de cette variable doit correspondre au paramètre &lt;Nom de la requête&gt; de la fonction **&lt;Source&gt;.ExécuteRequêteSQL**. 
	Exemple : 
	
	```wl
	MaRequête est une Source de Données
	```


3. Spécifier la valeur des paramètres, via la syntaxe suivante : 
	
	```txt
	<Variable Source de données>.<Nom Paramètre1> = xxx
	<Variable Source de données>.<Nom Paramètre2> = xxx
	<Variable Source de données>.<Nom Paramètre3> = xxx
	```

	Exemple : 
	
	```wl
	MaRequête.p_nom = "Dupont"
	```


4. Exécuter la requête SQL avec la fonction **&lt;Source&gt;.ExécuteRequêteSQL**. Exemple : 
	
	```wl
	MaRequête.ExécuteRequêteSQL("SELECT * FROM client WHERE nom={p_nom}")
	```





**Remarque** : A chaque exécution de la requête paramétrée, la structure des paramètres de la requête est ré-initialisée.


<a name="NOTE0_2B"></a>


### Injection SQL : Comment s'en prémunir ? 
<a name="injection_sql_comment_sen_premunir_ELTPARAGRAPHE001154"></a>L'injection SQL est une technique de piratage consistant à injecter du code SQL dans les paramètres des requêtes, forçant ainsi l'exécution de code SQL non désiré. 

Pour éviter l'injection SQL lors de l'exécution de requêtes via la fonction **&lt;Source&gt;.ExécuteRequêteSQL**, il est nécessaire d'utiliser des requêtes paramétrées et de ne pas concaténer des chaînes pour construire la requête. 

Exemple : 

```wl
// Construction de la requête par concaténation
// -> faille de sécurité
sdReq est une Source de Données
sdReq.ExécuteRequêteSQL("SELECT * FROM client WHERE nom = '" + SAI_Nom + "'")
```

```wl
// Utilisation de paramètres dans la requête
// -> code sûr et sécurisé
sdReq est une Source de Données
sdReq.p_nom = SAI_Nom
sdReq.ExécuteRequêteSQL("SELECT * FROM client WHERE nom={p_nom}")
```


L'utilisation de paramètres permet de ne pas interpréter le contenu comme étant du code SQL. Cette technique rend donc impossible l'injection de code SQL et élimine de nombreux risques de piratage.


<a name="NOTE0_3"></a>
![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) 

### Jointures
<a name="jointures_ELTPARAGRAPHE001191"></a>Les jointures du type (A join B on x=y) join C on y=z ... ne sont pas gérées automatiquement par les Accès Natifs : il faut utiliser dans ce cas la constante *hRequêteSansCorrection*pour gérer ce type de jointure.

**Remarque** : Ces jointures sont gérées par le moteur HFSQL.
<a name="NOTE0_4"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png)![Code Utilisateur (MCU)](https://doc.pcsoft.fr/ext/images/fr/MCU.png)![OLE DB](https://doc.pcsoft.fr/ext/images/fr/OLEDB.png)![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) 

### Pourquoi utiliser la constante hRequêteSansCorrection ?
<a name="pourquoi_utiliser_constante_hrequetesanscorrection_ELTPARAGRAPHE001205"></a>Par défaut, WINDEV et WEBDEV interprètent les requêtes SQL :

- réalisées via un Accès Natif,

- réalisées sur OLEDB et sur ODBC via le provider OLE DB.




**Pour que la requête ne soit pas interprétée, utilisez la constante hRequêteSansCorrection.**

| HRequêteSansCorrection n'est pas spécifié | HRequêteSansCorrection est spécifié |
| --- | --- |
| Détermination automatique de la connexion associée aux fichiers de données présents dans la requête. | La connexion à utiliser doit être précisée dans la fonction **&lt;Source&gt;.ExécuteRequêteSQL**. |
| Remplacement de tous les signes propriétaires PC SOFT (exemple : ']=' commence par) par leur équivalent en SQL standard. | Aucun remplacement n'est effectué. Il est nécessaire d'utiliser les signes SQL standard. |
| Formatage des dates et des heures selon le format utilisée par la base de données utilisée.<br>Par exemple, les dates sont au format 'AAAAMMJJ' sous WINDEV et WEBDEV alors que sous Access, les dates sont au format #AAAAJJMM# ou #AAAAMMJJ# selon la langue du système. | Aucun formatage n'est effectué. Il est nécessaire d'utiliser le format reconnu par la base de données. |
| Formatage des flottants (le séparateur de décimal peut être '.' ou ',') | Aucun formatage des flottants n'est réalisé. |
| Selon la base de données utilisée, remplacement des noms d'alias par les noms complets des rubriques dans les clauses Where, Order by et Group by<br>Par exemple, le moteur JET (Access, DBase, ...) n'accepte pas de noms d'alias dans la clause Where d'une requête | Aucun remplacement n'est effectué. Il est nécessaire d'utiliser directement dans le code de la requête les noms complets des rubriques dans les clauses Where, Order by et Group by. |


![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) **Cas particulier : Oracle et SQL Server** : Si la requête à exécuter contient un script avec ":param" (Oracle) ou "@param" (SQL Server), il faut utiliser la combinaison de constantes *hRequêteSansCorrection* + *hSansBind* pour que la requête ne soit pas interprétée.
<a name="NOTE0_5"></a>


### Condition sur une clé composée dans une requête SQL
<a name="condition_sur_une_cle_composee_dans_une_requete_sql_ELTPARAGRAPHE001260"></a>Pour définir une condition sur une clé composée dans une requête SQL, **il faut préciser les conditions de chacune des composantes de la clé**.

Il ne faut pas tenter d'affecter directement la clé composée avec une valeur (en effet, les clés composées sont enregistrées sous forme de valeur binaire).

**Exemple** : La clé composée des rubriques NOM et PRENOM (rubrique NOMPRENOM) :

```sql
SELECT MonFichier.MaRubrique, MonFichier.MaRubrique1
FROM MonFichier
WHERE NomFichier.Nom = "Dupont" AND NomFichier.Prénom = "Florence"
```

<a name="NOTE0_6"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png)![Universal Windows 10 App](https://doc.pcsoft.fr/ext/images/fr/UNIVERSALAPP.png)![Code Utilisateur (MCU)](https://doc.pcsoft.fr/ext/images/fr/MCU.png)![Langage Externe](https://doc.pcsoft.fr/ext/images/fr/LE.png)![HFSQL Classic](https://doc.pcsoft.fr/ext/images/fr/HF.png)![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png)![Hyper File 5.5](https://doc.pcsoft.fr/ext/images/fr/HF55.png) 

### Requêtes sur des fichiers de données HFSQL
<a name="requetes_sur_des_fichiers_donnees_hfsql_ELTPARAGRAPHE001277"></a>

- Pour optimiser le temps d'exécution de la requête, utilisez la fonction [&lt;Source&gt;.Optimise](../WDLang4/1000025042.md) sur les différents fichiers de données intervenant dans la requête ou la fonction [HOptimiseRequête](../WDLang4/3044003.md).

- Pour optimiser le temps de traitement des requêtes, utilisez la fonction [&lt;Source&gt;.StatCalcule](../WDLang4/1000025064.md) ou la fonction [&lt;Source&gt;.Réindexe](../WDLang4/1000025060.md) sur tous les fichiers de données intervenant dans la requête.

- **Lors de l'exécution d'une requête de type INSERT sur des fichiers de données HFSQL**, il est possible de connaître l'identifiant automatique attribué au nouvel enregistrement grâce à la syntaxe &lt;Nom Fichier&gt;.&lt;Nom Rubrique Identifiant automatique&gt;.

- Si les fichiers de données manipulés par la requête ne sont pas présents dans l'analyse, il est nécessaire de déclarer ces fichiers dynamiquement au préalable avec la fonction [&lt;Source&gt;.DéclareExterne](../WDLang4/1000024214.md). Dans le cas contraire, une erreur du type **Initialisation de la requête impossible. Fichier NOMFICHIER inconnu** apparaîtra. 
	Exemple :
	
	```wl
	// Paramètres de la connexion
	cnxBase est une Connexion
	cnxBase.Provider = hAccèsHFClientServeur
	cnxBase.Serveur = "SERVEURHYPERFILESQL:4900"
	cnxBase.BaseDeDonnées = "Base"
	cnxBase.Utilisateur = "admin"
	cnxBase.MotDePasse = ""
	
	// Connexion à la base de données
	SI cnxBase.OuvreConnexion() = Faux ALORS
		Erreur(HErreurInfo())
		RETOUR
	FIN
	
	// Déclaration dynamique du (ou des) fichier(s) utilisé(s) dans la requête
	SI HDéclareExterne("CLIENT.FIC", "CLIENT", cnxBase) = Faux ALORS
		Erreur(HErreurInfo())
		RETOUR	
	FIN
	
	// Exécution de la requête
	sdRequeSQL est une Source de Données
	SI PAS sdRequeSQL.ExécuteRequêteSQL(cnxBase, hRequêteDéfaut,[
	SELECT * 
	FROM CLIENT
	]) ALORS 
		Erreur("Problème d'exécution")
	SINON
		Info("ok")
	FIN
	
	// Annule la déclaration dynamique du fichier
	HAnnuleDéclaration("CLIENT")
	
	// Ferme la connexion à la base de données
	cnxBase.FermeConnexion()
	```





- **Lors de l'exécution d'une requête de type INSERT/UPDATE/DELETE sur des fichiers de données HFSQL**, il est possible de connaître le nombre d'enregistrements ayant été ajoutés, modifiés ou supprimés grâce à la variable [H.NbEnregRequêteModification](../WDLang4/3087002.md).



<a name="NOTE0_7"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png)![Code Utilisateur (MCU)](https://doc.pcsoft.fr/ext/images/fr/MCU.png)![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) 

### Optimisation pour exécuter plusieurs fois une même requête (Accès natifs Oracle et SQL Server uniquement)
<a name="optimisation_pour_executer_plusieurs_fois_une_meme_requete_acces_natifs_oracle_sql_server_uniquement_ELTPARAGRAPHE001331"></a>Pour optimiser l'exécution d'une requête plusieurs fois, vous pouvez :

1. Déclarer une source de données. Cette source de données contiendra le résultat de la requête SQL.

2. Déclarer les différents paramètres ou variables de la requête. 
	Par défaut, les paramètres sont de type chaîne. Il est possible de préciser leur type en utilisant la propriété [Type](../Proprietes/2510131.md). 
	**Attention** : Pour préciser le type d'une variable de la requête, il est également possible d'affecter cette variable avec une variable existante du type voulu.

3. Préparer la requête avec la fonction [&lt;Source&gt;.PrépareRequêteSQL](../WDLang4/1000025050.md).

4. Indiquez la valeur du ou des différents paramètres à prendre en compte et exécuter la requête à l'aide de la fonction **&lt;Source&gt;.ExécuteRequêteSQL**. Seul le nom de la source de données correspondant à la requête doit être spécifié.




Cette dernière étape doit être répétée autant de fois que nécessaire.

**Exemple** :

```wl
// Exécution d'une même requête sous Oracle
// Déclaration d'une source de données
// Cette source de données correspond à la requête. 
Insert1 est une Source de Données
// Déclaration d'un des paramètres de la requête
// Le type de ce paramètre est un entier
Insert1.age = 0
i est un entier
// Préparation de la requête pour de multiples exécutions
Insert1.PrépareRequêteSQL(MaConnexion, ...
	hRequêteSansCorrection, ...
	"INSERT INTO PERSONE VALUES (:nom, :prenom, :age )")
// Boucle d'exécution de la requête
// Seuls quelques paramètres sont modifiés
POUR i = 1 A 10
	Insert1.nom = "Nom" + i
	Insert1.prenom = "Prenom" + i
	Insert1.age = i
	Insert1.ExécuteRequêteSQL()
FIN
```

<a name="NOTE0_8"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png)![Code Utilisateur (MCU)](https://doc.pcsoft.fr/ext/images/fr/MCU.png)![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) 

### Spécifier et récupérer des valeurs lors de l'exécution d'une requête (cas des procédures stockées)
<a name="specifier_recuperer_des_valeurs_lors_execution_une_requete_cas_des_procedures_stockees_ELTPARAGRAPHE001374"></a>**Remarque** : Cette note ne s'applique qu'aux Connecteurs Natifs Oracle et SQL Server.

Pour spécifier et récupérer des valeurs lors de l'exécution d'une requête, il faut :

1. Déclarer une source de données. Cette source de données contiendra le résultat de la requête SQL.

2. Déclarer les différentes variables de la requête (variables d'entrées et variables de sorties). 
	Par défaut, les variables sont de type chaîne. Il est possible de préciser leur type en utilisant la propriété [Type](../Proprietes/2510131.md). 
	**Attention** : Pour préciser le type d'une variable de la requête, il est également possible d'affecter cette variable avec une variable existante du type voulu.

3. Exécuter la requête à l'aide de la fonction **&lt;Source&gt;.ExécuteRequêteSQL**.



```wl
// Exemple pour Oracle
// Déclaration de la source de données associée à la requête
MaProc est une Source de Données
// Déclaration des variables
MaProc.n = 3
MaProc.str = "Exemple"
// Exécution de la requête avec récupération du résultat
MaProc.ExécuteRequêteSQL(MaConnexion, hRequêteSansCorrection, ...
	"begin :Res :=sp_cut(:n,:str);end;")
// Affichage du résultat 
Info(MaProc.Res)
```


**Remarques**

- La fonction **&lt;Source&gt;.ExécuteRequêteSQL** doit être utilisée avec :

	- le nom de la connexion,

	- la constante *hRequêteSansCorrection*.




- Les variables déclarées dans la requête doivent être identiques à celles utilisées dans le code de la procédure stockée. Dans le cas contraire, une erreur WLangage est affichée.

- Dans l'appel à la procédure stockée, il est nécessaire d'utiliser la syntaxe spécifique à la base de données utilisée, y compris pour les paramètres.
	Ainsi, pour Oracle, les paramètres sont spécifiés avec la syntaxe **:NomParam**. Attention : Le caractère ":" doit être suivi d'au moins une lettre (la syntaxe :1 est interdite). 
	Pour SQL Server, les paramètres sont spécifiés avec la notation **@NomParam**.
	Il est possible d'utiliser plusieurs fois le même paramètre. Dans ce cas, la variable correspondante sera ré-utilisée.

- Pour exécuter une requête sans que le bind ne soit activé, utilisez la constante ***hNoBind*** dans la fonction **&lt;Source&gt;.ExécuteRequêteSQL**. 



<a name="NOTE0_9"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png)![Universal Windows 10 App](https://doc.pcsoft.fr/ext/images/fr/UNIVERSALAPP.png)![Code Utilisateur (MCU)](https://doc.pcsoft.fr/ext/images/fr/MCU.png)![HFSQL Classic](https://doc.pcsoft.fr/ext/images/fr/HF.png)![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png)![Hyper File 5.5](https://doc.pcsoft.fr/ext/images/fr/HF55.png)![OLE DB](https://doc.pcsoft.fr/ext/images/fr/OLEDB.png)![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) 

### Requêtes SQL (fonction &lt;Source&gt;.ExécuteRequêteSQL ou exécution de requêtes SQL créées par l'éditeur de requêtes)
<a name="requetes_sql_fonction_docparampagetitleshort_execution_requetes_sql_creees_par_editeur_requetes_ELTPARAGRAPHE001431"></a>

**Lors de l'utilisation des instructions SQL DELETE, INSERT ou UPDATE dans des requêtes SQL, par défaut, aucun contrôle d'intégrité et aucun contrôle de doublons ne sont réalisés sur une base de données HFSQL.**

**Pour effectuer un contrôle automatique de l'intégrité**, il suffit de préciser la constante *hVérifieIntégrité*. Cette constante permet d'activer la gestion de l'intégrité pendant l'exécution de la requête. Si une erreur d'intégrité est détectée, la requête n'est pas exécutée. En effet, une transaction est démarrée, les enregistrements sont bloqués en écriture pendant l'exécution de la requête et débloqués à la fin de son exécution, que la requête échoue ou non. Si l'application est arrêtée pendant l'exécution de la requête (coupure de courant par exemple), la transaction sera annulée à la prochaine utilisation des fichiers de données de la requête.
![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png) Si la constante *hVérifieIntégrité* n'est pas spécifiée, la gestion de l'intégrité est débranchée. Or si l'utilisateur n'a pas les droits pour débrancher la gestion de l'intégrité (fonction [&lt;Variable Connexion&gt;.ModifieDroitBaseDeDonnées](../WDLang4/1000022707.md)) et si une gestion de l'intégrité doit être réalisée, une erreur de droit est affichée.**Pour effectuer un contrôle automatique des doublons**, il suffit de préciser la constante *hVérifieDoublons*. Cette constante permet d'activer la gestion des doublons pendant l'exécution de la requête. Si une erreur de doublons est détectée, la requête n'est pas exécutée. En effet, une transaction est démarrée, les enregistrements sont bloqués en écriture pendant l'exécution de la requête et débloqués à la fin de son exécution, que la requête échoue ou non. Si l'application est arrêtée pendant l'exécution de la requête (coupure de courant par exemple), la transaction sera annulée à la prochaine utilisation des fichiers de données de la requête.

Note : Si une erreur de doublons est détectée lors de l'exécution d'une requête de type UPDATE, la fonction **HExécuteRequête** renvoie Faux et le traitement continue. L'erreur correspondante peut être connue grâce à la fonction [HErreurInfo](../WDLang4/3044071.md).

**Remarque** : L'assistance automatique par défaut n'est pas appelée pour les erreurs de doublons. Une simple erreur de doublons est générée. Si une assistance a été redéfinie à l'aide de la fonction [&lt;Source&gt;.SurErreur](../WDLang4/1000025073.md), alors cette assistance personnalisée est appelée.
![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png) Si la constante *hVérifieDoublon* n'est pas spécifiée, la gestion des doublons est débranchée. Or si l'utilisateur n'a pas les droits pour débrancher la gestion des doublons (fonction [&lt;Variable Connexion&gt;.ModifieDroitBaseDeDonnées](../WDLang4/1000022707.md)) et si une gestion de doublons doit être réalisée, une erreur de droit est affichée.**Les requêtes de type UPDATE, DELETE ou INSERT n'existent que pendant leur exécution**. Il n'est pas possible d'utiliser une fonction WLangage sur ce type de requête après son exécution.
<a name="NOTE0_10"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png)![Universal Windows 10 App](https://doc.pcsoft.fr/ext/images/fr/UNIVERSALAPP.png)![Code Utilisateur (MCU)](https://doc.pcsoft.fr/ext/images/fr/MCU.png)![Langage Externe](https://doc.pcsoft.fr/ext/images/fr/LE.png)![HFSQL Classic](https://doc.pcsoft.fr/ext/images/fr/HF.png)![OLE DB](https://doc.pcsoft.fr/ext/images/fr/OLEDB.png)![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) 

### Parcours des requêtes (fonction [&lt;Source&gt;.LitPremier](../WDLang4/1000025022.md))
<a name="parcours_des_requetes_fonction_litpremierwdlang41000025022md_ELTPARAGRAPHE001478"></a>

- Par défaut, la fonction [&lt;Source&gt;.LitPremier](../WDLang4/1000025022.md) ré-exécute la requête pour rafraîchir le résultat de la requête. Il est conseillé d'utiliser la constante *hSansRafraichir*pour éviter la ré-exécution de la requête. 

- **Parcours d'une requête exécutée avec l'option hRequêteSansCorrection** :
	Pour parcourir les enregistrements dans l'ordre renvoyé par la base de données, il n'est pas nécessaire de préciser de rubrique de parcours. Exemple :
	
	```wl
	MaRequête.LitPremier(hSansRafraîchir)
	```

	Si une rubrique de parcours est spécifiée, le résultat de la requête est intégralement récupéré et indexé. Le parcours est alors réalisé sur la rubrique spécifiée. Le tri initial de la requête (spécifié par ORDER BY) est ignoré. L'index créé (au format HFSQL) est sensible à la casse, sensible à la ponctuation, sensible aux accents et ascendant.
	Exemple :
	
	```wl
	MaRequête.LitPremier("MaRubrique", hSansRafraîchir)
	```

	Les recherches utilisent l'index créé sur le résultat de la requête.




<a name="XComposante"></a>

## Composante :
wd280hf.dll
