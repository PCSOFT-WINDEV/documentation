
## &lt;Source&gt;.ExécuteRequête (Fonction)

***En anglais : &lt;Source&gt;.ExecuteQuery***

<a name="XUtilisation"></a>
<a name="Utilisation"></a>
<a name="description"></a>
Déclare une requête au moteur HFSQL et exécute cette requête. Cette requête peut correspondre à : 

- une requête créée sous l'éditeur de requêtes. 

- une variable de type Requête SQL. 


Le résultat de la requête pourra ensuite être parcouru. Si une requête de même nom existe déjà, cette requête est remplacée. Le résultat est recalculé.

**Attention** : Pour se positionner sur le premier enregistrement du résultat de la requête, utilisez par exemple la fonction [&lt;Source&gt;.LitPremier](../WDLang4/1000025022.md).

Pour libérer les ressources d'une requête créée sous l'éditeur de requêtes, utilisez : 

- la fonction [&lt;Source&gt;.AnnuleDéclaration](../WDLang4/1000024192.md).

- la fonction [&lt;Source&gt;.LibèreRequête](../WDLang4/1000025011.md).




**Remarque** : Une requête ne pourra pas être initialisée si :

- le nom de la requête est déjà utilisé dans l'analyse en cours (nom de fichier de données ou nom défini par une des fonctions suivantes : [&lt;Source&gt;.Déclare](../WDLang4/1000024213.md), [&lt;Source&gt;.DéclareExterne](../WDLang4/1000024214.md), [&lt;Source&gt;.DécritFichier](../WDLang4/1000024215.md)).

- une erreur de syntaxe est trouvée dans la requête.


![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Il n'est pas possible d'exécuter des requêtes dont le code SQL contient des fonctions WLangage. 
<a name="Exemple1"></a>
<a name="sample_code"></a>

## Exemple


```wl
// Initialisation de la requête "REQ_Client_84"
REQ_Client_84.ExécuteRequête()
```
<a name="3044080_Exemple2"></a>

```wl
// Requête sur fichier Oracle : Clients utilise la connexion "MaConnexion"
// REQ_Marequête = "Select * from clients where IDClient = ?"
REQ_MaRequête.ExécuteRequête(hRequêteDéfaut, 5)
```

<a name="XSYNTAXE"></a>
<a name="SYNTAXE1"></a>

## Syntaxe

### Exécuter une requête (sans connexion)

`<Résultat> = <Source>.ExécuteRequête([<Mode> [, <Paramètre 1> [, <Paramètre N>]]])`
---

**`<Résultat> : (booléen)`**



- <u><u><u><u>Vrai</u></u></u></u> si l'initialisation de la requête a été effectuée, 

- <u><u><u><u>Faux</u></u></u></u> dans le cas contraire. La fonction [HErreurInfo](../WDLang4/3044071.md) permet d'obtenir plus d'informations sur le problème rencontré.




**`<Source> : (Type correspondant à la source)`**

Nom de la requête à exécuter : 

- Nom logique de la requête à initialiser.
	Si une requête de même nom est déjà déclarée, elle est remplacée par la nouvelle requête.

- Nom d'une variable de type [Requête SQL](../Motscles/1514082.md). 
	




**`<Mode> : (Constante optionnelle de type Entier)`**

Option pour l'initialisation de la requête :


|   |   |
| --- | --- |
| *hAvecFiltre*<br>(option combinable avec les autres constantes) | **Si ce paramètre est spécifié** :<br><br>- le résultat de la requête correspond à une sélection d'enregistrements de type filtre si le moteur HFSQL le permet. Sinon, le résultat de la requête est une vue HFSQL<br><br>- les opérations suivantes ne sont pas possibles : recherche sur le résultat de la requête, requête sur requête, vue sur requête, requête sur vue.<br><br>- les rubriques de parcours spécifiées lors du parcours du résultat ne sont pas prises en compte.<br><br>- la loupe n'est pas disponible sur les tables liées à une requête.<br><br>- la fonction [&lt;Source&gt;.NbEnr](../WDLang4/1000025040.md) ne peut pas être utilisée sur les requêtes. <br>	Attention : si cette option est précisée, la constante *hModifieFichier* est automatiquement utilisée.<br><br><br>**Si ce paramètre n'est pas spécifié (par défaut)** :<br><br>- le résultat de la requête correspond à une vue HFSQL<br><br>- il est possible de réaliser les opérations suivantes sur les requêtes : recherche sur le résultat de la requête, requête sur requête, vue sur requête, requête sur vue.<br><br>- les rubriques de parcours spécifiées lors du parcours du résultat sont prises en compte.<br><br>- la loupe est disponible sur les tables liées à une requête.<br><br>- la fonction [&lt;Source&gt;.NbEnr](../WDLang4/1000025040.md) peut être utilisée sur les requêtes.<br><br><br><br><br>![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Accès par JDBC : Cette constante n'est pas disponible. |
| *hAvecTransaction* | La requête est exécutée dans une transaction.<br>Une transaction est démarrée, les enregistrements sont bloqués en écriture pendant l'exécution de la requête, et débloqués à la fin de son exécution, que la requête échoue ou non.<br>Si la requête ne peut pas se terminer normalement (blocage d'enregistrements, coupure de courant, ...), la transaction est annulée et les fichiers de données sont remis dans l'état avant l'exécution de la requête.<br>Remarque : L'exécution de la requête pourra être fortement ralentie.<br>![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Cette constante n'est pas disponible. |
| *hModifieFichier*<br>(option combinable avec les autres constantes) | **Sur des fichiers de données HFSQL** : Lors de la modification du résultat de la requête (fonctions [&lt;Source&gt;.Ajoute](../WDLang4/1000024187.md), [&lt;Source&gt;.Ecrit](../WDLang4/1000024331.md), [&lt;Source&gt;.Modifie](../WDLang4/1000025038.md), [&lt;Source&gt;.Raye](../WDLang4/1000025051.md), [&lt;Source&gt;.Supprime](../WDLang4/1000025071.md)), ces modifications seront reportées dans les fichiers de données intervenant dans la requête.<br>Si cette option n'est pas précisée, seul le résultat de la requête est modifié. <br>Pour plus de détails sur la modification du résultat d'une requête, consultez [Modifier le contenu d'une requête](../WDLang4/3044234.md).<br>**Sur des fichiers de données non HFSQL**, la constante *hModifieFichier* est inutile : les fichiers de données intervenant dans la requête sont automatiquement modifiés lors de la modification du résultat de la requête.<br>![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Accès par JDBC : Cette constante n'est pas disponible. |
| *hRequêteDéfaut*<br>(valeur par défaut) | Initialisation de la requête sans interruption. |
| *hRequêteInterruptible* | L'initialisation de la requête peut être interrompue avec la touche ECHAP.<br>![Universal Windows 10 App](https://doc.pcsoft.fr/ext/images/fr/UNIVERSALAPP.png) Cette constante n'est pas disponible.![Procédures stockées](https://doc.pcsoft.fr/ext/images/fr/PS.png) Cette constante est ignorée.![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Accès par JDBC : Cette constante n'est pas disponible.![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png) La touche Echap doit être utilisée sur le poste client. |
| *hRequêteSansCorrection* | ![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png)![OLE DB](https://doc.pcsoft.fr/ext/images/fr/OLEDB.png)![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) Le moteur HFSQL n'effectue aucune vérification de la requête. Cette option doit être utilisée si la requête comporte des ordres spécifiques à un type de connexion (Oracle, SQL Server, ...).<br><br>Attention : si cette constante est utilisée :<br><br>- il est nécessaire de préciser le nom de la connexion (paramètre &lt;Connexion&gt;).<br><br>- la fonction [&lt;Source&gt;.Filtre](../WDLang4/1000024960.md) ne peut pas être utilisée sur la requête manipulée.<br><br>- il n'est pas possible d'annuler une condition en l'affectant à NULL. <br><br>- il est conseillé de ne pas spécifier de rubrique de parcours dans les fonctions suivantes : [&lt;Source&gt;.Dernier](../WDLang4/1000024217.md), [&lt;Source&gt;.LitDernier](../WDLang4/1000025020.md), [&lt;Source&gt;.LitPremier](../WDLang4/1000025022.md), [&lt;Source&gt;.Premier](../WDLang4/1000025048.md), [&lt;Source&gt;.RechercheDernier](../WDLang4/1000025054.md), [&lt;Source&gt;.RecherchePremier](../WDLang4/1000025055.md).<br><br><br> |
| *hRequêteSansCorrectionHF* | ![HFSQL Classic](https://doc.pcsoft.fr/ext/images/fr/HF.png) Le moteur HFSQL n'effectue aucune vérification du format de fichier de données (complété par des espaces ou non). <br>A utiliser si la requête manipule à la fois des fichiers de données HFSQL au format complété par des espaces et des fichiers de données HFSQL au format non complété par des espaces. |
| *hSansSablier* | Lors de la lecture du résultat de la requête, cette lecture peut être bloquée et un sablier apparaît par défaut. Cette constante permet de ne pas afficher de sablier dans ce cas. <br><br> |
| *hTemporise* | Pour les requêtes UPDATE et DELETE s'appliquant sur beaucoup d'enregistrements et étant relativement longues, cette constante permet de laisser la main aux autres applications utilisant les fichiers de données.<br>Dans ce cas :<br><br>- la requête s'exécute un peu plus lentement,<br><br>- le serveur de fichiers n'est pas saturé,<br><br>- les autres utilisateurs des fichiers de données peuvent continuer à y accéder sans rencontrer de blocage.<br><br><br>![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png)![OLE DB](https://doc.pcsoft.fr/ext/images/fr/OLEDB.png)![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) Cette constante est ignorée.![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Accès par JDBC : Cette constante n'est pas disponible. |
| *hVérifieDoublon* | Active la gestion des doublons pendant l'exécution de la requête. Si une erreur de doublons est détectée, la requête n'est pas exécutée.<br>Cette constante force la constante *hAvecTransaction*. Une transaction est démarrée, les enregistrements sont bloqués en écriture pendant l'exécution de la requête et débloqués à la fin de son exécution, que la requête échoue ou non. Si l'application est arrêtée pendant l'exécution de la requête (coupure de courant par exemple), la transaction sera annulée à la prochaine utilisation des fichiers de données de la requête.<br>Remarque : L'exécution de la requête pourra être fortement ralentie.<br>![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png) <br><br>- Si la constante *hVérifieDoublon* n'est pas spécifiée, la gestion des doublons est débranchée. <br><br>- Si l'utilisateur n'a pas les droits pour brancher/débrancher la gestion des doublons (fonction [&lt;Variable Connexion&gt;.ModifieDroitBaseDeDonnées](../WDLang4/1000022707.md)) et si une gestion des doublons doit être réalisée, une erreur de droit est affichée.<br><br><br>![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Accès par JDBC : Cette constante n'est pas disponible. |
| *hVérifieIntégrité* | Active la gestion de l'intégrité pendant l'exécution de la requête. Si une erreur d'intégrité est détectée, la requête n'est pas exécutée.<br>Cette constante force la constante *hAvecTransaction*. Une transaction est démarrée, les enregistrements sont bloqués en écriture pendant l'exécution de la requête et débloqués à la fin de son exécution, que la requête échoue ou non. Si l'application est arrêtée pendant l'exécution de la requête (coupure de courant par exemple), la transaction sera annulée à la prochaine utilisation des fichiers de données de la requête.<br>Remarque : L'exécution de la requête pourra être fortement ralentie.<br>![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png) <br><br>- Si la constante *hVérifieIntégrité* n'est pas spécifiée, la gestion de l'intégrité est débranchée. <br><br>- Si l'utilisateur n'a pas les droits pour brancher/débrancher la gestion de l'intégrité (fonction [&lt;Variable Connexion&gt;.ModifieDroitBaseDeDonnées](../WDLang4/1000022707.md)) et si une gestion de l'intégrité doit être réalisée, une erreur de droit est affichée.<br><br><br>![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Accès par JDBC : Cette constante n'est pas disponible. |

![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Android et Java (accès par JDBC) : Ce paramètre peut correspondre uniquement aux constantes *hRequêteDéfaut* ou *hRequêteSansCorrection*. Si une autre constante est utilisée, elle sera ignorée. 

**`<Paramètre 1> : (Type du paramètre)`**

Valeurs des paramètres de la requête dans leur ordre d'initialisation (visible sous l'éditeur de requêtes). Chaque paramètre doit correspondre au type attendu. Les différents paramètres sont séparés par une virgule. 
Remarques :

- Le passage de paramètres dans la fonction &lt;Source&gt;.ExécuteRequête est conservé par compatibilité. Il est conseillé d'utiliser le passage de paramètres avec la notation &lt;Nom de la requête&gt;.&lt;Nom du paramètre&gt; = &lt;Valeur&gt;. 

- Pour spécifier les paramètres de la requête, il est nécessaire de spécifier le paramètre &lt;Mode&gt;.

- Il est possible de spécifier ou non la valeur de chaque paramètre. 

- Il est possible de spécifier une liste de valeurs ou une liste de paramètres. 


Pour plus de détails, consultez le paragraphe Passages de paramètres.
Ce paramètre n'est pas disponible si &lt;Nom de la requête&gt; correspond à une variable de type Requête SQL.

**`<Paramètre N> : (Type du paramètre)`**

Valeurs des paramètres de la requête dans leur ordre d'initialisation (visible sous l'éditeur de requêtes). Chaque paramètre doit correspondre au type attendu. Les différents paramètres sont séparés par une virgule. 
Remarques :

- Le passage de paramètres dans la fonction &lt;Source&gt;.ExécuteRequête est conservé par compatibilité. Il est conseillé d'utiliser le passage de paramètres avec la notation &lt;Nom de la requête&gt;.&lt;Nom du paramètre&gt; = &lt;Valeur&gt;. 

- Pour spécifier les paramètres de la requête, il est nécessaire de spécifier le paramètre &lt;Mode&gt;.

- Il est possible de spécifier ou non la valeur de chaque paramètre. 

- Il est possible de spécifier une liste de valeurs ou une liste de paramètres. 


Pour plus de détails, consultez le paragraphe Passages de paramètres.
Ce paramètre n'est pas disponible si &lt;Nom de la requête&gt; correspond à une variable de type Requête SQL.


<a name="SYNTAXE2"></a>
![Procédures stockées](https://doc.pcsoft.fr/ext/images/fr/PS.png) Cette syntaxe n'est pas disponible dans une procédure stockée
### Exécuter une requête via une connexion

`<Résultat> = <Source>.ExécuteRequête([<Connexion> [, <Mode> [, <Paramètre 1> [, <Paramètre N>]]]])`
---

**`<Résultat> : (booléen)`**



- <u><u><u><u>Vrai</u></u></u></u> si l'initialisation de la requête a été effectuée, 

- <u><u><u><u>Faux</u></u></u></u> dans le cas contraire. La fonction [HErreurInfo](../WDLang4/3044071.md) permet d'obtenir plus d'informations sur le problème rencontré.




**`<Source> : (Type correspondant à la source)`**

Nom de la requête à exécuter : 

- Nom logique de la requête à initialiser.
	Si une requête de même nom est déjà déclarée, elle est remplacée par la nouvelle requête.

- Nom d'une variable de type [Requête SQL](../Motscles/1514082.md). 
	




**`<Connexion> : (Chaîne de caractères optionnelle)`**

Nom d'une connexion, définie sous l'éditeur d'analyses ou dynamiquement avec la fonction [HDécritConnexion](../WDLang4/3044205.md). La requête sera exécutée via cette connexion.
![OLE DB](https://doc.pcsoft.fr/ext/images/fr/OLEDB.png)![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) Si ce paramètre n'est pas précisé et si la requête concerne des fichiers de données accédés par OLE DB ou par un accès natif, la requête est exécutée via la connexion utilisée par le premier fichier de données rencontré dans la requête. Si la connexion utilisée par un fichier de données est modifiée avant l'utilisation de la fonction **&lt;Source&gt;.ExécuteRequête**, la nouvelle connexion sera utilisée.

**`<Mode> : (Constante optionnelle de type Entier)`**

Option pour l'initialisation de la requête :


|   |   |
| --- | --- |
| *hAvecFiltre*<br>(option combinable avec les autres constantes) | **Si ce paramètre est spécifié** :<br><br>- le résultat de la requête correspond à une sélection d'enregistrements de type filtre si le moteur HFSQL le permet. Sinon, le résultat de la requête est une vue HFSQL<br><br>- les opérations suivantes ne sont pas possibles : recherche sur le résultat de la requête, requête sur requête, vue sur requête, requête sur vue.<br><br>- les rubriques de parcours spécifiées lors du parcours du résultat ne sont pas prises en compte.<br><br>- la loupe n'est pas disponible sur les tables liées à une requête.<br><br>- la fonction [&lt;Source&gt;.NbEnr](../WDLang4/1000025040.md) ne peut pas être utilisée sur les requêtes. <br>	Attention : si cette option est précisée, la constante *hModifieFichier* est automatiquement utilisée.<br><br><br>**Si ce paramètre n'est pas spécifié (par défaut)** :<br><br>- le résultat de la requête correspond à une vue HFSQL<br><br>- il est possible de réaliser les opérations suivantes sur les requêtes : recherche sur le résultat de la requête, requête sur requête, vue sur requête, requête sur vue.<br><br>- les rubriques de parcours spécifiées lors du parcours du résultat sont prises en compte.<br><br>- la loupe est disponible sur les tables liées à une requête.<br><br>- la fonction [&lt;Source&gt;.NbEnr](../WDLang4/1000025040.md) peut être utilisée sur les requêtes.<br><br><br><br><br>![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Accès par JDBC : Cette constante n'est pas disponible. |
| *hAvecTransaction* | La requête est exécutée dans une transaction.<br>Une transaction est démarrée, les enregistrements sont bloqués en écriture pendant l'exécution de la requête, et débloqués à la fin de son exécution, que la requête échoue ou non.<br>Si la requête ne peut pas se terminer normalement (blocage d'enregistrements, coupure de courant, ...), la transaction est annulée et les fichiers de données sont remis dans l'état avant l'exécution de la requête.<br>Remarque : L'exécution de la requête pourra être fortement ralentie.<br>![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Cette constante n'est pas disponible. |
| *hModifieFichier*<br>(option combinable avec les autres constantes) | **Sur des fichiers de données HFSQL** : Lors de la modification du résultat de la requête (fonctions [&lt;Source&gt;.Ajoute](../WDLang4/1000024187.md), [&lt;Source&gt;.Ecrit](../WDLang4/1000024331.md), [&lt;Source&gt;.Modifie](../WDLang4/1000025038.md), [&lt;Source&gt;.Raye](../WDLang4/1000025051.md), [&lt;Source&gt;.Supprime](../WDLang4/1000025071.md)), ces modifications seront reportées dans les fichiers de données intervenant dans la requête.<br>Si cette option n'est pas précisée, seul le résultat de la requête est modifié. <br>Pour plus de détails sur la modification du résultat d'une requête, consultez [Modifier le contenu d'une requête](../WDLang4/3044234.md).<br>**Sur des fichiers de données non HFSQL**, la constante *hModifieFichier* est inutile : les fichiers de données intervenant dans la requête sont automatiquement modifiés lors de la modification du résultat de la requête.<br>![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Accès par JDBC : Cette constante n'est pas disponible. |
| *hRequêteDéfaut*<br>(valeur par défaut) | Initialisation de la requête sans interruption. |
| *hRequêteInterruptible* | L'initialisation de la requête peut être interrompue avec la touche ECHAP.<br>![Universal Windows 10 App](https://doc.pcsoft.fr/ext/images/fr/UNIVERSALAPP.png) Cette constante n'est pas disponible.![Procédures stockées](https://doc.pcsoft.fr/ext/images/fr/PS.png) Cette constante est ignorée.![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Accès par JDBC : Cette constante n'est pas disponible.![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png) La touche Echap doit être utilisée sur le poste client. |
| *hRequêteSansCorrection* | ![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png)![OLE DB](https://doc.pcsoft.fr/ext/images/fr/OLEDB.png)![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) Le moteur HFSQL n'effectue aucune vérification de la requête. Cette option doit être utilisée si la requête comporte des ordres spécifiques à un type de connexion (Oracle, SQL Server, ...).<br><br>Attention : si cette constante est utilisée :<br><br>- il est nécessaire de préciser le nom de la connexion (paramètre &lt;Connexion&gt;).<br><br>- la fonction [&lt;Source&gt;.Filtre](../WDLang4/1000024960.md) ne peut pas être utilisée sur la requête manipulée.<br><br>- il n'est pas possible d'annuler une condition en l'affectant à NULL. <br><br>- il est conseillé de ne pas spécifier de rubrique de parcours dans les fonctions suivantes : [&lt;Source&gt;.Dernier](../WDLang4/1000024217.md), [&lt;Source&gt;.LitDernier](../WDLang4/1000025020.md), [&lt;Source&gt;.LitPremier](../WDLang4/1000025022.md), [&lt;Source&gt;.Premier](../WDLang4/1000025048.md), [&lt;Source&gt;.RechercheDernier](../WDLang4/1000025054.md), [&lt;Source&gt;.RecherchePremier](../WDLang4/1000025055.md).<br><br><br> |
| *hRequêteSansCorrectionHF* | ![HFSQL Classic](https://doc.pcsoft.fr/ext/images/fr/HF.png) Le moteur HFSQL n'effectue aucune vérification du format de fichier de données (complété par des espaces ou non). <br>A utiliser si la requête manipule à la fois des fichiers de données HFSQL au format complété par des espaces et des fichiers de données HFSQL au format non complété par des espaces. |
| *hSansSablier* | Lors de la lecture du résultat de la requête, cette lecture peut être bloquée et un sablier apparaît par défaut. Cette constante permet de ne pas afficher de sablier dans ce cas. <br><br> |
| *hTemporise* | Pour les requêtes UPDATE et DELETE s'appliquant sur beaucoup d'enregistrements et étant relativement longues, cette constante permet de laisser la main aux autres applications utilisant les fichiers de données.<br>Dans ce cas :<br><br>- la requête s'exécute un peu plus lentement,<br><br>- le serveur de fichiers n'est pas saturé,<br><br>- les autres utilisateurs des fichiers de données peuvent continuer à y accéder sans rencontrer de blocage.<br><br><br>![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png)![OLE DB](https://doc.pcsoft.fr/ext/images/fr/OLEDB.png)![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) Cette constante est ignorée.![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Accès par JDBC : Cette constante n'est pas disponible. |
| *hVérifieDoublon* | Active la gestion des doublons pendant l'exécution de la requête. Si une erreur de doublons est détectée, la requête n'est pas exécutée.<br>Cette constante force la constante *hAvecTransaction*. Une transaction est démarrée, les enregistrements sont bloqués en écriture pendant l'exécution de la requête et débloqués à la fin de son exécution, que la requête échoue ou non. Si l'application est arrêtée pendant l'exécution de la requête (coupure de courant par exemple), la transaction sera annulée à la prochaine utilisation des fichiers de données de la requête.<br>Remarque : L'exécution de la requête pourra être fortement ralentie.<br>![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png) <br><br>- Si la constante *hVérifieDoublon* n'est pas spécifiée, la gestion des doublons est débranchée. <br><br>- Si l'utilisateur n'a pas les droits pour brancher/débrancher la gestion des doublons (fonction [&lt;Variable Connexion&gt;.ModifieDroitBaseDeDonnées](../WDLang4/1000022707.md)) et si une gestion des doublons doit être réalisée, une erreur de droit est affichée.<br><br><br>![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Accès par JDBC : Cette constante n'est pas disponible. |
| *hVérifieIntégrité* | Active la gestion de l'intégrité pendant l'exécution de la requête. Si une erreur d'intégrité est détectée, la requête n'est pas exécutée.<br>Cette constante force la constante *hAvecTransaction*. Une transaction est démarrée, les enregistrements sont bloqués en écriture pendant l'exécution de la requête et débloqués à la fin de son exécution, que la requête échoue ou non. Si l'application est arrêtée pendant l'exécution de la requête (coupure de courant par exemple), la transaction sera annulée à la prochaine utilisation des fichiers de données de la requête.<br>Remarque : L'exécution de la requête pourra être fortement ralentie.<br>![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png) <br><br>- Si la constante *hVérifieIntégrité* n'est pas spécifiée, la gestion de l'intégrité est débranchée. <br><br>- Si l'utilisateur n'a pas les droits pour brancher/débrancher la gestion de l'intégrité (fonction [&lt;Variable Connexion&gt;.ModifieDroitBaseDeDonnées](../WDLang4/1000022707.md)) et si une gestion de l'intégrité doit être réalisée, une erreur de droit est affichée.<br><br><br>![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Accès par JDBC : Cette constante n'est pas disponible. |

![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Android et Java (accès par JDBC) : Ce paramètre peut correspondre uniquement aux constantes *hRequêteDéfaut* ou *hRequêteSansCorrection*. Si une autre constante est utilisée, elle sera ignorée. 

**`<Paramètre 1> : (Type du paramètre)`**

Valeurs des paramètres de la requête dans leur ordre d'initialisation (visible sous l'éditeur de requêtes). Chaque paramètre doit correspondre au type attendu. Les différents paramètres sont séparés par une virgule. 
Remarques :

- Le passage de paramètres dans la fonction &lt;Source&gt;.ExécuteRequête est conservé par compatibilité. Il est conseillé d'utiliser le passage de paramètres avec la notation &lt;Nom de la requête&gt;.&lt;Nom du paramètre&gt; = &lt;Valeur&gt;. 

- Pour spécifier les paramètres de la requête, il est nécessaire de spécifier le paramètre &lt;Mode&gt;.

- Il est possible de spécifier ou non la valeur de chaque paramètre. 

- Il est possible de spécifier une liste de valeurs ou une liste de paramètres. 


Pour plus de détails, consultez le paragraphe Passages de paramètres.
Ce paramètre n'est pas disponible si &lt;Nom de la requête&gt; correspond à une variable de type Requête SQL.

**`<Paramètre N> : (Type du paramètre)`**

Valeurs des paramètres de la requête dans leur ordre d'initialisation (visible sous l'éditeur de requêtes). Chaque paramètre doit correspondre au type attendu. Les différents paramètres sont séparés par une virgule. 
Remarques :

- Le passage de paramètres dans la fonction &lt;Source&gt;.ExécuteRequête est conservé par compatibilité. Il est conseillé d'utiliser le passage de paramètres avec la notation &lt;Nom de la requête&gt;.&lt;Nom du paramètre&gt; = &lt;Valeur&gt;. 

- Pour spécifier les paramètres de la requête, il est nécessaire de spécifier le paramètre &lt;Mode&gt;.

- Il est possible de spécifier ou non la valeur de chaque paramètre. 

- Il est possible de spécifier une liste de valeurs ou une liste de paramètres. 


Pour plus de détails, consultez le paragraphe Passages de paramètres.
Ce paramètre n'est pas disponible si &lt;Nom de la requête&gt; correspond à une variable de type Requête SQL.



<a name="NOTE0"></a>
<a name="NOTE0_1"></a>

## Remarques


### Lecture des données lors de l'initialisation de la requête
<a name="lecture_des_donnees_lors_initialisation_requete_ELTPARAGRAPHE001095"></a>Selon la requête (tris, groupes, etc.), les données peuvent ou non être lues au moment de l'initialisation de la requête.

Remarque : La propriété [ExécutionTerminée](../Proprietes/2512117.md) permet de savoir si le remplissage de la requête est terminé (et donc si les lectures peuvent être effectuées sans blocage).
<a name="NOTE0_2"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png)![Universal Windows 10 App](https://doc.pcsoft.fr/ext/images/fr/UNIVERSALAPP.png)![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png)![Code Utilisateur (MCU)](https://doc.pcsoft.fr/ext/images/fr/MCU.png)![HFSQL Classic](https://doc.pcsoft.fr/ext/images/fr/HF.png)![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png)![Hyper File 5.5](https://doc.pcsoft.fr/ext/images/fr/HF55.png)![OLE DB](https://doc.pcsoft.fr/ext/images/fr/OLEDB.png)![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) 

### Ajout d'enregistrements et utilisation de la constante hModifieFichier
<a name="ajout_enregistrements_utilisation_constante_hmodifiefichier_ELTPARAGRAPHE001112"></a>

![HFSQL Classic](https://doc.pcsoft.fr/ext/images/fr/HF.png) Lors de l'ajout d'enregistrements dans un fichier de données via une requête, la requête prend en compte les enregistrements ajoutés dans le fichier de données quelle que soit la condition définie dans la requête. Le nombre d'enregistrement de cette requête est systématiquement modifié.![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) Lors de l'ajout d'enregistrements dans un fichier de données via une requête, la requête prend en compte la condition définie dans la requête. Le nombre d'enregistrements de cette requête est modifié uniquement si les enregistrements ajoutés dans le fichier de données correspondent à cette condition.
<a name="NOTE0_3"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png)![Code Utilisateur (MCU)](https://doc.pcsoft.fr/ext/images/fr/MCU.png)![OLE DB](https://doc.pcsoft.fr/ext/images/fr/OLEDB.png)![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) 

### Pourquoi utiliser la constante hRequêteSansCorrection
<a name="pourquoi_utiliser_constante_hrequetesanscorrection_ELTPARAGRAPHE001129"></a>Par défaut, WINDEV et WEBDEV interprètent les requêtes SQL sur OLE DB et sur ODBC via le provider OLE DB. Pour que la requête ne soit pas interprétée, utilisez la constante *hRequêteSansCorrection*.

La constante *hRequêteSansCorrection* peut par exemple être utilisée si vous saisissez directement le code SQL de votre requête sous l'éditeur de requêtes.

| hRequêteSansCorrection n'est pas spécifié | hRequêteSansCorrection est spécifié |
| --- | --- |
| Détermination automatique de la connexion associée aux fichiers de données présents dans la requête. | La connexion à utiliser doit être précisée dans la fonction **HExécuteRequêteSQL**. |
| Remplacement de tous les signes propriétaires PC SOFT (exemple : ']=' commence par) par leur équivalent en SQL standard. | Aucun remplacement n'est effectué. Il est nécessaire d'utiliser les signes SQL standard. |
| Formatage des dates et des heures selon le format utilisé par la base de données.<br>Par exemple, sous WINDEV et WEBDEV, les dates sont au format 'AAAAMMJJ' alors que sous Access, les dates sont au format #AAAAJJMM# ou #AAAAMMJJ# selon la langue du système. | Aucun formatage n'est effectué. Il est nécessaire d'utiliser le format reconnu par la base de données. |
| Formatage des flottants (le séparateur de décimal peut être '.' ou ',') | Aucun formatage des flottants n'est réalisé. |
| Selon la base de données utilisée, remplacement des noms d'alias par les noms complets des rubriques dans les clauses Where, Order by et Group by<br>Par exemple, le moteur JET (Access, DBase, ...) n'accepte pas de noms d'alias dans la clause Where d'une requête | Aucun remplacement n'est effectué. Il est nécessaire d'utiliser directement dans le code de la requête les noms complets des rubriques dans les clauses Where, Order by et Group by. |


<a name="NOTE0_4"></a>


### Passage de paramètres à la requête
<a name="passage_parametres_requete_ELTPARAGRAPHE001173"></a>Plusieurs méthodes peuvent être utilisées pour passer des paramètres à une requête : 

1. Passage des paramètres avec la notation &lt;Nom de la requête&gt;.&lt;Nom du paramètre&gt; = &lt;Valeur&gt; (conseillée)

2. Passage des paramètres directement dans la fonction **HExécuteRequête** (conservée par compatibilité, compatible PHP).




Pour plus de détails sur les différentes façons de passer des paramètres à une requête, leurs avantages et leurs inconvénients, consultez [Méthodes à utiliser pour passer des paramètres à une requête](../Editeurs/2032050.md).

Détaillons ces deux méthodes : 

1. **Passage des paramètres avec la notation &lt;Nom de la requête&gt;.&lt;Nom du paramètre&gt; = &lt;Valeur&gt; (conseillée)**
	Pour passer des paramètres à une requête paramétrée avant de l'exécuter, il est également possible d'utiliser la syntaxe suivante :
	
	```txt
	<Nom de la requête>.<Nom du paramètre 1> = xxx
	<Nom de la requête>.<Nom du paramètre 2> = xxx
	<Nom de la requête>.<Nom du paramètre 3> = xxx
	<Nom de la requête>.ExécuteRequête()
	SI ErreurDétectée = Vrai ALORS ...
	```

	**Remarques** :

	- Cette syntaxe simplifie le passage des paramètres. En effet, si les paramètres sont passés directement dans la fonction **&lt;Source&gt;.ExécuteRequête**, il est nécessaire de respecter l'ordre des paramètres.

	- A chaque exécution de la requête paramétrée, la structure des paramètres de la requête est ré-initialisée.




2. **Passage des paramètres directement dans la fonction HExécuteRequête (conservée par compatibilité)**
	Dans ce cas, il est nécessaire de spécifier les valeurs des paramètres de la requête dans leur ordre d'initialisation (visible sous l'éditeur de requêtes). Chaque paramètre doit correspondre au type attendu. Les différents paramètres sont séparés par une virgule. Il est possible de spécifier ou non la valeur de chaque paramètre. 
	Un paramètre peut être ignoré en utilisant la valeur **Null**. Dans ce cas, les conditions de sélection utilisant ce paramètre ne seront pas prises en compte.
	
	**Il est possible de spécifier une liste de valeurs ou une liste de paramètres.**
	Si la condition de sélection pour un des paramètres de la requête est "est dans la liste" ou "n'est pas dans la liste", il faut spécifier une liste de valeurs ou de paramètres.
	Pour spécifier une liste de valeurs ou une liste de paramètres, séparez les différentes valeurs ou paramètres par un point-virgule (';'), un retour-chariot ('RC') ou une tabulation ('TAB').
	Par exemple : 
	
	```wl
	NomRequête.ExécuteRequête(hRequêteDéfaut, "34000;34200;34400")
	```
ou
	```wl
	NomRequête.ExécuteRequête(hRequêteDéfaut, "34000 "+ RC + "34200" + RC + "34400")
	```
ou
	```wl
	NomRequête.ExécuteRequête(hRequêteDéfaut, "34000" + TAB + "34200" + TAB + "34400")
	```

	**Remarque** : Si une des valeurs ou des paramètres contient un point-virgule, un retour-chariot ou une tabulation, il est nécessaire d'entourer cette valeur ou ce paramètre avec des quotes. Par exemple :
	
	```wl
	NomRequête.ExécuteRequête(hRequêteDéfaut, "'A;A';'A;B';'A;C'")
	```

	Remarque : Tous les paramètres de la requête ne doivent pas obligatoirement être précisés. Les conditions de la requête utilisant des paramètres non précisés seront ignorées. 
	**Exemple** : Soit la requête "Clients_nom_prénom" dont le code SQL est le suivant :
	
	```sql
	SELECT * FROM CLIENT WHERE NOM = {Param1} AND PRENOM = {Param2}
	```


	- Les 2 paramètres sont donnés :
			
		```wl
		REQ_Clients_nom_prénom.ExécuteRequête(hRequêteDéfaut, "Dupond", "Jean")
		```
exécutera la requête
		```sql
		SELECT * FROM CLIENT WHERE NOM = 'Dupond' AND PRENOM = 'Jean'
		```


	- Seul le nom est donné : 
			
		```wl
		REQ_Clients_nom_prénom.ExécuteRequête(hRequêteDéfaut, "Dupond")
		```
exécutera la requête
		```sql
		SELECT * FROM CLIENT WHERE NOM = 'Dupond'
		```


	- Seul le prénom est donné : 
			
		```wl
		sNom est un Variant = Null 
		// Utilisation du variant obligatoire pour variable de type Null (non renseignée)
		
		REQ_Clients_nom_prénom.ExécuteRequête(hRequêteDéfaut, sNom, "Jean")
		
		ou
		
		REQ_Clients_nom_prénom.ExécuteRequête(hRequêteDéfaut, Null, "Jean")
		```
exécutera la requête
		```sql
		SELECT * FROM CLIENT WHERE PRENOM = 'Jean'
		```







<a name="NOTE0_7"></a>
![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) 

### Fonction **&lt;Source&gt;.ExécuteRequête** et accès par JDBC
<a name="fonction_docparampagetitleshort_acces_par_jdbc_ELTPARAGRAPHE001292"></a>Si le nom physique d'un fichier de données manipulé dans la requête est différent de son nom logique, dans le code SQL, le nom des rubriques doit être préfixé par le nom physique du fichier de données et non par le nom logique. Il est également possible de ne pas préfixer le nom des rubriques.
<a name="NOTE0_8"></a>


### Libération des ressources de la requête
<a name="liberation_des_ressources_requete_ELTPARAGRAPHE001305"></a>Pour libérer les ressources d'une requête, utilisez : 

- la fonction [&lt;Source&gt;.AnnuleDéclaration](../WDLang4/1000024192.md).

- la fonction [&lt;Source&gt;.LibèreRequête](../WDLang4/1000025011.md).




Si cette opération n'est pas effectuée, la requête est toujours présente dans le contexte HFSQL en cours et elle est accessible depuis n'importe quel traitement.

**Remarques** : 

- Les ressources de la requête ne sont pas libérées automatiquement à la fermeture de la fenêtre qui a exécuté la requête (utilisation de la fonction **&lt;Source&gt;.ExécuteRequête**).

- Les variables de type Requête SQL sont automatiquement libérées en fin de portée de la variable. Pour plus de détails, consultez [Requêtes SQL en WLangage](../Motscles/1514082.md).



<a name="NOTE0_9"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png)![Code Utilisateur (MCU)](https://doc.pcsoft.fr/ext/images/fr/MCU.png)![HFSQL Classic](https://doc.pcsoft.fr/ext/images/fr/HF.png)![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png)![Hyper File 5.5](https://doc.pcsoft.fr/ext/images/fr/HF55.png) 

### Optimisation des requêtes sur des fichiers de données HFSQL
<a name="optimisation_des_requetes_sur_des_fichiers_donnees_hfsql_ELTPARAGRAPHE001347"></a>

- Pour optimiser le temps d'exécution de la requête, utilisez la fonction [&lt;Source&gt;.Optimise](../WDLang4/1000025042.md) sur les différents fichiers de données intervenant dans la requête ou la fonction [HOptimiseRequête](../WDLang4/3044003.md).

- Pour optimiser le temps de traitement des requêtes, utilisez la fonction [&lt;Source&gt;.StatCalcule](../WDLang4/1000025064.md) ou la fonction [&lt;Source&gt;.Réindexe](../WDLang4/1000025060.md) sur tous les fichiers de données intervenant dans la requête.



<a name="NOTE0_10"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png)![Code Utilisateur (MCU)](https://doc.pcsoft.fr/ext/images/fr/MCU.png)![HFSQL Classic](https://doc.pcsoft.fr/ext/images/fr/HF.png)![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png)![Hyper File 5.5](https://doc.pcsoft.fr/ext/images/fr/HF55.png)![OLE DB](https://doc.pcsoft.fr/ext/images/fr/OLEDB.png)![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) 

### Exécution d'une requête et champ Table basé sur cette requête
<a name="execution_une_requete_champ_table_base_sur_cette_requete_ELTPARAGRAPHE001378"></a>Pour plus de détails, consultez [Champ Table fichier et gestion des requêtes](../WDChamp/1013203.md).
<a name="NOTE0_11"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png)![Code Utilisateur (MCU)](https://doc.pcsoft.fr/ext/images/fr/MCU.png)![HFSQL Classic](https://doc.pcsoft.fr/ext/images/fr/HF.png)![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png)![Hyper File 5.5](https://doc.pcsoft.fr/ext/images/fr/HF55.png)![OLE DB](https://doc.pcsoft.fr/ext/images/fr/OLEDB.png)![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) 

### Exécution d'une requête et état basé sur cette requête
<a name="execution_une_requete_etat_base_sur_cette_requete_ELTPARAGRAPHE001393"></a>Lors de l'impression d'un état basé sur une requête, si la requête a déjà été exécutée, elle n'est pas ré-exécutée. Pour forcer la ré-exécution de la requête (ajout d'enregistrements par exemple), il suffit d'utiliser les fonctions **&lt;Source&gt;.ExécuteRequête** ou [&lt;Etat&gt;.InitRequête](../WDLang5/1000025143.md).
<a name="NOTE0_12"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png)![Universal Windows 10 App](https://doc.pcsoft.fr/ext/images/fr/UNIVERSALAPP.png)![Code Utilisateur (MCU)](https://doc.pcsoft.fr/ext/images/fr/MCU.png)![HFSQL Classic](https://doc.pcsoft.fr/ext/images/fr/HF.png)![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png)![Hyper File 5.5](https://doc.pcsoft.fr/ext/images/fr/HF55.png)![OLE DB](https://doc.pcsoft.fr/ext/images/fr/OLEDB.png)![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) 

### Requêtes SQL (fonction **&lt;Source&gt;.ExécuteRequête** ou exécution de requêtes SQL créées par l'éditeur de requêtes)
<a name="requetes_sql_fonction_docparampagetitleshort_execution_requetes_sql_creees_par_editeur_requetes_ELTPARAGRAPHE001413"></a>

- Lors de l'utilisation des instructions SQL DELETE, INSERT ou UPDATE dans des requêtes SQL, par défaut, aucun contrôle d'intégrité et aucun contrôle de doublons ne sont réalisés sur une base de données HFSQL.

	- **Pour effectuer un contrôle automatique de l'intégrité**, il suffit de préciser la constante *hVérifieIntégrité*. Cette constante permet d'activer la gestion de l'intégrité pendant l'exécution de la requête. Si une erreur d'intégrité est détectée, la requête n'est pas exécutée. En effet, une transaction est démarrée, les enregistrements sont bloqués en écriture pendant l'exécution de la requête et débloqués à la fin de son exécution, que la requête échoue ou non. Si l'application est arrêtée pendant l'exécution de la requête (coupure de courant par exemple), la transaction sera annulée à la prochaine utilisation des fichiers de données de la requête.
			![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png) Si la constante *hVérifieIntégrité* n'est pas spécifiée, la gestion de l'intégrité est débranchée. Or si l'utilisateur n'a pas les droits pour débrancher la gestion de l'intégrité (fonction [&lt;Variable Connexion&gt;.ModifieDroitBaseDeDonnées](../WDLang4/1000022707.md)) et si une gestion de l'intégrité doit être réalisée, une erreur de droit est affichée.

	- **Pour effectuer un contrôle automatique des doublons**, il suffit de préciser la constante *hVérifieDoublons*. Cette constante permet d'activer la gestion des doublons pendant l'exécution de la requête. Si une erreur de doublons est détectée, la requête n'est pas exécutée. En effet, une transaction est démarrée, les enregistrements sont bloqués en écriture pendant l'exécution de la requête et débloqués à la fin de son exécution, que la requête échoue ou non. Si l'application est arrêtée pendant l'exécution de la requête (coupure de courant par exemple), la transaction sera annulée à la prochaine utilisation des fichiers de données de la requête.
			Note : Si une erreur de doublons est détectée lors de l'exécution d'une requête de type UPDATE, la fonction **&lt;Source&gt;.ExécuteRequête** renvoie <u><u><u><u>Faux</u></u></u></u> et le traitement continue. L'erreur correspondante peut être connue grâce à la fonction [HErreurInfo](../WDLang4/3044071.md).
			**Remarque** : L'assistance automatique par défaut n'est pas appelée pour les erreurs de doublons. Une simple erreur de doublons est générée. Si une assistance a été redéfinie à l'aide de la fonction [&lt;Source&gt;.SurErreur](../WDLang4/1000025073.md), alors cette assistance personnalisée est appelée.
			![HFSQL Client/Serveur](https://doc.pcsoft.fr/ext/images/fr/HFCS.png) Si la constante *hVérifieDoublons* n'est pas spécifiée, la gestion des doublons est débranchée. Or si l'utilisateur n'a pas les droits pour débrancher la gestion des doublons (fonction [&lt;Variable Connexion&gt;.ModifieDroitBaseDeDonnées](../WDLang4/1000022707.md)) et si une gestion de doublons doit être réalisée, une erreur de droit est affichée.




- Les requêtes de type UPDATE, DELETE ou INSERT n'existent que pendant leur exécution. Il n'est pas possible d'utiliser une fonction WLangage sur ce type de requête après son exécution.

- Les requêtes de type DELETE ne gèrent pas les suppressions en cascade.

- **Lors de l'exécution d'une requête de type INSERT/UPDATE/DELETE sur des fichiers de données HFSQL**, il est possible de connaître  le nombre d'enregistrements ayant été ajoutés, modifiés ou supprimés grâce à la variable [H.NbEnregRequêteModification](../WDLang4/3087002.md).




<a name="XComposante"></a>

## Composante :
wd280hf.dll
