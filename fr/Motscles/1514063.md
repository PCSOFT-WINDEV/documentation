
## Surcharge de prototype/Multisyntaxe
			

<a name="NOTE1"></a>
<a name="NOTE1_1"></a>


## Présentation
<a name="presentation_ELTTEXTE000234"></a>
Les procédures et les méthodes de classes peuvent avoir plusieurs syntaxes.

Par exemple, une procédure peut avoir : 

- une syntaxe qui prend en paramètre une chaîne.

- une syntaxe qui prend en paramètre un entier.




Il est ainsi possible d'avoir différentes syntaxes pour une même procédure ou une même méthode avec des paramètres et du code différents. A l'exécution, le moteur détermine automatiquement la syntaxe à appeler en fonction du nombre et du type des paramètres passés.

Cette technologie est souvent présentée sous différentes appellations et englobe différents objectifs. Parmi ces appellations, on retrouve les termes suivants :

- Multisyntaxe,

- Surcharge de prototype,

- Overload,

- Dynamic dispatch,

- Polymorphisme paramétrique,

- etc.




Cette fonctionnalité est disponible pour :

- Les procédures globales.

- Les procédures locales.

- Les méthodes de classe y compris les Constructeurs.
	




Dans la suite de ce document : 

- le terme **multisyntaxe** sera utilisé.

- le mot-clé "Procédure" sera utilisé pour désigner une procédure globale, une procédure locale ou bien une méthode.










<a name="NOTE2"></a>
<a name="NOTE1_2"></a>


## Comment le faire ?
<a name="comment_faire_ELTTEXTE000258"></a>


### Ajouter des syntaxes à une procédure
<a name="ajouter_des_syntaxes_une_procedure_ELTPARAGRAPHE000084"></a>Pour ajouter une syntaxe à une procédure existante :

1. Dans l'explorateur de projet, sélectionnez la procédure.

2. Affichez le menu contextuel de la procédure et choisissez l'option "Ajouter une syntaxe". 

3. Une nouvelle syntaxe est automatiquement créée dans l'éditeur de code.  




**Remarques** : 

- La création d'une procédure de même nom propose automatiquement d'ajouter une nouvelle syntaxe à la procédure existante.

- Si une procédure a plusieurs syntaxes, le nombre de syntaxes est affiché dans l'explorateur de projet (à côté du nom de la procédure). 





### Supprimer une syntaxe de procédure
<a name="supprimer_une_syntaxe_procedure_ELTPARAGRAPHE000098"></a>Pour supprimer une syntaxe :

1. Affichez le code de la procédure dans l'éditeur de code.

2. Dans le bandeau de la syntaxe, choisissez l'option "Supprimer" du menu contextuel.

3. Vous pouvez : 

	- supprimer la syntaxe courante. 

	- supprimer toutes les syntaxes (dans ce cas, la procédure est supprimée). 













<a name="NOTE3"></a>
<a name="NOTE3_1"></a>




## Gestion du multisyntaxe en exécution
<a name="gestion_multisyntaxe_execution_ELTTEXTE000288"></a>


### Mécanisme de base : détermination dynamique de la syntaxe selon le nombre et le type des paramètres
<a name="mecanisme_base_determination_dynamique_syntaxe_selon_nombre_type_des_parametres_ELTPARAGRAPHE000117"></a>Le moteur d'exécution recherche la syntaxe : 

- dont le nombre de paramètres correspond. 

- pour laquelle le nombre de conversions est minimal.




Si deux syntaxes sont équivalentes, c'est la première dans l'ordre de l'éditeur de code qui est exécutée.

**Exemple de base :**


```wl
// Première syntaxe
PROCEDURE p(s est une chaîne)
```

```wl
// Deuxième syntaxe
PROCEDURE p(n est un entier)
```

```wl
// Troisième syntaxe
PROCEDURE p(n est un entier, s est une chaîne)
```

```wl
// Quatrième syntaxe
PROCEDURE p(s est une chaîne, n est un entier)
```

```wl
// Appels

// Appelle la première syntaxe (meilleure syntaxe correspondant)
p("A")

// Appelle la deuxième syntaxe (meilleure syntaxe correspondant)
p(1)	

// Appelle la troisième syntaxe (meilleure syntaxe correspondant)	
p(1,"A")

// Appelle la quatrième syntaxe (meilleure syntaxe correspondant)	
p("A",1)
	
// Appelle la troisième syntaxe 
// (équivalente à la quatrième, la troisième est prioritaire car décrite avant)
p(1,1)	

// Appelle la troisième syntaxe 
// (équivalente à la quatrième, la troisième est prioritaire car décrite avant)
p("A","A")
```



### Dynamic dispatch
<a name="dynamic_dispatch_ELTPARAGRAPHE000135"></a>Dans le cas d'une procédure à plusieurs syntaxes dont les paramètres attendent des instances de classe, le moteur d'exécution utilise la méthode du "Dynamic dispatch" pour déterminer la syntaxe à appeler. 

Considérons l'exemple suivant : 

- une classe "ClasseBase" 

- deux classes "ClasseDérivée1" et "ClasseDérivée2" qui héritent de "ClasseBase".





```wl
// Première syntaxe
PROCEDURE p(LOCAL p est ClasseBase)
```

```wl
// Seconde syntaxe
PROCEDURE p(LOCAL p est ClasseDérivée1)
```

```wl
// Appels
pBase est ClasseBase dynamique
pBase = allouer ClasseBase		// Initialisation 
p(pBase)				// Première syntaxe
pBase = allouer ClasseDérivée1		// Initialisation
p(pBase)				// Seconde syntaxe
pBase = allouer ClasseDérivée2		// Initialisation
p(pBase)				// Première syntaxe
```



### Méthodes virtuelles
<a name="methodes_virtuelles_ELTPARAGRAPHE000149"></a>Pour la gestion des méthodes virtuelles, plusieurs aspects peuvent être pris en compte : 

- **1er aspect** : une syntaxe de la méthode de la classe dérivée redéfinit une syntaxe de la méthode de la classe de base
	
	```wl
	ClasseBase
		PROCEDURE meth(s est une chaîne)
		PROCEDURE meth(n est un entier)
	
	ClasseDérivée
		PROCEDURE meth(n est un entier)
	
	// Appel
	oBase est ClasseBase
	// Appelle la première syntaxe dans la classe ClasseBase
	oBase.meth("A")
	// Appelle la deuxième syntaxe dans la classe ClasseBase	
	oBase.meth(1)	
	
	oDérivée est ClasseDérivée
	// Appelle la première syntaxe dans la classe ClasseBase
	oDérivée.meth("A")
	// Appelle la première syntaxe dans la classe ClasseDérivée
	oDérivée.meth(1)
	```


- **2ème aspect** : une syntaxe supplémentaire dans la méthode de la classe dérivée
	
	```wl
	ClasseBase
		PROCEDURE meth(p)
		PROCEDURE meth(s est une chaîne)
	
	ClasseDérivée
		PROCEDURE meth(n est un entier)
	
	// Appel
	oBase est ClasseBase
	// Appelle la deuxième syntaxe dans la classe ClasseBase
	oBase.meth("A")
	// Appelle la première syntaxe dans la classe ClasseBase
	oBase.meth(1)		
	
	oDérivée est ClasseDérivée
	// Appelle la deuxième syntaxe dans la classe ClasseBase
	oDérivée.meth("A")	
	// Appelle la première syntaxe dans la classe ClasseDérivée
	oDérivée.meth(1)
	```


- **3ème aspect** : cas particulier lorsque la méthode de la classe de base et la méthode de la classe dérivée ont chacune une seule syntaxe avec des prototypes différents : 
	
	```wl
	ClasseBase
		PROCEDURE meth(s est une chaîne)
	
	ClasseDérivée
		PROCEDURE meth(n est un entier)
	```

	Le compilateur ne peut pas décider si la méthode de la classe dérivée est une redéfinition de celle de la classe de base ou une nouvelle syntaxe.

	- Pour provoquer une redéfinition, il faut ajouter l'attribut d'extension &lt;redéfinition&gt; à la méthode de la classe dérivée. 
			
		```txt
		PROCEDURE méthode(...) <redéfinition>
		```


	- Pour provoquer une multisyntaxe, il faut ajouter l'attribut d'extension &lt;multisyntaxe&gt; à la méthode de la classe dérivée.
			
		```txt
		PROCEDURE méthode(...) <multisyntaxe>
		```









### Notes
<a name="notes_ELTPARAGRAPHE000173"></a>

- Dans de nombreux cas, il est nécessaire de forcer les paramètres en LOCAL pour respecter les règles de passage des paramètres du WLangage.

- Si la détermination dynamique de la syntaxe trouve une syntaxe compatible, celle-ci peut provoquer une erreur d'exécution sur les règles de passage des paramètres par référence.












## Notes
<a name="notes_ELTTEXTE000330"></a>


### Portée des procédures
<a name="portee_des_procedures_ELTPARAGRAPHE000183"></a>Les procédures globales et les méthodes de classe peuvent être publiques, protégées ou privées. Dans le cas d'une procédure multisyntaxe, la portée doit être la même pour toutes les syntaxes. Si les portées des syntaxes sont différentes, une erreur de compilation est générée.






