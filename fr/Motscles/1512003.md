
## Opérateurs logiques
			



<a name="NOTE1"></a>
<a name="NOTE1_1"></a>


## Utilisation
<a name="utilisation_ELTTEXTE000206"></a>
Les opérateurs logiques sont les suivants :


|   |   |
| --- | --- |
| <br><br>- **ET**<br><br><br> | Multiplication logique. Les conditions composées de ET sont toujours évaluées dans leur totalité (même si la première condition est fausse). |
| <br><br>- ** _ET_**<br><br><br> | Multiplication logique. Les conditions composées de _ET_ sont évaluées de manière optimisée. Si la première partie de l'expression est fausse, la suite de l'expression n'est pas évaluée. |
| <br><br>- **OU**<br><br><br> | Addition logique. Les conditions composées de OU sont toujours évaluées dans leur totalité (même si la première condition est vraie). |
| <br><br>- ** _OU_**<br><br><br> | Addition logique. Les conditions composées de _OU_ sont évaluées de manière optimisée. Si la première partie de l'expression est vraie, la suite de l'expression n'est pas évaluée. |
| <br><br>- **PAS**<br><br><br> | Négation logique. |

Les opérateurs logiques permettent d'effectuer des opérations logiques et de construire des conditions.



```wl
SI Client.Ville = "Montpellier" ET Client.Civilité = "Monsieur" ALORS
	HommeMontpellier ++	// Nombre d'hommes habitant à Montpellier
FIN
SI Client.Ville = "Montpellier" OU Client.Ville = "Lyon" ALORS
	MontpellierLyon ++	// Nombre de clients habitant soit à Montpellier,
				// soit à Lyon
FIN
```




<a name="NOTE2"></a>
<a name="NOTE2_1"></a>


## Règles
<a name="regles_ELTTEXTE000230"></a>
Vrai **ET** Vrai : retourne <u><u><u><u>Vrai</u></u></u></u>

Vrai **ET** Faux : retourne <u><u><u><u>Faux</u></u></u></u>

Vrai **OU** Vrai : retourne <u><u><u><u>Vrai</u></u></u></u>

Vrai **OU** Faux : retourne <u><u><u><u>Vrai</u></u></u></u>

**PAS** Vrai : retourne <u><u><u><u>Faux</u></u></u></u>



<a name="NOTE3"></a>
<a name="NOTE3_1"></a>


## Notes
<a name="notes_ELTTEXTE000254"></a>


### Variable numérique
<a name="variable_numerique_ELTPARAGRAPHE000100"></a>Si une variable numérique est manipulée comme un opérateur logique (booléen), "0" est équivalent à <u><u><u><u>Faux</u></u></u></u>. Toute autre valeur est équivalente à <u><u><u><u>Vrai</u></u></u></u>.

Par exemple, les deux lignes de code suivantes sont équivalentes :

```wl
SI NumTest ALORS ...
```



```wl
SI NumTest <> 0 ALORS ...
```


La première syntaxe (SI NumTest ALORS) doit être préférée à la seconde syntaxe.


<a name="NOTE3_2"></a>


### Variable chaîne
<a name="variable_chaine_ELTPARAGRAPHE000123"></a>Si une variable chaîne est manipulée comme un opérateur logique, une erreur du WLangage sera générée.

Par exemple, la syntaxe : "SI ChTest ALORS" retournera une erreur lors de l'exécution (mais pas lors de la compilation du projet).


<a name="NOTE3_3"></a>


### Priorité
<a name="priorite_ELTPARAGRAPHE000133"></a>Les opérateurs **ET** et **OU, _ET_** et** _OU_** ont la même priorité. Pour donner des priorités à ces opérateurs, il suffit de mettre des parenthèses.

Par exemple :

```txt
SI (A = 2 ET B > 3) OU (A = 2 ET B < 0) ALORS ...
```


**Exceptions :** 

- Dans les filtres SQL et les requêtes SQL, l'opérateur ET est prioritaire sur l'opérateur OU.
	Par exemple : 
	
	```txt
	Condition1 ET Condition2 OU Condition3
	```

	sera évalué ainsi :
	
	```txt
	(Condition1 ET Condition2) OU Condition3
	```


- L'addition logique optimisée _OU_ ne doit pas être utilisée si une des expressions à comparer utilise le résultat d'une fonction pouvant renvoyer NULL.
	Par exemple, la comparaison suivante :
	
	```txt
	SI AppelFonction() = "Valeur1" _OU_ AppelFonction() = "Valeur2" ALORS...
	```

	devra être remplacée par le code suivant si la fonction AppelFonction peut renvoyer la valeur NULL :
	
	```txt
	SI AppelFonction() = "Valeur1" OU AppelFonction() = "Valeur2" ALORS...
	```






