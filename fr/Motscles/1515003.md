


## Opérateurs d'affectation
			



<a name="NOTE1"></a>
<a name="NOTE1_1"></a>


## Présentation
<a name="presentation_ELTTEXTE000273"></a>
Il existe plusieurs opérateurs d'affectations :

- [l'affectation simple](#NOTE2_1) : =

- [l'affectation par copie](#NOTE3_1) : &lt;=

- [l'affectation par référence](#NOTE4_1) : &lt;-






<a name="NOTE2"></a>
<a name="NOTE2_1"></a>


## Affectation simple : =
<a name="affectation_simple_ELTTEXTE000297"></a>
L'affectation simple est utilisée entre tous les types simples (entiers, réels, chaînes, etc.) pour copier la valeur d'une variable dans une autre.

Son fonctionnement varie lorsqu'elle est utilisée sur des types complexes. 


| Type des variables | Effet |
| --- | --- |
| Types simples (entier, réel, chaîne, ...) | La valeur de la variable est copiée. |
| Tableaux | Le tableau destination est une référence sur le tableau source. |
| Tableaux associatifs | Le contenu du tableau est copié. |
| File | Le contenu de la file est copié. |
| Pile | Le contenu de la pile est copié. |
| Liste | Le contenu de la liste est copié. |
| Objet = Objet dynamique | Les membres de l'objet dynamique sont copiés dans ceux de l'objet. |
| Objet = Objet | Les membres de l'objet source sont copiés dans ceux de l'objet destination. |
| Objet dynamique = Objet dynamique | L'objet dynamique destination est une référence à l'objet dynamique source. |
| Objet dynamique = Objet | L'objet dynamique destination est une référence à l'objet source. |
| Structure = Structure dynamique | Une copie de la structure est réalisée. Les membres de même nom sont initialisés avec les valeurs existantes. Les membres inexistants sont ignorés. |
| Structure = Structure | Une copie de la structure est réalisée. Les membres de même nom sont initialisés avec les valeurs existantes. Les membres inexistants sont ignorés. |
| Structure dynamique = Structure dynamique | La structure dynamique destination est une référence à la structure dynamique source. |
| Structure dynamique = Structure | La structure dynamique destination est une référence à la structure source. |
| Type avancé = Type avancé | Une copie de la variable de type avancé est réalisée. Les propriétés de même nom sont initialisées avec les valeurs existantes. |
| Type avancé = Type avancé dynamique | Une copie de la variable de type avancé est réalisée. Les propriétés de même nom sont initialisées avec les valeurs existantes. |
| Type avancé dynamique = Type avancé | La variable de type avancé dynamique destination est une référence à la variable de type avancé source.<br> |
| Type avancé dynamique = Type avancé dynamique | La variable de type avancé dynamique destination est une référence à la variable de type avancé dynamique source. |


<a name="NOTE2_2"></a>


### Affectation multiple
<a name="affectation_multiple_ELTPARAGRAPHE000066"></a>L'opérateur **'=**' peut également être utiliser pour affecter plusieurs variables en une seule ligne de code.

La syntaxe utilisée est la suivante : 

```txt
( <Variable 1>, <Variable 2>, ... <Variable N> ) = ( <Valeur 1>, <Valeur 2>, ... <Valeur M> )
```


où : 

- N représente le nombre de variables déclarées.

- M représente le nombre de valeurs à affecter.




Remarques :

- Les expressions à droite du signe '=' sont d'abord évaluées de gauche à droite.

- Les opérations d'affectation des variables à gauche du signe sont ensuite effectuées de gauche à droite.

- Il n'y a pas de dépendances entre les expressions de droite et celles de gauche. Par contre, il peut y avoir une dépendance entre les variables de gauche.

- Si il y a moins de variables que de valeurs (N inférieur à M), une erreur de compilation sera générée.

- Si il y a plus de variables que de valeurs (N supérieur ou égal à M), seules les premières variables seront affectées.

- Pour affecter la même valeur à toutes les variables, il suffit d'utiliser la syntaxe suivante : 
	
	```txt
	( <Variable 1>, <Variable 2>, ... <Variable N> ) = <Valeur>
	```

	Par exemple : 
	```wl
	(x,y,z) = 0
	```

	




Exemples : 

```wl
(x, y, z) = (5, 8, 12)
// x vaut 5, y vaut 8, z vaut 12

(x, y, z) = (25, 38)
// x vaut 25, y vaut 38, z n'est pas affecté


(x, , z) = (14, 87)
// x vaut 14, y n'est pas affecté, z vaut 87

(t[Indice1()], t[Indice2()]) = (Calcul1(), calcul2())
// L'ordre d'exécution des procédures est le suivant : 
// Calcul1()
// Calcul2()
// Indice1()
// Indice2()
// puis t[Indice1()] est affecté de la valeur de Calcul1()
// puis t[Indice2()] est affecté de la valeur de Calcul2()

(i, t[i]) = (1, "ABC")
// Affecte tout d'abord 1 à i
// Affecte ensuite "ABC" dans t à l'indice i
```


<a name="NOTE3"></a>
<a name="NOTE3_1"></a>


## Affectation par copie : &lt;=
<a name="affectation_par_copie_ELTTEXTE000404"></a>
L'affectation par copie force toujours la copie de l'élément source dans l'élément destination.

Une nouvelle zone de mémoire est allouée pour stocker la valeur copiée. 


### Affectation par copie sur les tableaux
<a name="affectation_par_copie_sur_les_tableaux_ELTPARAGRAPHE000113"></a>Il est possible d'utiliser l'opérateur &lt;= sur les tableaux.
Ces tableaux peuvent être de types différents.
L'affectation utilise les conversions implicites du WLangage (comme le ferait l'opérateur =).

Exemple :

```wl
// Déclaration de deux tableaux de même taille de types différents (entier et booléen)
tabEntiers  est un tableau de 3 par 2 entiers
tabBooléens est un tableau de 3 par 2 booléens

// Remplissage du tableau d'entiers
tabEntiers[1,1] = -6
tabEntiers[1,2] = 9
tabEntiers[2,1] = 0

// Copie du tableau d'entiers dans le tableau de booléens
tabBooléens <= tabEntiers

// Traces du tableau de booléens 
// (Rappel : tous les nombres autres que zéro sont "Vrai" en logique booléenne)
Trace(tabBooléens[1,1]) // Affiche 1
Trace(tabBooléens[1,2]) // Affiche 1
Trace(tabBooléens[2,1]) // Affiche 0
Trace(tabBooléens[2,2]) // Affiche 0
```



### Copie homonymique
<a name="copie_homonymique_ELTPARAGRAPHE000127"></a>Le mécanisme de la copie homonymique utilise l'opérateur *&lt;=* pour transférer des données depuis un élément structuré vers un autre élément structuré. 

Lors de la copie, les membres de même nom sont automatiquement recopiés de l'élément structuré source vers l'élément structuré destination. Les conversions de type seront automatiquement effectuées.

Il est ainsi possible de réaliser par exemple : 

- le transfert du contenu des membres d'une structure vers les rubriques d'un fichier HFSQL,

- le transfert des membres d'un type avancé (type Email par exemple) vers les membres d'une classe. 




Les types structurés manipulables sont les suivants : 

- structures,

- classes,

- types avancés,

- fichiers HFSQL, 

- requêtes,

- sources de données.






Exemple : Copie de classes

```wl
// Déclaration des classes
Classe_1 est une classe
	commun est un entier
	membre_1 est un entier
FIN

Classe_2 est une classe
	commun est un entier
	membre_2 est un entier
FIN

// Affectation
o1 est Classe_1
o1.commun = 1
o1.membre_1 = 1
	
o2 est Classe_2
o2.commun = 2
o2.membre_2 = 2

// Copie
o1 <= o2

// Résultat
// o1.commun = 2
// o1.membre_1 = 1
```


Remarques : 

- L'opérateur *&lt;=* peut être remplacé par l'opérateur *=* lorsque le fonctionnement ne présente pas d'ambiguïté.  

- Pour les structures et les classes, chaque membre peut être suivi d'un attribut "Mapping". Cet attribut permet de spécifier le nom du membre à "mapper" au membre de la structure ou de la classe. 
	
	Exemple :  
	
	```wl
	// Déclaration des classes
	Classe_Simple_1 est une classe
		commun est un entier
		membre_1 est un entier
	FIN
	
	Classe_Mapping_1 est une classe
		nCommun est un entier, Mapping = "commun"
		membre_1 est un entier, Mapping = ""
	FIN
	
	// Affectation
	o1 est Classe_Mapping_1
	o1.nCommun = 1
	o1.membre_1 = 1
		
	o2 est Classe_Simple_1
	o2.commun = 2
	o2.membre_1 = 2
		
	o1 <= o2
	
	// Résultat
	// o1.ncommum = 2
	// o1.membre_1 = 1
	```





- Pour les types avancés disposant de sous-éléments dynamiques (par exemple le type xmlNoeud ou les éléments structurés des Webservices), les sous-éléments sont prioritaires sur les propriétés standard du type. 
	Exemple :  
	
	```wl
	// Déclaration des classes
	Classe_xmlNoeud est une classe 
		Nom est une chaîne
		Balise1 est une chaîne
		Balise2 est une chaîne
	FIN
	
	// Affectation
	o1 est un Classe_xmlNoeud
	o1.Nom = ""
	o1.Balise1 = ""
	o1.Balise2 = ""
		
	c1 est un xmlNoeud
	c1..Nom = "Noeud_XML_avec_balise_Nom"
	c1.Nom = "Nom"
	c1.Balise1 = "Balise1"
	c1.Balise2 = "Balise2"
		
	o1 <= c1
	
	// Résultat
	// o1.Nom = "Nom"
	// o1.Balise1 = "Balise1"
	// o1.Balise2 = "Balise2"
	```


- Cas particulier : copie homonymique entre des structures ou classes : 

	- L'attribut "mapping" est autorisé pour les membres de la structure ou classe source ou destination (mais pas pour les deux). 

	- Si un membre dérivé a le même nom que un membre de la classe de base ou un mapping avec le même nom, seul le nom de la classe dérivée est pris en compte. 







- Limite : La copie homonymique n'est pas disponible : 

	- sur les objets .Net, 

	- sur les objets automation, 

	- si la source et la destination sont des types avancés avec des sous-éléments dynamiques. 







<a name="NOTE4"></a>
<a name="NOTE4_1"></a>


## Affectation par prise de référence : &lt;-
<a name="affectation_par_prise_reference_ELTTEXTE000440"></a>
L'affectation par prise de référence force l'élément destination à référencer la même zone de données que l'élément source.

Cette affectation ne peut pas être utilisée avec les types simples (entiers, réels, chaînes, etc.).

Ce type d'affectation peut être utilisé pour manipuler directement : 

- les rendez-vous d'un champ Agenda. Pour plus de détails, consultez [Programmation d'un champ Agenda](../WDChamp/1016326.md). 

- les rendez-vous d'un champ Planning. Pour plus de détails, consultez [Programmation d'un champ Planning](../WDChamp/1000019505.md). 

- les tâches d'un champ Diagramme de Gantt. Pour plus de détails, consultez [Programmation d'un champ Diagramme de Gantt](../WDChamp/1000030004.md). 




<a name="NOTE5"></a>
<a name="NOTE5_1"></a>


## Remarques
<a name="remarques_ELTTEXTE000464"></a>
Les opérateurs de prise de référence (=, &lt;= et &lt;-) renvoient "Null" si l'affectation ou la prise de référence est invalide. Il devient possible d'écrire le code suivant :

```wl
Objet1 est un objet ClasseBase1
Objet2 est un objet ClasseDérivée

Objet1 <- Objet2

SI Objet1 = Null ALORS
	Trace("Objet1 n'est pas un ClasseDérivée ni une classe ancêtre de ClasseDérivée.")
SINON
	Trace("Objet1 est un ClasseDérivée ou un classe ancêtre de ClasseDérivée.")
FIN
```



