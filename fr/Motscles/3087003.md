
## Inférence de type
			

<a name="NOTE1"></a>
<a name="NOTE1_1"></a>


## Présentation
<a name="presentation_ELTTEXTE000314"></a>
L'inférence de type permet de simplifier la déclaration des variables dans le cas où le compilateur peut déduire automatiquement le type de la variable. Le principe est simple. Le type de la variable est alors déduit en fonction de la valeur qui est affectée à la variable.

L'affectation de la valeur peut être réalisée : 

- [par copie](#NOTE2_1).

- [par référence](#NOTE3_1).








<a name="NOTE2"></a>
<a name="NOTE2_1"></a>


## Inférence de type : affectation par copie
<a name="inference_type_affectation_par_copie_ELTTEXTE000338"></a>


### Syntaxes
<a name="syntaxes_ELTPARAGRAPHE000050"></a>

**1. Inférence simple** : 

```txt
soit <Variable> = <Valeur>
```


où : 

- &lt;Variable&gt; correspond au nom de la variable à déclarer. 

- &lt;Valeur&gt; correspond à la valeur affectée à la variable à déclarer.




**2. Inférence multiple** : 

```txt
soit (<Variable 1>, ..., <Variable N>) = (<Valeur 1>, ..., <Valeur N>)
```


où : 

- &lt;Variable 1&gt; ... &lt;Variable N&gt; correspondent aux noms des variables à déclarer. 

- &lt;Valeur 1&gt; ... &lt;Valeur N&gt;  correspondent aux valeurs affectées à chaque variable à déclarer.







### Fonctionnement
<a name="fonctionnement_ELTPARAGRAPHE000072"></a>Lors de l'affectation par copie, si le type de la variable peut être déterminé à la compilation, la variable est déclarée selon le type de la valeur. Une copie de la valeur est affectée à la variable.

Exemples : 


```wl
soit Montant = 1500.69 // type réel

soit Ville = "Montpellier" // type chaîne
```



```wl
// Inférence multiple
soit (x, y) = (1, "A")

// Inférence multiple via une procédure renvoyant des valeurs multiples
soit (x, y) = MaProcédureARetourMultiple()
```


Remarque : La variable garde son type et ne change pas de type en cours d'exécution même si une autre valeur d'un type différent lui est affectée.

Si le type de la variable ne peut pas être déterminé à la compilation, le type sera déterminé au moment de l'exécution, donc dynamiquement (comme lorsque un paramètre de procédure n'est pas typé).

Par exemple :


```wl
// Cas type inconnu au moment de la compilation
PROCEDURE MaProc(Param1)

soit MaVar = Param1 

// Comme le paramètre Param1 n'est pas typé, 
// son type est inconnu au moment de la compilation
// La variable Param1 sera typée du type de la valeur passée en paramètre 
// au moment de l'appel de la procédure.
// La variable MaVar sera donc typée également 
// du type de la variable Param1 connu uniquement au moment de l'exécution.
```



### Les types simples gérés par l'affectation par copie
<a name="les_types_simples_geres_par_affectation_par_copie_ELTPARAGRAPHE000093"></a>Les types simples gérés par l'affectation par copie sont les suivants : 

| Type de la valeur | Type utilisé |
| --- | --- |
| booléen | booléen |
| entier sans signe sur 1 octet | entier |
| entier sans signe sur 2 octets | entier |
| entier sans signe sur 4 octets | entier sans signe sur 4 octets |
| entier sans signe sur 8 octets | entier sans signe sur 8 octets |
| entier sur 1 octet | entier |
| entier sur 2 octets | entier |
| entier | entier |
| entier sur 8 octets | entier sur 8 octets |
| monétaire | monétaire |
| décimal | décimal |
| réel sur 4 octets | réel sur 4 octets |
| réel | réel |
| caractère | caractère |
| chaîne | chaîne (Ansi ou Unicode) |
| chaîne sur N | chaîne (Ansi ou Unicode) |
| chaîne Ansi | chaîne Ansi |
| chaîne Ansi sur N | chaîne Ansi |
| chaîne Unicode | chaîne Unicode |
| chaîne Unicode sur N | chaîne Unicode |
| chaîne ASCIIZ sur N | chaîne Ansi |
| chaîne Fixe sur N | chaîne Ansi |
| chaîne Pascal sur N | chaîne Ansi |
| buffer | buffer |
| date | date |
| heure | heure |
| dateheure | dateheure |
| durée | durée |
| police | police |
| procédure | procédure |







<a name="NOTE3"></a>
<a name="NOTE3_1"></a>


## Inférence de type : affectation par référence
<a name="inference_type_affectation_par_reference_ELTTEXTE000374"></a>


### Syntaxes
<a name="syntaxes_ELTPARAGRAPHE000229"></a>

**1. Inférence simple** : 

```txt
soit <Variable> <- <Valeur>
```


où : 

- &lt;Variable&gt; correspond au nom de la variable à déclarer. 

- &lt;Valeur&gt; correspond à la valeur affectée à la variable à déclarer.




**2. Inférence multiple** : 

```txt
soit (<Variable 1>, ..., <Variable N>) <- (<Valeur 1>, ..., <Valeur N>)
```


où : 

- &lt;Variable 1&gt; ... &lt;Variable N&gt; correspondent aux noms des variables à déclarer. 

- &lt;Valeur 1&gt; ... &lt;Valeur N&gt;  correspondent aux valeurs affectées à chaque variable à déclarer.



L'affectation par référence est disponible uniquement pour des types complexes :

- Type Objet : Classe, Structure, Classe .NET, type avancé, ...

- Type Conteneur : Tableau, Tableau associatif, Pile, File, Liste, ...




Lors d'une affectation par référence, la valeur de la variable de référence n'est pas copiée dans la nouvelle variable mais la nouvelle variable pointe sur la variable de référence. 

Dans ce cas, si la variable qui sert de référence est modifiée, la nouvelle variable est aussi modifiée.

Exemple :


```wl
clMonClient est un cClient // classe cClient, objet clMonClient
soit clClient <- clMonClient // type classe, clClient pointe sur l'objet clMonClient

tabPrix est un tableau de 5 monétaires
tabPrix[1] = 500.00
tabPrix[2] = 250

soit tPrix <- tabPrix // type tableau, tPrix pointe sur le tableau tabPrix
```


![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) L'inférence de type par référence n'est pas supportée pour les Tableaux associatifs.






