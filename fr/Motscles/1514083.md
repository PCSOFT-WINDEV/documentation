
## UUID (Type de variable)

***En anglais : UUID***
				

<a name="XUtilisation"></a>
<a name="Utilisation"></a>


<a name="description"></a>
Le type UUID permet de manipuler facilement :

- des UUID ou des GUID,

- des identifiants automatiques uniques HFSQL de type UUID,

- les identifiants des objets et des interfaces COM/Automation, 

- ...




Les variables de type UUID sont disponibles : 

- en 128 bits. Les UUID sur 128 bits vérifient la RFC 4122. 

- en 256 bits. 





<a name="Exemple1"></a>
<a name="sample_code"></a>

## Exemple


```wl
v est un UUID 	// Déclaration d'un UUID sur 128 bits par défaut
v1 est un UUID sur 128
v2 est un UUID sur 256
```



<a name="XSYNTAXE"></a>
<a name="SYNTAXE1"></a>

## Syntaxe

### Déclaration et affectation d'un type UUID

`<Nom de la variable> est un UUID = <Valeur>
 
OU 

 
  <Nom de la variable> est un UUID
  <Nom de la variable> = <Valeur>
`
---

**`<Nom de la variable> : ()`**

Nom de la variable à déclarer.

**`<Valeur> : ()`**

Valeur à affecter à la variable. Une variable de type UUID peut être affectée avec :

- le résultat de la fonction [DonneGUID](../WDLang1/1000018857.md). 

- le résultat de la fonction [DonneUUID](../WDLang1/1000023915.md) ou de la fonction [DonneUUID256](../WDLang1/1000023916.md).  






<a name="NOTE0"></a>
<a name="NOTE0_1"></a>

## Remarques




### UUID vide
<a name="uuid_vide_ELTPARAGRAPHE000061"></a>Par défaut, lors de la création d'une variable de type UUID, cette variable est vide. Sa valeur correspond : 

- à la constante *Nil_UUID* pour les variables de type UUID sur 128. 

- à la constante *Nil_UUID_256* pour les variables de type UUID sur 256. 







<a name="NOTE0_1B"></a>




### Conversions possibles
<a name="conversions_possibles_ELTPARAGRAPHE000074"></a>Le but principal des conversions est de permettre un débogage facile tout en détectant les opérations n'ayant pas de sens. Les conversions en chaîne ou buffer sont possibles mais il n'est pas possible d'effectuer une conversion vers une variable de type numérique.

Un UUID 128 est convertible : 

- en chaîne au format héxadécimal standard "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx".

- en buffer au format "big-endian" (16 octets).




Un UUID 256 est convertible : 

- en chaîne au format héxadécimal "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx".

- en buffer au format "big-endian" (32 octets).




Les autres conversions ne sont pas autorisées. En particulier, un UUID 128 n'est pas convertible en un UUID 256 et réciproquement.


<a name="NOTE0_2"></a>




### Opérations disponibles
<a name="operations_disponibles_ELTPARAGRAPHE000095"></a>Le but principal des opérations est de permettre un débogage facile tout en détectant les opérations n'ayant pas de sens. La concaténation avec une chaîne est donc autorisée mais aucune opération arithmétique n'est autorisée.

Un UUID (128 ou 256) peut être concaténé avec une chaîne ou un buffer.
<a name="NOTE0_3"></a>




### Comparaison
<a name="comparaison_ELTPARAGRAPHE000105"></a>Les UUID sont comparables afin de permettre le tri et la recherche dichotomique dans un tableau.

- Les UUID 128 peuvent être comparés à des UUID 128, des chaînes et des buffers.

- Les UUID 256 peuvent être comparés à des UUID 256, des chaînes et des buffers.





<a name="NOTE0_4"></a>


### Génération d'un UUID
<a name="generation_uuid_ELTPARAGRAPHE000116"></a>Un UUID 128 peut être généré : 

- grâce à la fonction [DonneGUID](../WDLang1/1000018857.md). Exemple :  
	
	```wl
	v est un UUID = DonneGUID()
	```


- grâce à la fonction [DonneUUID](../WDLang1/1000023915.md). Exemple : 
	
	```wl
	v est un UUID = DonneUUID()
	```





Un UUID 256 peut être généré : 

- grâce à la fonction [DonneGUID](../WDLang1/1000018857.md). Exemple : 
	
	```wl
	v est un UUID sur 256 = DonneGUID(guidBrut256)
	```


- grâce à la fonction [DonneUUID256](../WDLang1/1000023916.md). Exemple : 
	
	```wl
	v est un UUID sur 256 = DonneUUID256()
	```






<a name="NOTE0_5"></a>


### Rubriques HFSQL
<a name="rubriques_hfsql_ELTPARAGRAPHE000152"></a>

- Les rubriques de type UUID 128 et UUID 256 sont disponibles dans l'analyse.

- Les rubriques de type UUID 128 et UUID 256 peuvent être automatiques. Dans ce cas, ce sont des identifiants automatiques de type UUID. Un UUID sera automatiquement généré lors de l'appel de la fonction [HAjoute](../WDLang4/3044147.md).




Pour plus de détails, consultez [Editeur d'analyses : les différents types de rubriques](../Editeurs/2011026.md). 




<a name="NOTE0_6"></a>


### Gestion des types UUID dans les champs
<a name="gestion_des_types_uuid_dans_les_champs_ELTPARAGRAPHE000170"></a>Des masques de saisie et d'affichage de type "UUID" et "UUID 256" sont disponibles pour les différents champs permettant de manipuler ces types. 

Le binding est disponible vers les rubriques HFSQL et les variables de type UUID.


<a name="NOTE0_7"></a>


### Interface COM
<a name="interface_com_ELTPARAGRAPHE000180"></a>Un UUID 128 peut être utilisé pour stocker les CLSID et les IID des objets et des interfaces COM. Il peut donc être utilisé dans les fonctions [COMCréeInstance](../WDLang1/1000018831.md) et [COMRécupèreInterface](../WDLang1/1000019784.md).
<a name="NOTE0_8"></a>


### Sérialisation
<a name="serialisation_ELTPARAGRAPHE000193"></a>Les UUID sont sérialisables (fonction [Sérialise](../WDLang1/3013065.md)) : 

- UUID 128 :

	- Sérialisable en XML et en JSON : chaîne au format standard "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"

	- Sérialisable en binaire : format binaire "big-endian".




- UUID 256 :

	- Sérialisable en XML et en JSON : chaîne au format "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"

	- Sérialisable en binaire : format binaire "big-endian".














