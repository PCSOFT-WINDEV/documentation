


## Héritage de classe
			



<a name="NOTE1"></a>
<a name="NOTE1_1"></a>


## Présentation
<a name="presentation_ELTTEXTE000277"></a>
L'organisation hiérarchique en classes et sous-classes a permis de créer la notion d'héritage.

Autrement dit un objet de la sous-classe A (classe dérivée) qui possède les mêmes caractéristiques que la classe B (classe ancêtre), plus certaines qui lui sont propres, hérite d'emblée des caractéristiques de la classe B sans qu'il soit nécessaire de dupliquer les programmes dans l'objet de la sous-classe A. Ainsi le nombre de lignes de code diminue.

L'héritage est le mécanisme par lequel la classe en cours de description utilise les méthodes et les membres définies dans les classes existantes.

- La classe existante est appelée **Classe ancêtre** ou **Classe de base**.

- La nouvelle classe est appelée **Classe dérivée**. La classe dérivée englobe la classe ancêtre et y ajoute de nouvelles méthodes, de nouveaux membres et de nouvelles propriétés.




Le but de l'héritage est de récupérer pour une classe, les méthodes développées pour une autre classe, en y ajoutant les spécificités de la nouvelle classe.

Une classe dérivée permet à ses objets d'accéder à toutes les méthodes, à tous les membres et à toutes les propriétés de ses classes ancêtres; tout se passe comme si les méthodes, les membres et les propriétés des classes ancêtres faisaient partie de la classe dérivée.

Caractéristiques d'un héritage :

- Un héritage peut être multiple. Dans ce cas, la classe dérivée peut être dérivée de plusieurs classes ancêtres.

- Un héritage peut être privé ou public (par défaut).
	Si l'héritage est public, il est possible d'accéder aux méthodes, aux propriétés et aux membres hérités depuis l'extérieur de la classe.
	Si l'héritage est privé, seules les méthodes de la classe dérivée peuvent accéder aux méthodes, aux propriétés et aux membres hérités.

- Comme dans tous les langages, le polymorphisme ne fonctionne qu'avec des objets dynamiques.






<a name="NOTE2"></a>
<a name="NOTE2_1"></a>


## Syntaxes
<a name="syntaxes_ELTTEXTE000301"></a>


### Héritage d'une classe
<a name="heritage_une_classe_ELTPARAGRAPHE000060"></a>
```txt
<NomClasseDérivée> est une classe
	[PRIVE, PROTEGE, PUBLIC]
	Hérite de <NomClasseAncêtre>
	<Nom Membre classe Dérivée> est <Type du membre>
	...
FIN
```

<a name="NOTE2_2"></a>


### Détail de la syntaxe
<a name="detail_syntaxe_ELTPARAGRAPHE000067"></a>**&lt;NomClasseDérivée&gt;**
Nom identifiant la classe dérivée en cours de déclaration.

 
**PRIVE, PROTEGE, PUBLIC**
Mot-clé optionnel. Indique si l'héritage est privé ou non. Si ce mot n'est pas précisé, l'héritage est public.

 
**&lt;NomClasseAncêtre&gt;**
Nom de la classe ancêtre.

 
**&lt;Nom Membre classe Dérivée&gt;**
Nom du membre de la classe dérivée. Ce membre sera utilisable uniquement dans un objet de la classe dérivée.

 
**&lt;Type du membre&gt;**
Type du membre, choisi parmi les types disponibles. 

```wl
NomFichier est une Classe 
	Nom est une Chaîne
	Extension est une Chaîne
	Répertoire est une Chaîne
FIN
 
InformationsFichier est une classe 
	Hérite de NomFichier
	TailleFichier est un entier
	DateFichier est une Chaîne 
	HeureFichier est une Chaîne 
FIN
```

<a name="NOTE2_3"></a>


### Syntaxe conservée pour compatibilité
<a name="syntaxe_conservee_pour_compatibilite_ELTPARAGRAPHE000104"></a>
```txt
<NomClasseDérivée> est une classe
	[PRIVE, PROTEGE, PUBLIC]
	Un objet <NomClasseAncêtre>
	<Nom Membre classe Dérivée> est <Type du membre>
	...
FIN
```


<a name="NOTE3"></a>
<a name="NOTE3_1"></a>


## Redéfinition de méthodes
<a name="redefinition_methodes_ELTTEXTE000337"></a>
Dans une classe dérivée, une méthode de la classe de base peut être redéfinie en créant dans la classe dérivée une méthode de même nom que celle de la classe de base.

La redéfinition de méthode permet de modifier le comportement de la méthode définie dans la classe de base; la classe dérivée peut éventuellement redéfinir la méthode en fonction de ses besoins.

Par défaut, la méthode redéfinie est une méthode virtuelle.

**Remarque** : la surcharge d'une méthode (utilisation de deux méthodes de même nom dans la même classe) est gérée en WLangage. Pour plus de détails, consultez [Surcharge de prototype/Multisyntaxe](../Motscles/1514063.md).

**Note** : le mot-clé **Objet** permet d'accéder à l'objet courant à l'intérieur d'une méthode
<a name="NOTE3_2"></a>


### Exemple
<a name="exemple_ELTPARAGRAPHE000129"></a>La classe **InfoFichier** hérite de la classe **NomFichier**. Ces deux classes ont une méthode Affiche. La méthode Affiche de la classe **NomFichier** est utilisée par la méthode Affiche de la classe **InfoFichier**.


|   |   |
| --- | --- |
| **Classe NomFichier** | **Classe InfoFichier** |
| Déclaration de la classe | Déclaration de la classe |
| <br><pre><code>NomFichier est une classe<br>	Nom est une chaîne<br> 	Extension est une chaîne<br> 	Répertoire est une chaîne <br>FIN</code></pre><br> | <br><pre><code>InformationsFichier est une classe<br>	Hérite de NomFichier<br>	TailleFichier est un entier<br>	DateFichier est une Chaîne  	<br>	HeureFichier est une Chaîne  <br>FIN</code></pre><br> |
| Méthode Affiche | Méthode Affiche |
| <br><pre><code>PROCEDURE Affiche()<br>Trace(:Nom) <br>Trace(:Extension) <br>Trace(:Répertoire)</code></pre><br> | <br><pre><code>PROCEDURE AFFICHE() <br>Ancêtre:Affiche() <br>Trace(:TailleFichier) <br>Trace(:DateFichier) <br>Trace(:HeureFichier)</code></pre><br> |


<a name="NOTE3_3"></a>


### Exemple
<a name="exemple_ELTPARAGRAPHE000157"></a>Le polymorphisme ne fonctionne qu'avec des objets dynamiques.

Dans cet exemple, une classe virtuelle animal est créée. Deux classes (lapin et chat) héritent de cette classe. On veut réaliser une liste des objets différents (des lapins et des chats).

```wl
Animal est une Classe 
FIN
 
Chat est une Classe 
	Hérite de Animal
FIN
Lapin est une Classe 
	Hérite de Animal
FIN

ListeA est un tableau de 16 animal dynamiques
ListeA[1] = allouer un chat
ListeA[1] = allouer un lapin
```


<a name="NOTE4"></a>
<a name="NOTE4_1"></a>


## Syntaxe pour appeler une méthode de la classe de base
<a name="syntaxe_pour_appeler_une_methode_classe_base_ELTTEXTE000373"></a>


### Syntaxe 1
<a name="syntaxe_1_ELTPARAGRAPHE000169"></a>
```txt
Ancêtre:<Nom de la Méthode>()
```
**Détail de la syntaxe**
**Ancêtre**
mot-clé permettant d'indiquer que la méthode à utiliser est la méthode de la classe ancêtre immédiatement précédente (utilisable dans le cas d'un seul héritage). Pour appeler une méthode d'une classe de base quelque soit son niveau dans l'ordre d'héritage, il est nécessaire d'utiliser la syntaxe 2.

**&lt;Nom de la méthode&gt;**
Nom de la méthode à utiliser dans la classe ancêtre.<a name="NOTE4_2"></a>


### Syntaxe 2
<a name="syntaxe_2_ELTPARAGRAPHE000187"></a>
```txt
<Classe de base>:<Nom de la Méthode>()
```
**Détail de la syntaxe**
**&lt;Classe de base&gt;**
Nom de la classe ancêtre dans laquelle la méthode à utiliser a été définie.

**&lt;Nom de la méthode&gt;**
Nom de la méthode à utiliser dans la classe ancêtre.<a name="NOTE4_3"></a>


### Syntaxe 3
<a name="syntaxe_3_ELTPARAGRAPHE000205"></a>
```txt
:<Classe de base>:<Nom de la Méthode>()
```
**Détail de la syntaxe**
**&lt;Classe de base&gt;**
Nom de la classe ancêtre dans laquelle la méthode à utiliser a été définie.

**&lt;Nom de la méthode&gt;**
Nom de la méthode à utiliser dans la classe ancêtre.<a name="NOTE4_4"></a>


### Remarque
<a name="remarque_ELTPARAGRAPHE000223"></a>Pour les constructeurs et destructeurs, il est conseillé d'utiliser des syntaxes spécifiques (consultez [Syntaxe des constructeurs des classes de base et des membres](../POO/6010001.md)).


- ![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=WDPOOSimple.gif) ***Exemples didactiques (WINDEV)*** : **WD POO Simple** <br>L'exemple "WD POO Simple" est un exemple didactique sur la POO avec WINDEV. Cet exemple permet de voir le fonctionnement :<br>- des classes, <br>- des héritages,<br>- des procédures virtuelles,<br>- des diagrammes UML,<br>- ...
- ![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=WDPilotagetraitementdetexte.gif) ***Exemples didactiques (WINDEV)*** : **WD Pilotage traitement de texte** <br>Le but de cet exemple est de proposer une interface universelle, permettant de piloter ces applications, sans se soucier de l'application à piloter. Cet exemple se base sur un concept de la programmation orientée objet : le polymorphisme. Cela consiste à utiliser des objets différents (objet LibreOffice et objet MicrosoftWord), sans savoir réellement lequel est utilisé.


