


## Classes, membres, méthodes et propriétés
			



<a name="NOTE1"></a>
<a name="NOTE1_1"></a>


## Présentation d'une classe
<a name="presentation_une_classe_ELTTEXTE000807"></a>
Une classe est composée de :

- données, appelées **membres**.

- **constantes**.

- procédures, appelées **méthodes**. Une méthode est une procédure spécialement écrite pour manipuler les objets de la classe.

- **propriétés**. Une propriété est un élément de la classe qui s'utilise directement par son nom comme un membre et pour lequel les opérations d'affectation et de récupération de la valeur provoquent l'exécution d'un traitement.
	![Universal Windows 10 App](https://doc.pcsoft.fr/ext/images/fr/UNIVERSALAPP.png) Les propriétés de classes ne sont pas disponibles.




Pour utiliser une classe, il faut déclarer un ou plusieurs objets. Tous les objets d'une classe donnée sont identiques par leur forme et leur comportement, mais leurs membres contiennent des données différentes.

Par défaut les membres d'une classe sont publics, ils sont accessibles aussi bien par une méthode de la classe que par un traitement/événement du projet ou de ses éléments (champ, fenêtre, ...).



<a name="NOTE2"></a>
<a name="NOTE2_1"></a>


## Exemple de classe
<a name="exemple_classe_ELTTEXTE000831"></a>
La classe "CFichier" est composée des membres : m_sCheminCourt, m_sCheminLong, m_sExtension, m_sNomCourt, m_sNomLong.

La classe "CFichier" a les méthodes suivantes :


|   |   |
| --- | --- |
| <br><br>- DateFichier()<br><br>- SelectionFichier()<br><br><br> | <br><br>- HeureFichier()<br><br>- TailleFichier()<br><br><br> |

Cette classe n'a pas de propriétés.

Les informations affichées dans le volet "Explorateur de projet" sont les suivantes :<br>![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=Classe_POO%20-%20HC%20N%B0001.gif)
Pour connaître la légende des différentes icônes utilisées, consultez les Notes.

<a name="NOTE3"></a>
<a name="NOTE3_1"></a>


## Création et déclaration d'une classe
<a name="creation_declaration_une_classe_ELTTEXTE000855"></a>


### Création d'une classe
<a name="creation_une_classe_ELTPARAGRAPHE000064"></a>Pour créer une classe :

1. Affichez si nécessaire le volet "Explorateur de projet" : sous le volet "Accueil", dans le groupe "Environnement", déroulez "Volets" puis sélectionnez "Explorateur de projet".

2. Dans le volet "Explorateur de projet", affichez le menu contextuel du dossier "Classes" puis sélectionnez "Créer une classe".

3. Saisissez le nom de la classe dans la fenêtre qui s'ouvre et validez.

4. L'éditeur de code affiche le code de la nouvelle classe. L'événement "Déclaration" de la classe ainsi que le constructeur et le destructeur sont automatiquement créés.



<a name="NOTE3_2"></a>


### Syntaxe de déclaration de la classe et de ses éléments
<a name="syntaxe_declaration_classe_ses_elements_ELTPARAGRAPHE000088"></a>
```txt
<NomClasse> est une Classe [, abstraite]
	<Portée et droits>
		<Déclaration membre 1>
		<Déclaration membre 2>
	<Portée et droits>
		<Déclaration membre 3>
		<Déclaration membre 4>
	...
	<CONSTANTE>
		<Déclaration des constantes>
FIN
```

<a name="NOTE3_3"></a>


### Détail de la syntaxe de déclaration d'une classe
<a name="detail_syntaxe_declaration_une_classe_ELTPARAGRAPHE000095"></a>**&lt;NomClasse&gt;**

Nom identifiant la classe.

**abstraite : optionnel**

Permet d'indiquer que la classe est abstraite. Une classe abstraite est une classe de base qui regroupe des comportements communs à plusieurs classes. 
Une classe est abstraite lorsqu'elle est déclarée comme telle ou si une de ses méthodes est abstraite.
Une classe abstraite ne peut pas être instanciée.

**&lt;Portée et droits&gt;**

Ce paramètre est de la forme : [GLOBAL][ Public/ Public CONSTANT / Protégé / Protégé CONSTANT / Privé ]

**GLOBAL : Optionnel**

Définit un membre global. Ce membre existera en dehors des objets. Il pourra être utilisé sans instancier un objet. Si plusieurs objets sont déclarés, un membre global est commun à tous les objets.

**&lt;Mode d'accès&gt; : Optionnel**

Permet de restreindre l'accès à ce membre de la classe.

- **Public** (par défaut) : accès autorisé depuis n'importe quel code de la classe ou du projet.

- **Public CONSTANT** : La valeur du membre peut être lue et modifiée depuis un code de la classe ou d'une classe dérivée, et uniquement lue depuis un autre code de l'application. 

- **Protégé** : accès autorisé depuis un code de la classe ou un code d'une classe dérivée (et "héritée")

- **Protégé CONSTANT** : La valeur du membre peut être lue et modifiée depuis un code de la classe, uniquement lue depuis un code d'une classe dérivée, et inaccessible depuis un autre code de l'application. 

- **Privé** : accès autorisé depuis un code de la classe




**&lt;Déclaration membre&gt;**

Syntaxe de déclaration des membres de la classe (voir ci-dessous). La portée et les droits d'accès des membres sont ceux courants.

**&lt;Déclaration des constantes&gt;**

Syntaxe de déclaration des constantes (voir ci-dessous).<a name="NOTE3_4"></a>


### Exemple
<a name="exemple_ELTPARAGRAPHE000165"></a>
```wl
ClasseSystème est une Classe
	Nom est une chaîne
FIN
```


<a name="NOTE4"></a>
<a name="NOTE4_1"></a>


## Déclaration des membres d'une classe
<a name="declaration_des_membres_une_classe_ELTTEXTE000897"></a>


### Syntaxe
<a name="syntaxe_ELTPARAGRAPHE000174"></a>
```txt
<Nom du membre> est un <Type du membre> [ = <Valeur initiale>]
```

<a name="NOTE4_2"></a>


### Détail de la syntaxe
<a name="detail_syntaxe_ELTPARAGRAPHE000181"></a>**&lt;Nom du membre&gt;**

Nom identifiant le membre.

**&lt;Type du membre&gt;**

Type du membre choisi parmi les types disponibles du WLangage.

**&lt;Valeur initiale&gt;**

Valeur initiale du membre.
```wl
ClasseSystème est une classe
	Nom est une chaîne
	Privé
		TailleClasse est un entier
FIN
```

<a name="NOTE4_3"></a>


### Déclaration des membres de type Tableau
<a name="declaration_des_membres_type_tableau_ELTPARAGRAPHE000205"></a>Pour déclarer un tableau dans une classe, il suffit d'utiliser la syntaxe suivante :

```txt
ClasseSystème est une Classe
	TableauDéfaut est un tableau de 1 entier
FIN
```


Le tableau est déclaré de la même façon que les tableaux simples (pour plus de détails, consultez le [type Tableau](../Motscles/1514030.md)).

Lors de copies d'instances de classes, tous les membres de la classe sont recopiés dans la nouvelle instance, sauf les tableaux. Ainsi, si la valeur d'un membre de type tableau est modifiée, cette valeur est modifiée dans toutes les instances.

**Pour obtenir des tableaux indépendants dans toutes les instances de classes**, il est nécessaire de déclarer un tableau local de la manière suivante :

```txt
ClasseSystème est une Classe
	TableauDéfaut est un tableau local de 1 entier
FIN
```

 
Remarque : Pour obtenir des tableaux indépendants dans toutes les instances de classes : 

1. Affichez la fenêtre de description du projet : sous le volet "Projet", dans le groupe "Projet", cliquez sur "Description". 

2. Dans l'onglet "Compilation", cochez l'option "Tableaux : l'affectation copie le contenu". 


Pour plus de détails, consultez [Description projet, onglet compilation](../Editeurs/9500218.md).
<a name="NOTE4_4"></a>


### Sérialisation des membres d'une classe
<a name="serialisation_des_membres_une_classe_ELTPARAGRAPHE000251"></a>Par défaut, tous les membres d'une classe sont sérialisés. 

Il est possible de gérer précisément la sérialisation de chaque membre d'une classe : 

- en indiquant quel membre sera sérialisé lors de l'appel à la fonction [Sérialise](../WDLang1/3013065.md). 
	Cette opération est possible sur tous les types de sérialisation (WXML, JSON, binaire). 

- en changeant le nom du membre lors de la sérialisation par la fonction [Sérialise](../WDLang1/3013065.md).  
	Cette opération n'est pas possible lors d'une sérialisation binaire. 




Cette gestion de la sérialisation est réalisée en utilisant la syntaxe suivante : 

- Sérialisation ou non d'un membre : 
	
	```txt
	<Nom du membre> est un <Type du membre> [ = <Valeur initiale>] 
	[, Sérialise = <Vrai/Faux>]
	```


- Sérialisation et changement du nom d'un membre : 
	
	```txt
	<Nom du membre> est un <Type du membre> [ = <Valeur initiale>] 
	[, Sérialise = <Nouveau nom>]
	```



Exemple : 

```wl
Cl est une Classe
	// Membre sérialisé
	MembreSérialisé est un entier 
	// Membre non sérialisé
	MembreNonSérialisé est une chaîne, Sérialise = Faux  
	// Membre renommé lors de la sérialisation
	MembreRenommé est un entier, Sérialise = "NouveauNomMembre" 
FIN
```

<a name="NOTE4_5"></a>


### Data binding
<a name="data_binding_ELTPARAGRAPHE000285"></a>Le Data binding est disponible sur les membres de la classe. 

<a name="NOTE5"></a>
<a name="NOTE5_1"></a>


## Déclaration des constantes de la classe
<a name="declaration_des_constantes_classe_ELTTEXTE000951"></a>


### Syntaxe
<a name="syntaxe_ELTPARAGRAPHE000314"></a>
```txt
CONSTANT <Nom de la constante> = <Valeur de la constante>

CONSTANT 
	<Nom de la constante> = <Valeur de la constante>
	<Nom de la constante> = <Valeur de la constante>
FIN
```

<a name="NOTE5_2"></a>


### Détail de la syntaxe
<a name="detail_syntaxe_ELTPARAGRAPHE000321"></a>**&lt;Nom de la constante&gt;**
Nom défini pour la constante. Une constante est publique.

**&lt;Valeur de la constante&gt;**
Valeur associée à la constante. Cette valeur ne variera pas au cours du programme.<a name="NOTE5_3"></a>


### Exemple
<a name="exemple_ELTPARAGRAPHE000336"></a>
```wl
CONSTANT K=5
CONSTANT 
	K=5
	J=10
FIN
```


<a name="NOTE6_Singleton"></a>
<a name="NOTE6_1_Singleton"></a>


## Déclaration d'un singleton
<a name="declaration_singleton_ELTTEXTE000987"></a>
Un **Singleton** est une déclaration d'une instance unique de classe. 

Pour déclarer une instance unique d'une classe et pour l'allouer immédiatement, il est possible d'utiliser la syntaxe suivante :

```txt
<Nom classe singleton> est une Classe
GLOBAL
	<Nom instance> est <Nom classe singleton>
FIN
```
**Exemple**

```wl
CSingleton est une Classe
GLOBAL
	m_Singleton est CSingleton
FIN
```


<a name="NOTE6"></a>
<a name="NOTE6_1"></a>


## Création et déclaration des méthodes de classes
<a name="creation_declaration_des_methodes_classes_ELTTEXTE001011"></a>


### Création d'une méthode de classe
<a name="creation_une_methode_classe_ELTPARAGRAPHE000358"></a>Pour créer une méthode de classe :

1. Affichez si nécessaire le volet "Explorateur de projet" : sous le volet "Accueil", dans le groupe "Environnement", déroulez "Volets" puis sélectionnez "Explorateur de projet"..

2. Dans le volet "Explorateur de projet", affichez les différentes classes disponibles : il suffit de dérouler le dossier "Classes".

3. Sélectionnez la classe voulue. Affichez le menu contextuel de la classe (clic droit) puis sélectionnez l'option "Nouvelle méthode".

4. Dans la fenêtre qui s'ouvre :

	- Saisissez le nom de la méthode.

	- Indiquez si le commentaire du prototype de la méthode doit être généré automatiquement (option "Générer un commentaire d'en-tête").
			Pour plus de détails sur les commentaires générés automatiquement, consultez [Documentation automatique des procédures et des méthodes](../Motscles/1513006.md).

	- Indiquez si la méthode est publique, protégée ou privée. Pour plus de détails, consultez la partie "**Accès**" du [Détail de la syntaxe](#NOTE6_3).

	- Indiquez si la méthode est abstraite. Pour plus de détails, consultez la partie "**Abstraite**" du [Détail de la syntaxe](#NOTE6_3).

	- Indiquez si la méthode est globale. Pour plus de détails, consultez la partie "**Globale**" du [Détail de la syntaxe](#NOTE6_3).

	- Validez.




5. L'éditeur de code affiche le code de la nouvelle méthode.



<a name="NOTE6_2"></a>


### Syntaxe de déclaration d'une méthode
<a name="syntaxe_declaration_une_methode_ELTPARAGRAPHE000406"></a>
```txt
PROCEDURE [<Accès>] [Globale] [VIRTUELLE] [ABSTRAITE] 
	<Nom de la méthode> ([<Paramètre1>, ...[<ParamètreN>]]) [<Attributs d'extension>]
```

<a name="NOTE6_3"></a>


### Détail de la syntaxe
<a name="detail_syntaxe_ELTPARAGRAPHE000413"></a>**&lt;Accès&gt; : Optionnel**

Permet de restreindre l'accès à cette méthode. 3 niveaux sont disponibles : 

- **Privé** : la méthode peut être appelée uniquement depuis un code de la classe

- **Protégé** : la méthode peut être appelée uniquement depuis un code de la classe ou un code d'une classe dérivée

- **Public** (par défaut) : la méthode peut être appelée depuis n'importe quel code de la classe ou du projet.




**Globale : Optionnel**

Définit une méthode globale. Cette méthode ne travaillera pas sur un objet particulier : il n'est pas nécessaire de disposer d'un objet de la classe pour appeler cette méthode. Cette classe permet aussi de manipuler les membres globaux.

**Virtuelle : Optionnel**

Définit une méthode virtuelle. Par défaut, une méthode redéfinie est virtuelle.

**Abstraite : Optionnel**

Définit une méthode abstraite. Une méthode abstraite est une méthode qui doit obligatoirement être redéfinie dans les classes dérivées. Par défaut, une méthode n'est pas abstraite. 

**&lt;Nom de la méthode&gt;**

Nom identifiant la méthode.

**&lt;Paramètre 1&gt; ... &lt;Paramètre N&gt;**

Paramètres optionnels à passer à la méthode.

**&lt;Attribut d'extension&gt;**

Attributs d'extension permettant de définir des options de gestion de l'éditeur de code. Les attributs d'extension disponibles sont : 

- &lt;zombie [commentaire = "texte"]&gt; : Permet de définir une méthode obsolète (également appelée méthode zombie). Le mot-clé optionnel **commentaire** permet d'indiquer le texte qui sera affiché dans l'erreur de compilation associée à la méthode obsolète. Pour plus de détails, consultez [Procédures zombies](../Motscles/1513008.md).

- &lt;sans pas à pas&gt; : Permet d'indiquer que cette méthode sera ignorée par le débogueur lors d'un débogage en mode "Pas à pas".  



```wl
PROCEDURE GLOBALE VoirObjet(obj)
// Le membre privé TailleClasse est accessible depuis le code de la classe
Info("Nom : " + Obj:Nom + "Taille : " + Obj:TailleClasse)
```



```wl
FONCTION GLOBALE Essai(a1,b1)
RENVOYER a1 + b1
```

<a name="NOTE6_4"></a>
<a name="NOTE6_5"></a>


### Suppression d'une méthode
<a name="suppression_une_methode_ELTPARAGRAPHE000500"></a>Une méthode peut être supprimée : 

- directement depuis le volet "Explorateur de projet" (option "Supprimer" du menu contextuel)

- depuis l'éditeur de code, par le menu contextuel du bandeau de la méthode (option "Supprimer"). 




<a name="NOTE7"></a>
<a name="NOTE7_1"></a>


## Création et déclaration des propriétés
<a name="creation_declaration_des_proprietes_ELTTEXTE001059"></a>


### Présentation
<a name="presentation_ELTPARAGRAPHE000514"></a>Une propriété est un élément de code possédant deux événements : 

- un événement de récupération de la valeur,

- un événement d'affectation de la valeur.




Une propriété peut être utilisée comme une variable ou un membre (récupération directe de la valeur, affectation par le symbole '=', ...). Lors de l'exécution :

- Toute opération nécessitant la lecture de la propriété exécute l'événement de récupération de la valeur. Cet événement doit renvoyer une valeur.

- Toute opération nécessitant l'écriture de la propriété exécute l'événement d'affectation de la valeur. Cet événement doit traiter un paramètre.




![Universal Windows 10 App](https://doc.pcsoft.fr/ext/images/fr/UNIVERSALAPP.png) Les propriétés de classes ne sont pas disponibles.
<a name="NOTE7_2"></a>


### Création d'une propriété de classe
<a name="creation_une_propriete_classe_ELTPARAGRAPHE000533"></a>Pour créer une propriété de classe :

1. Affichez si nécessaire le volet "Explorateur de projet" : sous le volet "Accueil", dans le groupe "Environnement", déroulez "Volets" puis sélectionnez "Explorateur de projet".

2. Dans le volet "Explorateur de projet", affichez les différentes classes disponibles (déroulez le dossier "Classes").

3. Sélectionnez la classe voulue. Affichez le menu contextuel de la classe et sélectionnez l'option "Nouvelle propriété".

4. Saisissez le nom de la propriété dans la fenêtre qui s'ouvre et validez.

5. L'éditeur de code affiche les événements liés à la propriété :

	- Evénement de récupération de la propriété. Cet événement contient : 

		- soit le mot-clé "RENVOYER" qui permet d'obtenir la valeur de la propriété.

		- soit le mot-clé "RETOUR =" pour renvoyer la valeur de la propriété.




- Evénement d'affectation de la propriété. Cet événement permet de donner une valeur à la propriété. Cette valeur est passée en paramètre. Cet événement ne doit pas renvoyer de résultat.




**Remarque** : Une nouvelle propriété peut également être créée depuis le menu contextuel d'un membre. Les procédures manipulent alors automatiquement le membre spécifié.
<a name="NOTE7_3"></a>


### Data binding
<a name="data_binding_ELTPARAGRAPHE000566"></a>Le Data binding est disponible sur les propriétés des classes et des membres de classes.
<a name="NOTE7_4"></a>


### Droits d'accès à une propriété
<a name="droits_acces_une_propriete_ELTPARAGRAPHE000573"></a>Si l'événement de récupération est vide, la lecture de la propriété est interdite. Une erreur de compilation apparaîtra sous l'éditeur et une erreur se produira également en exécution.

Si l'événement d'affectation est vide, l'écriture de la propriété est interdite. Une erreur de compilation apparaîtra sous l'éditeur et une erreur se produira également en exécution. 

Les événements de récupération et d'affectation peuvent être publics, privés ou protégés. Les droits d'accès de la propriété correspondent aux droits les moins restrictifs des deux événements. Pour plus de détails, consultez [Droits d'accès à une propriété](../POO/6010011.md).

Les propriétés peuvent être globales. Une propriété est globale à la classe lorsque les événements de récupération et d'affectation sont globaux. Si l'un des événements est global, tous les événements doivent l'être sinon une erreur de compilation est affichée.
<a name="NOTE7_5"></a>


### Membres et propriétés
<a name="membres_proprietes_ELTPARAGRAPHE000589"></a>Une propriété peut avoir le même nom qu'un membre déjà existant. Dans ce cas, les ordres de priorité sont les suivants :

- dans les événements de la propriété, le membre est prioritaire sur la propriété.

- dans tout le reste du code, la propriété est prioritaire sur le membre.




Ainsi, il est possible de remplacer un membre par une propriété sans aucune modification du code utilisant le membre.

Les événements d'une propriété ne peuvent pas utiliser récursivement la propriété. S'il n'existe pas de membre du même nom que la propriété, l'utilisation de la propriété dans un de ses événements provoquera une erreur de compilation.
<a name="NOTE7_6"></a>


### Héritage
<a name="heritage_ELTPARAGRAPHE000603"></a>Les propriétés des classes de base sont héritées dans les classes dérivées.

Une propriété peut être surchargée dans une classe dérivée. Les événements d'une propriété sont toujours considérés comme virtuels : l'utilisation du mot-clé VIRTUEL est inutile et ignorée.

L'héritage multiple est supporté sur les propriétés. Il est possible d'appeler les propriétés des classes de base grâce aux syntaxes :

- ***Ancêtre.Propriété*** si la classe dérivée n'a qu'une seule classe de base

- ***ClasseDeBase.Propriété*** dans tous les cas.



<a name="NOTE7_7"></a>


### Passage de propriétés en paramètre à une fonction ou procédure WLangage
<a name="passage_proprietes_parametre_une_fonction_procedure_wlangage_ELTPARAGRAPHE000617"></a>**Si le paramètre est passé par référence (cas par défaut) et non typé** : 

- la propriété est passée en paramètre.

- aucun événement associé à la propriété n'est exécuté au moment de l'appel.

- la lecture du paramètre formel exécute le code de récupération de la valeur.

- l'écriture du paramètre formel exécute le code d'affectation de la valeur.




**Si le paramètre est passé par valeur (LOCAL) et non typé** : 

- la valeur de la propriété est passée en paramètre.

- le code de récupération de la valeur est exécuté au moment de l'appel.

- la lecture du paramètre formel accède à la valeur passée au moment de l'appel et n'exécute pas le code de récupération de la valeur. 

- l'écriture du paramètre formel modifie la valeur passée au moment de l'appel et n'exécute pas le code d'affectation de la valeur. 




**Si le paramètre est passé par référence (cas par défaut) et typé** : 

- la propriété est passée en paramètre.

- le type de la propriété doit être correct. Dans le cas contraire, une erreur WLangage est affichée.

- aucun événement associé à la propriété n'est exécuté au moment de l'appel.

- la lecture du paramètre formel exécute le code de récupération de la valeur.

- l'écriture du paramètre formel exécute le code d'affectation de la valeur.




**Si le paramètre est passé par valeur (LOCAL) et typé** : 

- la valeur de la propriété est passée en paramètre.

- le code de récupération de la valeur est exécuté au moment de l'appel.

- si nécessaire, la valeur de la propriété est convertie dans le type du paramètre.

- la lecture du paramètre formel accède à la valeur passée au moment de l'appel et n'exécute pas le code de récupération de la valeur. 

- l'écriture du paramètre formel modifie la valeur passée au moment de l'appel et n'exécute pas le code d'affectation de la valeur. 




<a name="NOTE8"></a>
<a name="NOTE8_1"></a>


## Instances de classe à contexte HFSQL indépendant
<a name="instances_classe_contexte_hfsql_independant_ELTTEXTE001119"></a>


### Présentation
<a name="presentation_ELTPARAGRAPHE000655"></a>Il est possible d'associer une copie du contexte HFSQL à une instance de classe. Tous les accès à HFSQL effectués depuis les méthodes et les propriétés de la classe (appels de fonctions ou accès aux enregistrements) opèrent sur la copie du contexte de l'instance de la classe.
![Universal Windows 10 App](https://doc.pcsoft.fr/ext/images/fr/UNIVERSALAPP.png)![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Cette fonctionnalité n'est pas disponible.
<a name="NOTE8_2"></a>


### Syntaxe
<a name="syntaxe_ELTPARAGRAPHE000666"></a>La syntaxe à utiliser est la suivante :

```txt
// Déclaration de la classe
ClasseHFSQLIndépendant est une Classe, contexte HFSQL indépendant [<léger/complet>]
FIN
```
ou

```txt
// Déclaration de la classe
ClasseHFSQLIndépendant est une Classe
	<contexte HFSQL indépendant léger/complet>

FIN
```
Par exemple : 

```wl
ClasseHFSQLIndépendant est une Classe, contexte HFSQL indépendant léger
```


Paramètre **léger/complet** : 

- Le mot-clé "léger" provoque la copie immédiate d'une partie du contexte HFSQL. 
	Seuls les répertoires où se trouvent les fichiers de données en HFSQL Classic et/ou les connexions en HFSQL Client/Serveur sont mémorisés. 

- Le mot-clé "complet" provoque la copie immédiate du contexte HFSQL.
	Conseillé par exemple si le thread doit tenir compte des positions en cours dans les fichiers et requêtes du contexte de l'appelant.



<a name="NOTE8_3"></a>


### Utilisation
<a name="utilisation_ELTPARAGRAPHE000689"></a>Le contexte HFSQL de l'instance est créé par copie du contexte courant lors de l'exécution du constructeur.

Les opérateurs **=** et **&lt;=** entre deux instances à contexte HFSQL indépendant recopient le contenu du contexte HFSQL.

Il est déconseillé d'utiliser des instances de classes à contexte HFSQL indépendant pour simuler un alias sur un seul fichier HFSQL ou sur un enregistrement particulier d'un fichier HFSQL. La copie du contexte HFSQL porte en effet sur tous les éléments (les fichiers, vues, requêtes, connexions, ...) du contexte et peut donc être très coûteuse en temps.

Une instance de classe à contexte HFSQL indépendant peut être utilisée uniquement dans le thread qui a exécuté le constructeur. Pour manipuler une instance de classe à contexte HFSQL indépendant dans plusieurs threads, il est nécessaire :

- d'allouer une nouvelle instance de la classe,

- de faire une copie de l'instance d'origine grâce à l'opérateur **=** ou **&lt;=**.




<a name="NOTE9"></a>
<a name="NOTE9_1"></a>


## Notes
<a name="notes_ELTTEXTE001161"></a>


### Légende des icônes utilisées
<a name="legende_des_icones_utilisees_ELTPARAGRAPHE000706"></a>Les différentes icônes utilisées sont les suivantes :


|   |   |
| --- | --- |
| <br>![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=ProcedurePublique.gif)<br> | Procédure publique |
| <br>![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=ProcedureProtegee.gif)<br> | Procédure protégée |
| <br>![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=ProcedurePrivee.gif)<br> | Procédure privée |
| <br>![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=MethVirtPublique.gif)<br> | Méthode virtuelle publique |
| <br>![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=MethVirtProtegee.gif)<br> | Méthode virtuelle protégée |
| <br>![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=MethVirtPrivee.gif)<br> | Méthode virtuelle privée |
| <br>![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=MethStatPublique.gif)<br> | Méthode globale publique |
| <br>![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=MethStatProtegee.gif)<br> | Méthode globale protégée |
| <br>![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=MethStatPrivee.gif)<br> | Méthode globale privée |
| <br>![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=Constante.gif)<br> | Constante |


<a name="NOTE9_2"></a>


### Nouveautés depuis la version 9
<a name="nouveautes_depuis_version_9_ELTPARAGRAPHE000754"></a>Une classe contenant un membre de type caractère n'a pas le même comportement que dans les versions précédentes. En effet, les caractères occupaient 1 octet dans les versions précédentes et 2 octets à partir de la version 9.

Il est conseillé d'utiliser le type "Entier sur un octet" pour assurer un bon fonctionnement.


- ![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=WDPOOSimple.gif) ***Exemples didactiques (WINDEV)*** : **WD POO Simple** <br>L'exemple "WD POO Simple" est un exemple didactique sur la POO avec WINDEV. Cet exemple permet de voir le fonctionnement :<br>- des classes, <br>- des héritages,<br>- des procédures virtuelles,<br>- des diagrammes UML,<br>- ...


