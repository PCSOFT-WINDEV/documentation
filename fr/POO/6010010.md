
## Utilisation des objets
			



<a name="NOTE1"></a>
<a name="NOTE1_1"></a>


## Présentation
<a name="presentation_ELTTEXTE000378"></a>
Pour accéder à une classe, il faut déclarer **l'objet** comme étant de la classe à manipuler, on parle d' **instanciation d'un objet**.

Une instance est un objet qui appartient à une classe donnée.

Remarque : Pour récupérer l'instance de l'objet en cours dans les méthodes de la classe, utilisez le mot-clé **objet** ou le mot-clé *this*.

Cette page d'aide présente :

- [comment manipuler les membres d'un objet](#NOTE3_1).

- [comment manipuler les méthodes d'un objet](#NOTE4_1).

- [l'affectation des classes](#NOTE5_1).






<a name="NOTE3"></a>
<a name="NOTE3_1"></a>


## Manipuler les membres d'un objet
<a name="manipuler_les_membres_objet_ELTTEXTE000402"></a>


### Présentation
<a name="presentation_ELTPARAGRAPHE000055"></a>Un membre d'un objet est une donnée associée à l'objet. Un objet possède nécessairement tous les membres décrits dans la classe. Un membre est également appelé **propriété de l'objet**.

Les membres d'un objet correspondent à tous les membres définis pour la classe d'origine de l'objet.

Rappel : un membre est déclaré dans la classe.


<a name="NOTE3_2"></a>


### Appeler un membre appartenant à un objet différent de l'objet en cours
<a name="appeler_membre_appartenant_objet_different_objet_cours_ELTPARAGRAPHE000067"></a>Pour appeler un membre appartenant à un objet différent de l'objet en cours, la syntaxe à utiliser est :


```txt
<Nom Objet> . <Nom Membre>
```



```txt
<Nom Objet> : <Nom Membre>
```


Le membre est recherché parmi les membres de la classe de l'objet. Si le membre n'est pas trouvé, il est recherché parmi les membres des classes ancêtres de la classe de l'objet.


<a name="NOTE3_3"></a>


### Appeler un membre de l'objet en cours
<a name="appeler_membre_objet_cours_ELTPARAGRAPHE000081"></a>Pour appeler un membre de l'objet en cours, deux syntaxes sont disponibles :

- **Syntaxe simplifiée**, disponible uniquement si vous activez l'option "Classes : préfixes ":" et "::" d'accès aux membres et aux méthodes facultatifs" (cette option est activée par défaut sur les nouveaux projets) :
	
	```txt
	<Nom Membre>
	```


- **Syntaxe complète** (toujours disponible) :
	
	```txt
	:<Nom Membre>
	```




<a name="NOTE3_4"></a>


### Appeler un membre d'une classe ancêtre qui a été redéfinie
<a name="appeler_membre_une_classe_ancetre_qui_ete_redefinie_ELTPARAGRAPHE000095"></a>Pour appeler un membre appartenant à une classe ancêtre qui a été redéfinie, la syntaxe à utiliser est :


```txt
<Nom Objet> . <Nom de la classe> . <Nom Membre>
```



```txt
<Nom Objet> : <Nom de la classe> :: <Nom Membre>
```



<a name="NOTE3_5"></a>


### Appeler un membre de classe générale
<a name="appeler_membre_classe_generale_ELTPARAGRAPHE000107"></a>Pour appeler un membre appartenant à une classe générale, la syntaxe à utiliser est :


```txt
<Nom de la classe> . <Nom Membre>
```



```txt
<Nom de la classe> :: <Nom Membre>
```



<a name="NOTE3_6"></a>


### Remarque
<a name="remarque_ELTPARAGRAPHE000119"></a>Il est possible d'enchaîner les accès aux membres. Par exemple :


```wl
// Enchaînements de membres 
MonObjet.Membre1[1]:Membre2:Membre3
```




<a name="NOTE4"></a>
<a name="NOTE4_1"></a>


## Manipuler les méthodes d'un objet
<a name="manipuler_les_methodes_objet_ELTTEXTE000456"></a>


### Présentation
<a name="presentation_ELTPARAGRAPHE000131"></a>Les méthodes d'un objet sont des fonctionnalités associées à l'objet. Un objet possède nécessairement toutes les méthodes décrites dans la classe. Ces méthodes peuvent être appelées de différentes façons selon le lieu de l'appel.


<a name="NOTE4_2"></a>


### Appeler une méthode appartenant à un objet différent de l'objet en cours
<a name="appeler_une_methode_appartenant_objet_different_objet_cours_ELTPARAGRAPHE000139"></a>Pour appeler une méthode appartenant à un objet différent de l'objet en cours, la syntaxe à utiliser est :


```txt
<Nom Objet> . <Nom Méthode> ([<Paramètres>])
```



```txt
<Nom Objet> : <Nom Méthode> ([<Paramètres>])
```


La méthode est recherchée parmi les méthodes de la classe de l'objet. Si la méthode n'est pas trouvée, elle est recherchée parmi les méthodes des classes ancêtres de la classe de l'objet.


<a name="NOTE4_3"></a>


### Appeler une méthode de l'objet en cours
<a name="appeler_une_methode_objet_cours_ELTPARAGRAPHE000153"></a>Pour appeler une méthode appartenant à l'objet en cours, la syntaxe à utiliser est :


```txt
. <Nom Méthode> ([<Paramètres>])
```


**Remarque** : Par compatibilité avec les versions précédentes, il est possible d'utiliser la syntaxe ":&lt;Nom méthode&gt;([&lt;Paramètres&gt;])". Pour utiliser cette syntaxe, décochez l'option "Classes : préfixes ":" et "::" d'accès aux membres et aux méthodes facultatifs".


<a name="NOTE4_4"></a>


### Appeler une méthode d'une classe ancêtre qui a été redéfinie
<a name="appeler_une_methode_une_classe_ancetre_qui_ete_redefinie_ELTPARAGRAPHE000171"></a>Pour appeler une méthode d'une classe ancêtre qui a été redéfinie, la syntaxe à utiliser est :


```txt
<Nom Objet> . <Nom Classe> . <Nom Méthode> ([<Paramètres>])
```



```txt
<Nom Objet> : <Nom Classe> :: <Nom Méthode> ([<Paramètres>])
```



<a name="NOTE4_5"></a>


### Appeler une méthode de classe générale
<a name="appeler_une_methode_classe_generale_ELTPARAGRAPHE000183"></a>Pour appeler une méthode d'une classe générale, la syntaxe à utiliser est :


```txt
<Nom Classe> . <Nom Méthode> ([<Paramètres>])
```



```txt
<Nom Classe> :: <Nom Méthode> ([<Paramètres>])
```



<a name="NOTE4_6"></a>


### Exemple
<a name="exemple_ELTPARAGRAPHE000195"></a>
```wl
FichierS est un CFichier
FichierD est un CFichier
ch1,ch2 sont des chaînes

// Appel de la méthode de sélection d'un fichier
FichierS.SélectionFichier()
FichierD.SélectionFichier()

// Appel de la méthode de vérification de l'espace disponible
SI FichierS.EspaceRestant(FichierD.Repertoire[[1]]) ALORS
	ch1 = FichierS:Repertoire + "\" + FichierS:Nom + "." + FichierS:Extension
	ch2 = FichierD:Repertoire + "\" + FichierD:Nom + "." + FichierD:Extension
	fCopieFichier(ch1, ch2)
SINON
	Erreur("Espace insuffisant")
FIN
```



<a name="NOTE4_7"></a>


### Remarque
<a name="remarque_ELTPARAGRAPHE000203"></a>Il est possible d'enchaîner les appels de méthodes. Par exemple :


```wl
// Enchaînements d'accès .NET
ObjetNET.Méthode1().Membre2[n].Méthode3()

// Méthode qui alloue et renvoie une classe enchaînée avec un appel
ObjetClasse.AlloueOpérateur().EffectueOpération()
```




<a name="NOTE5"></a>
<a name="NOTE5_1"></a>


## Affectation des objets
<a name="affectation_des_objets_ELTTEXTE000516"></a>


### Règles d'affectation
<a name="regles_affectation_ELTPARAGRAPHE000215"></a>Les règles d'affectation entre des objets et entre des objets dynamiques sont les suivantes :

- **Opérateur =** : Copie ou prise de référence
	


|   |   |   |
| --- | --- | --- |
|   | **Opérateur =** |
|   | Objet | Objet dynamique |
| Objet | Copie | Copie |
| Objet dynamique | Prise de référence | Prise de référence |



- **Opérateur &lt;=** : Copie
	


|   |   |   |
| --- | --- | --- |
|   | **Opérateur &lt;=** |
|   | Objet | Objet dynamique |
| Objet | Copie | Copie |
| Objet dynamique | Copie | Copie |






Note : Pour les membres déclarés comme "XXX dynamique", l'opérateur &lt;= fait une copie de la référence, on a donc le même objet après l'affectation.

- **Opérateur &lt;-** : Prise de référence
	


|   |   |   |
| --- | --- | --- |
|   | **Opérateur &lt;-** |
|   | Objet | Objet dynamique |
| Objet | Prise de référence | Prise de référence |
| Objet dynamique | Prise de référence | Prise de référence |







### Détails et exemples
<a name="details_exemples_ELTPARAGRAPHE000287"></a>

- **Affectation entre deux objets** :
	
	```wl
	O1, O2 sont des Classe
	// Opérateur = fait une copie de membre
	O1 = O2
	// Opérateur
	```


	- **L'opérateur = et l'opérateur &lt;=** permettent de faire une copie de membres. Dans ce cas, tous les membres sont recopiés dans l'instance O1.

	- Cas particulier des tableaux : Seuls les tableaux locaux sont recopiés. Les tableaux non locaux utilisent tous la même instance. Cette remarque ne concerne pas les tableaux associatifs. 

	- **L'opérateur &lt;-** permet de prendre une référence sur l'objet passé en opérande.




- **Affectation entre deux objets dynamiques** :
	
	```wl
	pO1 est une Classe dynamique
	pO2 est une Classe dynamique
	// Opérateur = fait une prise de référence
	pO1 = pO2
	// Opérateur
	```


	- **L'opérateur = et l'opérateur &lt;-** permettent de faire une prise de référence. Dans ce cas, la variable dynamique pO1 utilise l'objet pO2.

	- **L'opérateur &lt;=** permet de faire une copie de membres. Dans ce cas, tous les membres sont recopiés dans l'instance pO1.

	- Pour permettre la copie avec **l'opérateur &lt;=**, les variables dynamiques p01 et p02 doivent être allouées, et déclarées de même type.




- **Affectation entre deux objets (dynamique et non dynamique)** :
	
	```wl
	O1 est une Classe
	pO1 est une Classe dynamique
	// Opérateur = permettant de faire une prise de référence
	// La variable dynamique pO1 utilise l'objet O1
	pO1 = O1
	
	// Opérateur = permettant de faire une copie de membres
	// Tous les membres sont recopiés dans l'instance O1
	O1 = pO1
	```


	- Selon l'ordre des opérandes, l'opérateur = permet de réaliser une copie de membres ou de faire une prise de référence.

	- Pour simplifier ces syntaxes, il est conseillé d'utiliser les opérateurs &lt;= et &lt;- :

		- l'opérateur &lt;= permet de faire dans tous les cas une copie de membres. Pour les membres déclarés comme "XXX dynamique", l'opérateur &lt;= fait une copie de la référence, on a donc le même objet après l'affectation.

		- l'opérateur &lt;- permet de faire dans tous les cas une prise de référence.
						
			```wl
			O1 est une Classe
			pO1 est une Classe dynamique
			
			// Opérateur <- : prise de référence
			// La variable dynamique pO1 pointe sur l'objet O1
			p01 <- O1
			
			// Opérateur <= : copie des membres
			// Tous les membres sont recopiés dans l'instance pO1
			pO1 <= O1
			```







<a name="NOTE5_2"></a>


### Instances de classes et tableaux
<a name="instances_classes_tableaux_ELTPARAGRAPHE000318"></a>Lors de copies d'instances de classes, tous les membres de la classe sont recopiés dans la nouvelle instance, sauf les tableaux. Ainsi, si la valeur d'un membre de type tableau est modifiée, cette valeur est modifiée dans toutes les instances. 

Pour obtenir des tableaux indépendants dans toutes les instances de classes, il est nécessaire de déclarer un tableau local de la manière suivante :


```wl
ClasseSystème est une Classe
	tTableauDéfaut est un tableau local de 1 entier
FIN
```


Les tableaux associatifs, les piles et les files ne peuvent pas être déclarés en local. Lors des copies d'instances, les tableaux associatifs, files et piles sont automatiquement recopiés. 

Pour plus de détails sur l'instanciation, consultez [Instanciation d'un objet](../POO/6010002.md). 


