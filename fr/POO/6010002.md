
## Instanciation d'un objet
			



<a name="NOTE1"></a>
<a name="NOTE1_1"></a>


## Présentation d'un objet
<a name="presentation_objet_ELTTEXTE000227"></a>
Pour accéder à une classe, il faut déclarer **l'objet** comme étant de la classe à manipuler, on parle d' **instanciation d'un objet**.

Une instance est un objet qui appartient à une classe donnée.

**Pour manipuler un objet**, il faut : 

1. Décrire la classe.

2. Instancier l'objet.




Un objet peut être passé en paramètre à une fonction ou à une procédure.

**Remarque** : Il est possible d'instancier dynamiquement un objet à une classe. La mise en oeuvre du polymorphisme requiert l'instanciation dynamique. Pour plus de détails, consultez [Instanciation dynamique](../POO/6010003.md).

Exemple d'objet : "FichierSource" est un objet de la classe "Fichier". Pour cet objet, il est possible de manipuler les membres "Nom", "Extension", etc.


```wl
FichierSource est un objet Fichier

FichierSource est un Fichier
```




<a name="NOTE2"></a>
<a name="NOTE2_1"></a>


## Syntaxe de déclaration / d'instanciation d'un objet
<a name="syntaxe_declaration_instanciation_objet_ELTTEXTE000251"></a>


### Déclaration/instanciation d'un objet
<a name="declarationinstanciation_objet_ELTPARAGRAPHE000057"></a>
```txt
<NomObjet> est [un] [objet] <Nom Classe> ([<Paramètres>])
```


**Détail de la syntaxe**

**&lt;NomObjet&gt;**

Nom identifiant l'instance de la classe.

**&lt;Nom Classe&gt;**

Nom identifiant la classe, défini lors de la création de la classe sous l'éditeur de code.

**&lt;Paramètres&gt;**

Paramètres optionnels du constructeur. Pour plus de détails, consultez [Méthode constructeur](../POO/6010001.md).


<a name="NOTE2_2"></a>


### Déclaration / instanciation d'un objet Null
<a name="declaration_instanciation_objet_null_ELTPARAGRAPHE000082"></a>
```txt
<NomObjet> est [un] [objet] <Nom Classe> ([<Paramètres>]) = NULL
```


Cette syntaxe permet de déclarer un objet sans l'instancier. Dans ce cas :

- l'opérateur &lt;- permet de prendre une référence sur l'objet.

- la variable déclarée se comporte comme si la déclaration était non dynamique : l'opérateur = effectue une copie des membres.

- l'objet manipulé peut être renvoyé comme valeur de retour de la procédure ou de la méthode.

- dans certains cas avancés, l'objet manipulé peut être détruit pour anticiper la destruction automatique.





<a name="NOTE2_3"></a>


### Remarque : Objet en cours
<a name="remarque_objet_cours_ELTPARAGRAPHE000097"></a>Le mot-clé **Objet** peut également être utilisé pour désigner l'objet en cours.

Il est également possible d'utiliser le mot-clé **This** pour accéder à l'objet en cours.


<a name="NOTE2_4"></a>


### Membres et méthodes
<a name="membres_methodes_ELTPARAGRAPHE000109"></a>Pour plus de détails sur les membres et les méthodes, consultez [Utilisation d'un objet](../POO/6010010.md).



<a name="NOTE3"></a>
<a name="NOTE3_1"></a>


## Durée de vie d'un objet
<a name="duree_vie_objet_ELTTEXTE000293"></a>


### Référence sur un objet local
<a name="reference_sur_objet_local_ELTPARAGRAPHE000122"></a>L'objet est créé lors de sa déclaration. Par défaut, l'objet est local.

Les objets locaux ne sont pas automatiquement détruits à la fin de l'exécution du traitement. **Seule la référence locale est libérée.**

Ainsi, si une autre référence a été prise sur l'objet, l'objet ne sera pas détruit lors de la libération de la référence locale.

Exemple :


```wl
// Code de déclaration des globales
gpo est Classe1 dynamique
gTab est un tableau de Classe1 dynamique

// Code quelconque
o1, o2, o3 sont Classe1
gpo1 = o1
Ajoute(gTab, o2)

// A la fin du traitement
// o1 n'est pas détruit car il est référencé par la variable globale gpo
// o2 est pas détruit car il a été ajouté au tableau gTab
// o3 est détruit car il n'y a que la référence locale
```



<a name="NOTE3_2"></a>


### Renvoyer un objet
<a name="renvoyer_objet_ELTPARAGRAPHE000138"></a>Il est possible de renvoyer un objet manipulé par une variable locale dynamique ou non dynamique.

**Remarque** : Dans les versions précédentes, il était possible uniquement de renvoyer un objet manipulé par une variable locale dynamique.


<a name="NOTE3_3"></a>


### Objets dans les boucles
<a name="objets_dans_les_boucles_ELTPARAGRAPHE000148"></a>Dans une boucle, il est possible de manipuler des objets par des variables locales non dynamiques et sans allocation explicite.

Les objets déclarés dans une boucle sont réalloués à chaque itération de la boucle et la référence sur l'objet de l'itération précédente est libérée :

- si aucune autre référence n'a été prise, l'objet est détruit.

- si une référence a été prise (variable globale, ajout dans un tableau, ...), l'objet n'est pas détruit.




Exemple :


```wl
// on construit le tableau
t est un tableau de Classe1 dynamique
POUR i = 1 A 10
	// on crée un objet correspondant à l'indice
	o est Classe (x)
	o.m_nIndice = i
	// on ajoute l'objet dans le tableau
	Ajoute(t,o)
FIN
```



<a name="NOTE3_4"></a>


### Libération d'objet
<a name="liberation_objet_ELTPARAGRAPHE000165"></a>Les objets manipulés par des variables locales non dynamiques peuvent être détruits explicitement avec le mot-clé [LIBERER](../Motscles/1511012.md) pour anticiper la destruction automatique.

**Remarque** : Cette syntaxe est une syntaxe avancée à n'utiliser que dans des cas très particuliers. Dans la majorité des cas, la destruction est automatique.

**Rappel** : De manière générale, l'utilisation du mot-clé LIBERER est inutile. Le WLangage détruit automatiquement les objets qui ne sont plus utilisés par aucune variable. Les cas d'utilisation les plus courants sont :

- destruction d'une série d'objets qui se référencent de manière cyclique

- libération anticipée de ressources utilisées par l'instance (sockets, fichiers, ...) via l'exécution du destructeur.




![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) **Cas particulier en Java/Android**
La notion de destructeur n'existe pas en Java/Android. Le code situé dans le destructeur d'une classe ne sera par conséquent jamais exécuté. 
Un objet est libéré par le ramasse-miette (garbage collector) lorsqu'il n'est plus référencé dans l'application. Le moment où intervient cette libération n'est pas prévisible.
Pour forcer la libération d'un objet, il est possible de l'affecter à NULL ou d'utiliser l'instruction [Libérer](../Motscles/1511012.md).




