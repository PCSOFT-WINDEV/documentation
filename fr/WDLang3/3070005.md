
## SocketChangeModeTransmission (Fonction)

***En anglais : SocketChangeTransmissionMode***



<a name="XUtilisation"></a>
<a name="Utilisation"></a>
<a name="description"></a>
Change le mode de transmission utilisé sur un socket. Il est ainsi possible de définir le codage du message lors de la transmission. Les fonctions [SocketLit](../WDLang3/3070014.md) et [SocketEcrit](../WDLang3/3070002.md) utilisent le mode de transmission indiqué.

**Attention** : Le mode de transmission doit être identique sur le poste serveur et sur le poste client.

Remarques :

- ![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png) Si vous utilisez une application WINDEV sur le poste serveur et sur le poste client, le changement de mode de transmission doit être effectué sur le poste client **et** sur le poste serveur.

- **Sockets UDP** : Les sockets de type UDP sont toujours de type "Socket sans marqueur". La fonction **SocketChangeModeTransmission** ne doit pas être utilisée avec des sockets de type UDP. Le protocole UDP est un protocole non fiable : la chaîne envoyée avec la fonction [SocketEcrit](../WDLang3/3070002.md) peut ne pas arriver ou arriver plusieurs fois. L'ordre des chaînes envoyées n'est pas toujours respecté.


**Rappel** : Un socket est une ressource de communication utilisée par les applications pour communiquer d'une machine à une autre sans se soucier du type de réseau.






<a name="Exemple1"></a>
<a name="sample_code"></a>

## Exemple


```wl
// Mise en place du mode de transmission avec EOF comme marqueur de fin
SI SocketChangeModeTransmission("Serveur", SocketMarqueurFin) = Vrai ALORS
	Info("Mode de transmission modifié")
FIN
```


<a name="Exemple2"></a>



```wl
// Mise en place du mode de transmission avec CRLF comme marqueur de fin
SI SocketChangeModeTransmission(sNomSocket, SocketMarqueurFin, CRLF) = Faux ALORS
	RENVOYER Faux
FIN
```







<a name="XSYNTAXE"></a>
<a name="SYNTAXE1"></a>

## Syntaxe

`<Résultat> = SocketChangeModeTransmission(<Nom du socket> , <Type de transmission> [, <Option>])`
---

**`<Résultat> : (Booléen)`**



- <u><u><u><u>Vrai</u></u></u></u> si la fonction a réussi, 

- <u><u><u><u>Faux</u></u></u></u> dans le cas contraire (nom du socket invalide par exemple). En cas d'erreur, il est possible de connaître le détail de l'erreur grâce à la fonction [ErreurInfo](../WDLang1/3013008.md).




**`<Nom du socket> : (Chaîne de caractères)`**

Nom du socket défini sur le serveur. Ce nom a été défini :

- soit par la fonction [SocketCrée](../WDLang3/3070011.md) (cas d'un serveur simplifié WINDEV).

- soit par la fonction [SocketCréeInfraRouge](../WDLang3/3070012.md) (cas d'un serveur simplifié WINDEV Mobile).

- soit par la fonction [SocketAccepte](../WDLang3/3070004.md) (cas d'un serveur standard).

- soit par la fonction [SocketConnecte](../WDLang3/3070016.md) (cas d'un site WEBDEV).




![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png) Attention : le nom du socket est "case-sensitive".

**`<Type de transmission> : (Constante)`**

Type de transmission à adopter :


|   |   |
| --- | --- |
| *SocketMarqueurFin* | Permet de préciser un marqueur de fin dans le paramètre &lt;Option&gt;. <br>Si des éléments sont reçus après le marqueur de fin, une erreur WLangage est générée, indiquant que les marqueurs de fin ne sont pas respectés. <br>Par défaut, le marqueur de fin est la chaîne de caractères "&lt;EOF&gt;". <br>Message de la forme "Hello world&lt;EOF&gt;" |
| *SocketMarqueurFinBuffer* | Permet de préciser un marqueur de fin de buffer dans le paramètre &lt;Option&gt;. <br>Si des éléments sont reçus après le marqueur de fin, la chaîne reçue est lue jusqu'au marqueur de fin, l'excédent est conservé et reporté dans la prochaine lecture. <br>Par défaut, le marqueur de fin du buffer est la chaîne de caractères "&lt;EOF&gt;". |
| *SocketSansMarqueurFin* | Aucun marqueur n'est ajouté et/ou enlevé de la chaîne de caractères transmise. Dans ce cas, le nombre maximum d'octets pouvant être transmis peut être spécifié dans la fonction [SocketLit](../WDLang3/3070014.md). |
| *SocketTailleDébut*<br>(Valeur par défaut) | Le message est un buffer de la forme : <br><br><pre><code><Longueur>+RC+<Chaîne ou buffer à envoyer></code></pre><br><br>&lt;Longueur&gt; est une chaîne ANSI correspondant à la longueur de la chaîne ou du buffer en octets. <br>Exemple : "9"+RC+"HelloWord". |



**`<Option> : (Chaîne de caractères optionnelle ou constante du WLangage (RC, CRLF, EOT))`**

Marque de fin (par défaut ce marqueur est la chaîne de caractères "&lt;EOF&gt;").  



<a name="NOTE0"></a>
<a name="NOTE0_1"></a>

## Remarques




### Type de transmission d'un message
<a name="type_transmission_message_ELTPARAGRAPHE000170"></a>Le type de transmission du message définit le mode utilisé pour déterminer la longueur du message.

**Par défaut**(constante *SocketTailleDébut*), le nombre de caractères du message est indiqué au début du message. Ce mode de transmission est conseillé lors d'une communication par sockets entre deux applications WINDEV.

Les constantes *SocketMarqueurFin* et *SocketMarqueurFinBuffer* permettent d'utiliser le mode standard de détermination de la longueur des messages lors de communication par sockets. Ce mode de transmission est conseillé lors d'une communication par sockets entre une application WINDEV et une autre application. Dans ce cas, il sera nécessaire d'inclure un caractère spécifique dans le message afin d'indiquer que le message est terminé.


<a name="NOTE0_2"></a>




### Différences de fonctionnement entre les constantes SocketMarqueurFin et SocketMarqueurFinBuffer
<a name="differences_fonctionnement_entre_les_constantes_socketmarqueurfin_socketmarqueurfinbuffer_ELTPARAGRAPHE000183"></a>Dans les deux cas, la lecture sur le socket attend de recevoir le marqueur de fin.

- Avec la constante ***SocketMarqueurFin*** : Si des éléments sont reçus après le marqueur de fin, une erreur WLangage est générée, indiquant que les marqueurs de fin ne sont pas respectés.

- Avec la constante ***SocketMarqueurFinBuffer*** : Si des éléments sont reçus après le marqueur de fin, la chaîne reçue est lue jusqu'au marqueur de fin, l'excédent est conservé et reporté dans la prochaine lecture. Il est ainsi possible de réaliser des lectures partielles. Ce mode permet de simplifier le traitement de certains protocoles standard sur Internet.
	Par exemple : lors de la connexion à un serveur de news (protocole NNTP), le protocole indique que le marqueur de fin peut être "&lt;CRLF&gt;" ou bien "&lt;CRLF&gt;.&lt;CRLF&gt;". Avec le mode "bufferisé", il est possible de lire la première ligne, et d'attendre le deuxième marqueur uniquement s'il doit y en avoir un.





<a name="NOTE0_3"></a>




### Message avec marqueur de fin
<a name="message_avec_marqueur_fin_ELTPARAGRAPHE000197"></a>Si l'encodage du message prend en compte le marqueur de fin, il n'est pas nécessaire de le préciser dans le message.


<a name="NOTE0_4"></a>




### Transmission entre deux postes utilisant des formats de chaînes de caractères différents (UNICODE et ANSI)
<a name="transmission_entre_deux_postes_utilisant_des_formats_chaines_caracteres_differents_unicode_ansi_ELTPARAGRAPHE000206"></a>Lors de la transmission de messages entre deux postes utilisant un format de chaînes de caractères différent, certaines conversions peuvent être nécessaires (fonctions [AnsiVersUnicode](../WDLang1/3024002.md) ou [UnicodeVersAnsi](../WDLang1/3024025.md)). 

<a name="XComposante"></a>

## Composante :
wd280com.dll
