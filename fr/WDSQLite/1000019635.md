
## Connecteur Natif SQLite : Spécificités et remarques
			

<a name="NOTE1"></a>
<a name="NOTE1_1"></a>


## Présentation
<a name="presentation_ELTTEXTE000247"></a>
Les paragraphes suivants présentent les remarques générales et les spécificités du Connecteur Natif SQLite.

<a name="NOTE2"></a>
<a name="NOTE2_1"></a>


## Remarques générales
<a name="remarques_generales_ELTTEXTE000271"></a>


### Versions nécessaires
<a name="versions_necessaires_ELTPARAGRAPHE000017"></a>**Attention** : Cette version du Connecteur Natif SQLite ne fonctionne qu'avec WINDEV 28 et/ou WEBDEV 28.

Le Connecteur Natif SQL Server via OLE DB est disponible sous Windows en 32 bits et en 64 bits. 

Le Connecteur Natif SQL Server via ODBC est disponible sous Windows en 32 bits et en 64 bits et sous Linux en 64 bits. 

<a name="NOTE2_2"></a>


## Type et contenu des rubriques
<a name="type_contenu_des_rubriques_ELTTEXTE000295"></a>


### Type déclaré
<a name="type_declare_ELTPARAGRAPHE000033"></a>Dans les bases de données SQLite, les rubriques possèdent un type "déclaré". Cependant, le type de chaque valeur peut être différent de ce type "déclaré". 

Il est donc possible de stocker n'importe quelle valeur, de n'importe quelle longueur, dans n'importe quel type de rubrique, théoriquement sans perte (exemple : 'toto' peut être stocké dans une rubrique de type entier).

Ce fonctionnement n'est pas disponible en HFSQL. Le Connecteur Natif va donc essayer de convertir la valeur lue sur la base dans le type "déclaré" de la rubrique.

**Contournement** : Il est conseillé de forcer le type de la rubrique dans l'analyse à "Texte". Dans ce cas, l'Accès Natif convertira toutes les valeurs dans le type texte, ce qui permettra de lire et d'afficher n'importe quel type de valeur.

SQLite stocke les valeurs dans l'un des types suivants :  

- NULL.

- INTEGER. 

- REAL. 

- TEXT. 

- BLOB. 


Pour plus de détails, consultez la documentation de SQLite. 
<a name="NOTE2_3"></a>


### Type NUMERIC ou DECIMAL
<a name="type_numeric_decimal_ELTPARAGRAPHE000056"></a>Le fonctionnement interne de SQLite limite la précision des rubriques de type NUMERIC à 15 chiffres car en interne la valeur est généralement stockée sous forme de réel.
<a name="NOTE2_4"></a>


### Identifiant automatique
<a name="identifiant_automatique_ELTPARAGRAPHE000063"></a>Sur SQLite, chaque enregistrement possède un identifiant unique de type entier 64 bits : le ROWID.

Bien que cette rubrique soit "cachée" par défaut par le moteur SQLite, il est toujours possible d'y accéder en utilisant un des noms spéciaux suivants : 

- "ROWID",

- "_ROWID_",

- "OID".




Les recherches sur l'identifiant "ROWID" sont généralement deux fois plus rapides que les recherches sur n'importe quelle autre clé primaire.

Le Connecteur Natif SQLite importe donc systématiquement la colonne "ROWID" afin de privilégier son utilisation pour optimiser les performances.

**Remarques** : 

- Si un fichier possède une rubrique de type "INTEGER PRIMARY KEY", cette rubrique est un alias de la rubrique "ROWID". Dans ce cas, la rubrique ROWID sera importée sous ce nom.

- Si le nom "ROWID" est déjà utilisé par une autre rubrique du fichier, le Connecteur Natif utilise l'un des autres noms de l'identifiant unique : "_ROWID_" ou "OID".



<a name="NOTE2_5"></a>


### Unicode
<a name="unicode_ELTPARAGRAPHE000085"></a>Toutes les chaînes de caractères sont UNICODE. 

Tous les échanges avec le moteur SQLite sont faits en UTF8.

Si dans l'analyse, une chaîne de caractères est de type ANSI, le Connecteur Natif effectue automatiquement toutes les conversions nécessaires.
<a name="NOTE2_6"></a>


### Sensibilité à la casse
<a name="sensibilite_casse_ELTPARAGRAPHE000096"></a>Le Connecteur Natif gère la sensibilité à la casse (option "collate binary" ou "collate nocase") lors de la création ou de l'importation d'un fichier existant.

L'insensibilité à la casse est gérée uniquement pour les caractères Latin 1.
<a name="NOTE2_7"></a>


### Sensibilité à l'accentuation et aux caractères spéciaux
<a name="sensibilite_accentuation_aux_caracteres_speciaux_ELTPARAGRAPHE000105"></a>Toutes les rubriques sont toujours sensibles à l'accentuation et aux caractères spéciaux sur une base de données SQLite. 

<a name="NOTE3"></a>
<a name="NOTE3_1"></a>


## Remarques et spécificités du Connecteur Natif SQLite
<a name="remarques_specificites_connecteur_natif_sqlite_ELTTEXTE000349"></a>


### Optimisation des opérations d'écriture multiples
<a name="optimisation_des_operations_ecriture_multiples_ELTPARAGRAPHE000114"></a>Chaque opération d'écriture (par exemple effectuée par les fonctions [HAjoute](../WDLang4/3044147.md), [HModifie](../WDLang4/3044042.md), [HSupprime](../WDLang4/3044018.md)) est effectuée par défaut dans une transaction. 

Si aucune transaction n'est démarrée, une transaction est débutée automatiquement avant l'opération et terminée automatiquement après l'opération.

**Conseil** : Les performances d'une boucle d'écriture seront meilleures en effectuant toutes les opérations dans la même transaction. 
Pour cela, il suffit d'appeler la fonction SQLTransaction avant la boucle puis la fonction SQLTransaction après la boucle.

Exemple : 

```txt
SQLTransaction(sqlDébut, <Connexion>) 

// Boucle d'écritures

SQLTransaction(sqlFin, <Connexion>)
```



<a name="NOTE3_2"></a>


### Batchs de requêtes
<a name="batchs_requetes_ELTPARAGRAPHE000139"></a>Le Connecteur Natif ne gère pas les batchs de requêtes (c'est-à-dire plusieurs requêtes séparées par des ';' exécutées en une seule fois). 

Il faut exécuter une requête à la fois.

**Astuce** : Il est possible de débuter une transaction, exécuter/parcourir toutes les requêtes une par une, puis de terminer la transaction. 


<a name="NOTE3_3"></a>


### Fonction HCréation
<a name="fonction_hcreation_ELTPARAGRAPHE000151"></a>La fonction [HCréation](../WDLang4/3044255.md) peut échouer (erreur "database table is locked") si les conditions suivantes sont réunies : 

- le fichier à créer existe déjà.

- un parcours est en cours sur un autre fichier de la même base de données.




Ceci est dû à une limitation de la base de données SQLite. 


<a name="NOTE3_4"></a>


### Blocage des enregistrements
<a name="blocage_des_enregistrements_ELTPARAGRAPHE000167"></a>Les options de blocage (constantes *hBlocageEcriture* et *hBlocageLectureEcriture*) utilisables avec les fonctions HFSQL ne sont pas gérées dans cette version.

**Remarque** : Seuls les blocages effectués par les fonctions SQL sont gérés. Le blocage est géré uniquement au niveau du fichier de données par SQLite. 
<a name="NOTE3_5"></a>


### Ordres SQL non gérés
<a name="ordres_sql_non_geres_ELTPARAGRAPHE000176"></a>Le Connecteur Natif SQLite ne supporte pas : 

- les instructions suivantes : 

	- INSTR

	- PATINDEX

	- TOP

	- BOTTOM

	- LOG

	- LN

	- EXP

	- POWER 

	- SIGN

	- SQRT

	- COS

	- SIN

	- TAN

	- MOD

	- MID

	- RIGHT et FULL OUTER JOIN




- les concaténations de style (par exemple SELECT CLIENT.VILLE + '////' + CLIENT.CODEPOSTAL AS CONCAT1 FROM CLIENT WHERE CLIENT.VILLE + '////' + CLIENT.CODEPOSTAL LIKE 'O%')









