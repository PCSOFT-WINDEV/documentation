
## Langage externe : Programmation en C ++ (interface WDWDIAL)
			



<a name="NOTE1"></a>
<a name="NOTE1_1"></a>


## Présentation
<a name="presentation_ELTTEXTE000231"></a>
Ce troisième mode utilise la notion d'héritage de classes pour faciliter l'interfaçage d'une application C++ avec WINDEV. Bien entendu, ce mode de programmation est à conseiller si vous développez déjà en utilisant une architecture à base de classes (MFC par exemple).

Les fonctions décrites dans la 2ème méthode sont utilisées en arrière-plan par les classes de base fournies avec cette interface. Pour plus d'informations les concernant, reportez vous au [Détail des commandes de l'interface externe](../LangageExt/7513004.md)

Ce mode est illustré dans :

- le projet VC60API.dsp (au format Visual C++ 6) fourni dans le sous-répertoire "LangagesExternes\\C" du répertoire d'installation de WINDEV.

- le projet BC50API.ide (au format Borland C 5) fourni dans le sous-répertoire "LangagesExternes\\C" du répertoire d'installation de WINDEV.




Remarque : D'autres modes de programmation en langage externe sont disponibles. Pour plus de détails, consultez [Les différents modes de programmation des langages externes](../LangageExt/7510002.md)



<a name="NOTE2"></a>
<a name="NOTE2_1"></a>


## Mise en place
<a name="mise_place_ELTTEXTE000255"></a>


### 1. Inclusion des fichiers de l'interface C de WINDEV
<a name="1_inclusion_des_fichiers_interface_windev_ELTPARAGRAPHE000032"></a>Voici la liste des fichiers à inclure dans un projet faisant appel à cette interface. Cette liste présente l'exemple VC60Api.dsp fourni avec WINDEV. Bien sûr, le fichier nommé "WD Langage Externe.h" est propre à ce projet et ne doit pas être inclus dans votre propre projet.

![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=mode3.gif)


Les deux lignes suivantes doivent être placées dans le code du fichier .c principal de votre projet C :


```txt
#include "WDWDial.h" // Langage et objets WinDev
#include "HFContext.h" // SGBD HyperFileSQL
```



<a name="NOTE2_2"></a>


### 2. Inclusion des déclarations HyperFileSQL
<a name="2_inclusion_des_declarations_hyperfilesql_ELTPARAGRAPHE000046"></a>Une inclusion (#include) doit être ajoutée pour chaque fichier de données déclaré dans l'analyse du projet WINDEV. Les déclarations des fichiers de données sont incluses dans le fichier d'extension .h (ce fichier remplace les .wdr créés avec la version précédente de WINDEV).

Par exemple dans le projet Vc60.dsp (fourni avec WINDEV dans le répertoire "LangagesExternes"), la ligne suivante est présente pour gérer les fichiers Ville et Departement :


```txt
#include "WD Langage externe.h"
```




<a name="NOTE3"></a>
<a name="NOTE3_1"></a>


## Interfaçage du C++ avec WINDEV
<a name="interfacage_avec_windev_ELTTEXTE000285"></a>


### 1. Déclaration du contexte HyperFileSQL et des buffers de travail de chaque fichier:
<a name="1_declaration_contexte_hyperfilesql_des_buffers_travail_chaque_fichier_ELTPARAGRAPHE000060"></a>Si l'application doit gérer des fichiers de données, il est nécessaire de déclarer un contexte de travail HyperFileSQL, ainsi qu'un buffer par fichier de données.

Ces déclarations sont effectuées par les lignes suivantes dans le projet Vc60API.dsp :


```txt
CHFContext    gclHF; // Gestion du contexte HyperFileSQL
StVILLE       gstVille; // Buffer HF du fichier Ville
stDEPARTEMENT gstDepartement; // Buffer HF du fichier Depart
```



<a name="NOTE3_2"></a>


### 2. Héritage
<a name="2_heritage_ELTPARAGRAPHE000072"></a>L'utilisation des fenêtres WINDEV depuis le langage C++ se fait par héritage de la classe CWDDialog. La classe héritant de CWDDialog fera automatiquement l'interface avec l'objet graphique fenêtre et les champs contenus dans cette fenêtre. On utilise en principe une classe par type de fenêtre WINDEV.

Exemple d'héritage :


```txt
class CMenu:public CWDDialog
{
...
}
```



<a name="NOTE3_3"></a>


### 3. Constructeur
<a name="3_constructeur_ELTPARAGRAPHE000084"></a>Le constructeur de la classe CWDDialog reçoit deux paramètres comme montré ci-dessous :


```txt
CWDDialog::CWDDialog(LPCSTR szNomWDW, HWND hWndMere)
```


Il incombe donc au constructeur de votre classe de passer ces paramètres à CWDDialog lors de son appel. Par exemple, voici le code du constructeur de la classe CMenu de l'exemple VC60API.dsp :


```txt
CMenu::CMenu(LPCSTR szNomWDW, HWND hWndMere) : CWDDialog (szNomWDW,hWndMere)
{
}
```


Bien sûr votre constructeur de classe peut recevoir des paramètres supplémentaires. Voir par exemple le constructeur de la classe CRecherche dans le projet VC60API.dsp.
<a name="NOTE3_4"></a>


### 4. MAP des actions de l'utilisateur dans les fenêtres
<a name="4_map_des_actions_utilisateur_dans_les_fenetres_ELTPARAGRAPHE000099"></a>Le mécanisme de la classe CWDDialog permet d'associer les événements utilisateurs dans la fenêtre WINDEV à des méthodes de votre classe (à la manière de la fonction [nWDSetCallbackNext](../LangageExt/7513012.md)), mais de façon générale et automatique.

Ceci permet d'intégrer toute la gestion de la fenêtre à l'intérieur de votre classe. Pour cela :

- créez les méthodes correspondant aux différents traitements que vous souhaitez réaliser dans votre fenêtre

- déclarez le MAP (association méthode&lt;-&gt;événement) de la fenêtre

- récupérez éventuellement les actions de base gérées par la classe CWDDialog (optionnel)




** Création des méthodes**
Les méthodes de votre classe seront appelées automatiquement par le mécanisme interne de la classe hérité de CWDDialog. Il est donc possible de les encapsuler avec le mode 'protected' dans votre déclaration.

Exemple de la classe CMenu :


```txt
class CMenu:public CWDDialog
{
public:
CMenu(LPCSTR pszNomWDW, HWND hWndMere= NULL);
protected:
void Quitter( void ) {Ferme();}
void RechVille( void );
void RechDepar( void );
void LstDepart( void );
void LstImprime( void );
void LstConfig( void );
void Recherche( void );
...
}
```


**Déclaration du map**
La déclaration suivante permet de faire l'association entre les méthodes créées et les événements utilisateur. Les événements correspondent, comme pour la méthode précédente, au contenu de la chaîne **WDTouche** renseignée dans le code WLangage.

La première déclaration à faire dans la déclaration de la classe de la fenêtre (à la suite de la déclaration des méthodes) est la suivante :

```txt
DECLARE_TOUCHE_MAP(CMenu);
```


Ensuite, il ne reste plus qu'à remplir le MAP avec les associations méthode&lt;-événement comme suit (en dehors de la déclaration de la classe). Exemple issu du projet VC60API.dsp :


```txt
START_TOUCHE_MAP(CMenu)
{"FQ", Quitter},
{"RN", RechVille},
{"RD", RechDepar},
{"DD", LstDepart},
{"DI", LstImprime},
{"DC", LstConfig},
END_TOUCHE_MAP()
```


**Récupération des actions gérées de base par CWDDialog**
La classe CWDDialog prend en charge les touches Entrée et Echap (comportement standard de validation et d'abandon). Afin de récupérer vous aussi ces événements, il vous est possible d'hériter du mécanisme décrit dans la classe de base par la ligne suivante (placée à la fin de vos déclarations de méthodes) : HERITE_TOUCHE_MAP(CWDDialog)

Code complet de la déclaration de classe CMenu :


```txt
class CMenu:public CWDDialog
{
public:
	CMenu(LPCSTR pszNomWDW, HWND hWndMere= NULL);
protected:
	void Quitter( void ) {Ferme();}
	void RechVille( void );
	void RechDepar( void );
	void LstDepart( void );
	void LstImprime( void );
	void LstConfig( void );
	void Recherche( void );
	DECLARE_TOUCHE_MAP(CMenu);
	HERITE_TOUCHE_MAP(CWDDialog); // Optionnel
};
START_TOUCHE_MAP(CMenu)
	{"FQ", Quitter},
	{"RN", RechVille},
	{"RD", RechDepar},
	{"DD", LstDepart},
	{"DI", LstImprime},
	{"DC", LstConfig},
END_TOUCHE_MAP()
```



<a name="NOTE3_5"></a>


### 5. Association entre un membre de la classe et un champ de la fenêtre
<a name="5_association_entre_membre_classe_champ_fenetre_ELTPARAGRAPHE000143"></a>Ce type d'association permet de lier un membre de la classe avec un champ de la fenêtre gérée par la classe. Ceci peut fonctionner :

- pour récupérer automatiquement dans un membre défini le contenu du champ lors de la validation (et sortie) de la fenêtre

- pour affecter automatiquement le contenu d'un membre dans un champ lors de l'ouverture de la fenêtre




Une association de ce type est réalisée par l'appel à trois macro-commandes permettant:

- de créer le membre de la classe qui sera lié avec le champ

- initialiser la gestion des associations champ/membre

- associer le champ de la fenêtre avec le membre du même nom




La création du membre est réalisée par l'appel d'une des macro-commandes de la famille "DECLARE_MEMBER_SAISIE_". Par exemple la macro-commande DELCLARE_MEMBER_SAISIE_INT crée un membre de type entier qui pourra être associé à un champ de type entier.

Les macro-commandes du type "DECLARE_MEMBER_SAISIE" permettent de déclarer un membre dont le nom correspondra au nom du champ dans la fenêtre. L'exemple qui suit est extrait de la déclaration de la classe CRecherche :

```txt
DECLARE_MEMBER_SAISIE_INT(Occur,0) // Champ entier de valeur = 0
```


Il existe donc une macro-commande pour chaque type de champ (INT signifiant ici entier). Voici leur liste (pour plus de détails sur la syntaxe permettant de les appeler, voir le fichier WDWDIAL.H) :


```txt
// SELECTEUR
DECLARE_MEMBER_SELECTEUR(NOM, INITVAL)
// LIBELLE
DECLARE_MEMBER_LIBELLE(NOM, INITSTR, TAILLE)
// SAISIE CHAINE
DECLARE_MEMBER_SAISIE_STR(NOM, INITSTR, TAILLE)
// SAISIE CHAINE CTSTRING sans limite de taille
DECLARE_MEMBER_SAISIE_CTSTRING(NOM, INITSTR)
// SAISIE ENTIER
DECLARE_MEMBER_SAISIE_INT(NOM, INITVAL)
// INTERRUPTEUR MULTIPLE 
// Exemple :
//  DECLARE_MEMBER_TABINTERRUPTEUR(INTER1, 10, "x x x x x ")
// ensemble de 10 interrupteurs initialise de maniere a n'en cocher qu'un sur deux
DECLARE_MEMBER_TABINTERRUPTEUR(NOMCHAMPWD, NOMBRE, INITSTR)
// INTERRUPTEUR SIMPLE
DECLARE_MEMBER_INTERRUPTEUR(NOM,  INITSTATE)
// COMBO CHAINE
DECLARE_MEMBER_COMBO_STR(NOM, INITSTR, TAILLE)
// LISTE CHAINE
DECLARE_MEMBER_LISTE_STR(NOM, INITSTR, TAILLE)
// COMBO CHAINE CTString sans limite de taille
DECLARE_MEMBER_COMBO_CTSTRING(NOM, INITSTR)
// COMBO ENTIER
DECLARE_MEMBER_COMBO_INT(NOM, INITVAL)
```


L'initialisation de la gestion des champs/membres est ensuite réalisée par la macro "DECLARE_GERE_AUTO". Exemple pour la classe CRecherche :


```txt
DECLARE_GERE_AUTO(CRecherche)
```


Finalement, l'association entre les champs de la fenêtre et les membres de la classe du même nom est faite par les macro-commandes suivantes (exemple de la classe CRecherche) :


```txt
START_GERE_AUTO(CRecherche)
GERE_AUTO(Occur)
// placer ici les autres associations champ/membre
END_GERE_AUTO()
```




<a name="NOTE4"></a>
<a name="NOTE4_1"></a>


## Utilisation de HyperFileSQL en C++
<a name="utilisation_hyperfilesql_ELTTEXTE000333"></a>
L'utilisation des fonctions d'accès aux fichiers de données est bien sûr possible par l'appel de la fonction nWDExecute (voir définition de cette fonction). Toutefois, l'interface langage C++ fournit une classe de gestion des fichiers HyperFileSQL nommée CVHFContext.

Cette classe interface l'utilisation des fonctions HyperFileSQL standard (fonctions WLangage H\*).

Pour plus de détails sur les syntaxes de ces fonctions, référez vous à l'aide en ligne de WINDEV (WDLang.chm) et au fichier HFContext.cpp fourni avec le projet VC60API.dsp




