


## &lt;Type Chaîne&gt;.BufferVersHexa (Fonction)

***En anglais : &lt;String type&gt;.BufferToHexa***



<a name="XUtilisation"></a>
<a name="Utilisation"></a>
<a name="description"></a>
Convertit une chaîne Ansi ou Unicode en une chaîne hexadécimale affichable (par exemple : "4A 5B 00").

**Remarque** : Pour convertir une chaîne hexadécimale en buffer, utilisez la fonction [HexaVersBuffer](../WDLang1/1000019914.md). 






<a name="Exemple1"></a>
<a name="sample_code"></a>

## Exemple

<a name="Exemple2"></a>

```wl
s est une chaîne UNICODE = "abdcefghijkl"
Trace(s.BufferVersHexa())
// affiche :

// 61 00 62 00 64 00 63 00 65 00 66 00 67 00 68 
// 69 00 6A 00 6B 00 6C 00
```
<a name="Exemple3"></a>

```wl
s est une chaîne UNICODE = "Plétopabo"

// Affiche 50 00 6C 00 E9 00 74 00 6F 00 70 00 61 00 62 00<\r><\n>6F 00
Trace(s.BufferVersHexa(1)) 
// Affiche 0050 006C 00E9 0074 006F 0070 0061 0062<\r><\n>006F
Trace(s.BufferVersHexa(2)) 
// Affiche 5000 6C00 E900 7400 6F00 7000 6100 6200<\r><\n>6F00
Trace(s.BufferVersHexa(2, BigEndian))  
// Affiche 006C0050 007400E9 0070006F 00620061<\r><\n>6F 00
Trace(s.BufferVersHexa(4)) 
// Affiche 50006C00 E9007400 6F007000 61006200<\r><\n>6F 00
Trace(s.BufferVersHexa(4, BigEndian))
```

<a name="XSYNTAXE"></a>

## Syntaxe
<a name="SYNTAXE1"></a>

`<Résultat> = <Chaîne à convertir>.BufferVersHexa([<Nb octets par mot> [, <Nb octets par ligne>]])`
---

**`<Résultat> : (Chaîne de caractères)`**

Chaîne de caractères au format hexadécimal.

**`<Chaîne à convertir> : (Chaîne de caractères)`**

Chaîne de caractères Ansi ou Unicode à manipuler. 

**`<Nb octets par mot> : (Entier ou constante de type Entier)`**

Nombre d'octets affichés par mot. Ce paramètre peut correspondre à : 

- 1 (valeur par défaut) : les valeurs sont regroupées par octet. 

- 2 : les valeurs sont regroupées par mot de 2 octets. 

- 4 : les valeurs sont regroupées par mot double de 4 octets.

- la constante *SansRegroupement* : aucun regroupement ne sera effectué. Tous les codes hexadécimaux seront collés. Exemple : 61002345A1. 




**`<Nb octets par ligne> : (Entier ou constante de type Entier)`**

Nombre d'octets affichés avant de passer à la ligne. 

- Tous les &lt;Nb octets par ligne&gt;, un Retour Chariot (RC) est ajouté à la chaîne résultat.  

- Si &lt;Nb octets par ligne&gt; est inférieur à &lt;Nb octets par mot&gt;, le Retour Chariot (RC) sera ajouté tous les &lt;Nb octets par mot&gt;. 

- Si ce paramètre correspond à la constante *SansLigne*, tous les octets seront positionnés sur la même ligne.


Par défaut : 

- ce nombre est égal à 16. 

- le regroupement est effectué au format Little-Endian (octets de poids fort à la fin, comme en x86). 

- si le paramètre &lt;Nb octets par mot&gt; vaut *SansRegroupement*, alors &lt;Nb octets par ligne&gt; correspondra par défaut à la constante *SansLigne*.




Pour effectuer un regroupement au format Big-Endian : 

- utilisez directement la constante *BigEndian*. 

- ajoutez la constante *BigEndian* à la valeur de &lt;Nb octets par ligne&gt;. 

- Remarque : la constante *SansLigne* peut être combinée à la constante *BigEndian*.






<a name="NOTE0"></a>
<a name="NOTE0_1"></a>

## Remarques


### Création d'un identifiant
<a name="creation_identifiant_ELTPARAGRAPHE000309"></a>Les constantes *SansRegroupement* et *SansLigne* permettent de simplifier la création d'un identifiant à partir d'un buffer. 

<a name="XComposante"></a>

## Classification Métier / UI :
Code neutre
## Composante :
wd280std.dll
