
## Principe d'exécution des threads
			



<a name="NOTE1"></a>
<a name="NOTE1_1"></a>


## Présentation
<a name="presentation_ELTTEXTE000384"></a>
Lorsqu'une application est en cours d'exécution, cette application s'exécute dans un **thread principal**.

A tout moment, cette application peut lancer un **thread secondaire** : ce thread s'exécute en parallèle de l'application. Ce thread correspond à une procédure (locale ou globale) de l'application.

Ce thread secondaire va s'exécuter en parallèle de l'application principale. Il est possible de réaliser dans ce thread tous les traitements réalisables en tâche de fond : réception des emails, ...

**Remarque** : un thread efficace est un thread qui attend un événement spécifique, par exemple une action de l'utilisateur, la réception d'un appel téléphonique ou d'un email, ...









<a name="NOTE2"></a>
<a name="NOTE2_1"></a>


## Gestion simple des threads
<a name="gestion_simple_des_threads_ELTTEXTE000414"></a>


### Principe
<a name="principe_ELTPARAGRAPHE000043"></a>**Un thread secondaire est créé avec la fonction [ThreadExécute](../WDLang1/3077024.md).**

Un thread secondaire est automatiquement arrêté lorsque :

- la procédure correspondant au thread est terminée,

- l'objet à l'origine de thread est fermé.




Pour forcer l'arrêt : 

- d'un thread secondaire :

	1. utilisez la fonction [ThreadDemandeArrêt](../WDLang1/1000021218.md),

	2. testez le résultat de la fonction [ThreadArrêtDemandé](../WDLang1/1000021219.md) dans le thread secondaire afin de terminer l'exécution du thread par une sortie de la procédure, ou un appel de la fonction [ThreadFin](../WDLang1/1000020874.md).







- du thread en cours, utilisez la fonction [ThreadFin](../WDLang1/1000020874.md).




**Attention** : Si lors de l'arrêt d'un thread, une fonction WLangage est en cours d'exécution, l'arrêt ne sera effectif qu'après l'exécution de la fonction.
<a name="NOTE2_2"></a>


### Fonctions WLangage
<a name="fonctions_wlangage_ELTPARAGRAPHE000083"></a>Les fonctions suivantes permettent une gestion simple des threads :



|   |   |
| --- | --- |
| [ThreadArrêtDemandé](../WDLang1/1000021219.md) | Vérifie si une demande d'arrêt a été envoyée au thread en cours d'exécution. |
| [ThreadArrête](../WDLang1/3077019.md) | Arrête un thread secondaire. **Fonction déconseillée.** |
| [ThreadAttend](../WDLang1/3077020.md) | Attend la fin de l'exécution du thread désigné. |
| [ThreadCourant](../WDLang1/1000019423.md) | Renvoie le nom du thread en cours d'exécution. |
| [ThreadDemandeArrêt](../WDLang1/1000021218.md) | Envoie une demande d'arrêt à un thread. |
| [ThreadEtat](../WDLang1/3077016.md) | Renvoie l'état actuel d'un thread. |
| [ThreadExécute](../WDLang1/3077024.md) | Lance l'exécution d'un thread secondaire. |
| [ThreadFin](../WDLang1/1000020874.md) | Termine l'exécution du thread en cours. |
| [ThreadMode](../WDLang1/3077028.md) | Change le mode de gestion des threads. |
| [ThreadPause](../WDLang1/3077029.md) | Temporise le thread en cours pour la durée indiquée. |
| [ThreadPriorité](../WDLang1/3077027.md) | Renvoie ou modifie le niveau de priorité d'un thread. |
| [ThreadReprend](../WDLang1/3077023.md) | Relance l'exécution d'un "thread" précédemment suspendu par la fonction [ThreadSuspend](../WDLang1/3077014.md). **Fonction déconseillée.** |
| [ThreadSuspend](../WDLang1/3077014.md) | Suspend temporairement l'exécution du thread désigné. **Fonction déconseillée.** |




Pour plus de détails sur toutes les fonctions permettant de manipuler les threads, consultez [Fonctions de gestion des threads](../WDLang1/3077003.md).

<a name="NOTE3"></a>
<a name="NOTE3_1"></a>


## Caractéristiques d'un thread
<a name="caracteristiques_thread_ELTTEXTE000540"></a>


### Caractéristiques des threads
<a name="caracteristiques_des_threads_ELTPARAGRAPHE000098"></a>En WLangage, un thread secondaire peut être associé à :

- une procédure locale à la fenêtre en cours,

- une procédure globale au projet,

- une méthode de classe,

- une méthode globale de classe.




Un thread secondaire peut être un **thread sécurisé**. Dans ce mode : 

- une erreur de compilation sera affichée si des accès aux champs sont effectués dans le thread (ou si la procédure utilise l'attribut "UI"). 

- une exception sera générée : 

	- si le thread accède aux champs en exécution, 

	- si la fonction [ThreadArrête](../WDLang1/3077019.md) est utilisée.




- la fermeture de la fenêtre qui a lancé le thread provoque une demande d'arrêt (mais le thread peut continuer à s'exécuter après la fermeture de la fenêtre). 







### Attributs d'extension liés aux threads
<a name="attributs_extension_lies_aux_threads_ELTPARAGRAPHE000125"></a>Lors de la déclaration d'une procédure ou d'une méthode de classe, il est possible d'utiliser des attributs d'extension pour spécifier les caractéristiques du thread : 


|   |   |
| --- | --- |
| *&lt;thread&gt;* | Permet d'indiquer que la procédure sera exécutée dans un thread secondaire. <br>Cet attribut d'extension est incompatible avec les attributs d'extension **&lt;timer&gt;** et **&lt;thread principal&gt;**. |
| *&lt;thread principal&gt;* | Permet d'indiquer que la procédure sera exécutée dans le thread principal. <br>Cet attribut d'extension est incompatible avec les attributs d'extension **&lt;timer&gt;** et **&lt;thread&gt;**. |
| *&lt;thread principal asynchrone&gt;* | Permet d'indiquer que la procédure sera exécutée dans le thread principal sans attendre la fin de l'exécution de la procédure. <br>Cet attribut d'extension est incompatible avec les attributs d'extension **&lt;timer&gt;** et **&lt;thread&gt;**. |
| *&lt;thread sécurisé&gt;* | Permet d'indiquer que la procédure sera exécutée dans un thread secondaire sécurisé. <br>Cet attribut d'extension est incompatible avec les attributs d'extension **&lt;timer&gt;**,  **&lt;thread principal&gt;** et &lt;UI&gt;. |
| *&lt;contexte HFSQL léger&gt;* | Provoque la copie immédiate d'une partie du contexte HFSQL courant. <br>Seuls les répertoires où se trouvent les fichiers de données en HFSQL Classic et/ou les connexions en HFSQL Client/Serveur sont mémorisés.<br><br>Cet attribut d'extension doit être utilisé avec l'attribut d'extension **&lt;thread&gt;**. <br><br>![Universal Windows 10 App](https://doc.pcsoft.fr/ext/images/fr/UNIVERSALAPP.png) Cet attribut d'extension n'est pas disponible. |
| *&lt;contexte HFSQL complet&gt;* | Provoque la copie immédiate du contexte HFSQL courant.<br>Conseillé par exemple si le thread doit tenir compte des positions en cours dans les fichiers et requêtes du contexte de l'appelant.<br><br>Cet attribut d'extension doit être utilisé avec l'attribut d'extension **&lt;thread&gt;**. <br><br>![Universal Windows 10 App](https://doc.pcsoft.fr/ext/images/fr/UNIVERSALAPP.png) Cet attribut d'extension n'est pas disponible. |


Remarque : Il est également possible d'utiliser l'interface de l'éditeur de code, via les [Procédures automatiques](../Editeurs/9000072.md).
<a name="NOTE3_2"></a>


### Accès aux éléments existants et contexte HFSQL
<a name="acces_aux_elements_existants_contexte_hfsql_ELTPARAGRAPHE000193"></a>Lors de la création d'un thread, toutes les déclarations, objets, éléments existants sont communs :

- au nouveau thread secondaire.

- au thread dans lequel le thread secondaire a été créé (dans la plupart des cas, correspond au thread principal).




Ces threads peuvent ainsi accéder aux variables, procédures, ... Toutes les variables créées après le lancement d'un thread sont accessibles uniquement dans le thread où elles sont créées.

De même, lors de la création d'un thread, le ***contexte HFSQL*** est automatiquement dupliqué. Chaque thread manipule un contexte HFSQL spécifique. Il y a autant de contextes HFSQL que de threads en cours d'exécution. La totalité du contexte HFSQL est recopiée (filtre, condition de recherche, ...). Dans chaque thread, le contexte HFSQL évolue indépendamment.

Il est ainsi possible par exemple de réaliser deux parcours différents sur le même fichier de données dans deux threads différents.

**Exemple** : 

- Un filtre est créé sur le fichier de données Client. 

- La fonction [ThreadExécute](../WDLang1/3077024.md) est appelée pour créer le thread CTX2. 

- Dans chaque thread (thread principal et thread CTX2), le fichier de données client est filtré. Si dans le thread principal, le filtre est désactivé, le filtre sera toujours actif dans le thread CTX2.




**Cas particuliers** :

- **Gestion assistée des erreurs HFSQL** : Si plusieurs threads sont utilisés sur des fichiers de données, il est conseillé de personnaliser la gestion des erreurs HFSQL pour ne pas afficher les fenêtres par défaut. Pour cela, utilisez la fonction [HSurErreur](../WDLang4/3044017.md) pour désactiver la gestion automatique des erreurs ou pour rediriger la gestion des erreurs vers une procédure personnalisée (sans affichage de fenêtres). Pour plus de détails, consultez [Gestion assistée des erreurs HFSQL](../WDLang4/3044188.md).

- **Ecritures et affectations dans un thread** : Si des écritures ou des affectations sont effectuées dans un thread, les autres threads en cours d'exécution ne partagent pas ces informations. Certaines incohérences peuvent apparaître.


Exemple :



|   |   |
| --- | --- |
| Code Thread 1 | Code Thread 2 |
| a=i<br>a++<br>i=a | b=i<br>b++<br>i=b |


Ces deux threads partagent les variables mais ne gèrent pas l'accès aux ressources communes. Si le thread 1 est exécuté avant le thread 2, i vaudra 1 au lieu de 2.

**Remarque** : Pour partager une affectation entre plusieurs threads, il est nécessaire d'utiliser des sémaphores. Pour plus de détails, consultez [Gérer les sémaphores dans les threads](../WDLang1/3077013.md).



<a name="NOTE4"></a>
<a name="NOTE4_1"></a>


## Recommandations pour les traitements réalisés par le thread
<a name="recommandations_pour_les_traitements_realises_par_thread_ELTTEXTE000576"></a>


### Traitements interdits
<a name="traitements_interdits_ELTPARAGRAPHE000263"></a>Attention : Il n'est pas possible d'exécuter dans les threads les traitements suivants :

- ouverture de fenêtres avec les fonctions WLangage telles que [Ouvre](../WDLang1/3038035.md), [Utilise](../WDLang1/3038044.md), [Ferme](../WDLang1/3038018.md), ... Si des fenêtres doivent être manipulées dans des threads (cas rare), une gestion spécifique doit être mise en place. Pour plus de détails, consultez [Gérer l'ouverture d'une fenêtre dans un thread secondaire](../WDLang1/3077015.md).

- gestion d'événement.

- multitâche.

- gestion de timer.





|   |
| --- |
| **Attention : il est interdit de manipuler l'UI (fenêtres, champs, ...) dans un thread secondaire.**<br> Lorsqu'un thread secondaire doit interagir avec l'utilisateur ou mettre à jour l'UI, il doit utiliser un traitement lancé depuis le thread principal. Ce traitement peut correspondre à :<br><br>- une procédure globale du projet ou une procédure locale (d'une fenêtre, ...) appelée par la fonction [ExécuteThreadPrincipal](../WDLang1/1000019862.md),<br><br>- l'événement "Demande de mise à jour de l'affichage" d'une fenêtre exécuté grâce à la fonction [DemandeMiseAJourUI](../WDLang1/1000023899.md).<br><br><br> |




<a name="NOTE4_2"></a>


### Traitements d'une application WINDEV
<a name="traitements_une_application_windev_ELTPARAGRAPHE000301"></a>Par défaut, tout événement WINDEV (code de clic d'un bouton par exemple), toutes les procédures, les méthodes des classes ne peuvent être exécutés que par un seul thread à un moment donné.

Pour permettre à plusieurs threads d'exécuter ces traitements en même temps, il est nécessaire de :

1. Changer le mode de gestion par défaut des threads (fonction [ThreadMode](../WDLang1/3077028.md)).

2. Gérer dans le code de l'application les sections critiques et les sémaphores.




![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) En Java, tout événement (code de clic d'un bouton par exemple), toutes les procédures, les méthodes de classes peuvent être exécutées par plusieurs threads en même temps. Pour empêcher que plusieurs threads exécutent le même code en même temps, il est nécessaire d'ajouter dans le code de l'application des sections critiques ou des sémaphores.


<a name="NOTE4_3"></a>


### Traitement d'exception et threads
<a name="traitement_exception_threads_ELTPARAGRAPHE000321"></a>Si un traitement d'exception général est effectué dans le code d'initialisation du projet, il sera déclenché si une exception survient :

- dans le thread principal,

- dans un thread secondaire lancé par la fonction [ThreadExécute](../WDLang1/3077024.md).


Cependant, si le thread secondaire déclenche une exception, il ne sera pas possible de connaître son origine avec la fonction [ExceptionInfo](../WDLang1/3034006.md) dans le code du projet. Pour connaître l'origine d'une exception dans un thread secondaire, il faut inclure le traitement de l'exception dans le thread secondaire.




- ![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=Lesthreads.gif) ***Exemples unitaires (WINDEV Mobile)*** : **Les threads** <br>Utilisation des threads dans une application :<br>- exécuter une procédure sous forme d'un thread<br>- arrêter un thread<br>- exécuter une procédure nécessitant des paramètres sous forme d'un thread
- ![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=Lesthreads.gif) ***Exemples unitaires (WINDEV)*** : **Les threads** <br>Utilisation des threads dans une application :<br>- Exécuter une procédure sous forme d'un thread<br>- Arrêter un thread<br>- Exécuter une procédure nécessitant des paramètres sous forme d'un thread
- ![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=Lesthreads_pool_.gif) ***Exemples unitaires (WINDEV)*** : **Les threads (pool)** <br>Utilisation des threads :<br>- Exécution de processus lancés en parallèle<br>- Limitation du nombre de threads en exécution à un instant donné<br><br>Rappel: un "thread" est un processus lancé en parallèle de l'application en cours ("thread" principal). <br>Il est par exemple possible de lancer l'exécution d'une tâche en traitement de fond (sauvegarde, ...).<br>Les threads sont très utiles dans le domaine industriel: superviseur, applications avec contrôle de process en temps réel,
- ![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=WDUtilisationdessockets.gif) ***Exemples didactiques (WINDEV)*** : **WD Utilisation des sockets** <br>Cet exemple illustre les fonctions "Socket" de WINDEV dans une utilisation de type client/serveur.<br>Dans cet exemple, nous abordons deux thèmes principaux :<br>1/ Comment se connecter à une socket<br>2/ Comment accepter une demande de connexion<br>3/ Comment écrire ou lire sur une socket<br>Résumé de l'exemple livré avec WINDEV :	<br>Cet exemple présente les différentes fonctions de gestion des sockets livrées en standard avec WINDEV. Pour utiliser cet exemple, il est nécessaire de lancer une première instance de l'exemple en mode "serveur". Ensuite, en donnant le nom de la machine faisant office de serveur et un pseudonyme, vous pouvez vous connecter à cette application en mode "client". Il est alors possible d'envoyer des messages à tous les utilisateurs connectés. Dans cet exemple, à chaque connexion est associée : un thread et une socket .


