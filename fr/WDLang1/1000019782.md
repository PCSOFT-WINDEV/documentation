


## EvalueExpression (Fonction)

***En anglais : EvaluateExpression***



<a name="XUtilisation"></a>
<a name="Utilisation"></a>
<a name="description"></a>
Evalue la valeur d'une expression construite dans une chaîne de caractères. 


<a name="Exemple1"></a>
<a name="sample_code"></a>

## Exemple


```wl
// Evaluation d'une formule
x,y sont des réels
x = 1.5
Y = 5
Trace(EvalueExpression("cos(x)+sin(y)"))
```

<a name="XSYNTAXE"></a>

## Syntaxe
<a name="SYNTAXE1"></a>

`<Résultat> = EvalueExpression(<Expression>)`
---

**`<Résultat> : (Tout type)`**



- **Si l'expression compile sans erreur**, résultat de l'expression.

- **Si l'expression ne compile pas**, si elle ne renvoie pas de valeur ou si une erreur se produit lors de l'évaluation, une erreur fatale est déclenchée.




**`<Expression> : (Chaîne de caractères)`**

Expression à évaluer.



<a name="NOTE0"></a>
<a name="NOTE0_1"></a>

## Remarques


### Variables locales
<a name="variables_locales_ELTPARAGRAPHE000042"></a>Les variables locales du traitement courant peuvent être utilisées directement dans l'expression.
<a name="NOTE0_2"></a>


### Compilation de l'expression
<a name="compilation_expression_ELTPARAGRAPHE000049"></a>L'expression est recompilée à chaque appel de la fonction **EvalueExpression**. 

Pour éviter la phase de recompilation, vous pouvez utiliser les fonctions [Compile](../WDLang1/3013015.md) et [Exécute](../WDLang1/3013041.md) pour construire le code d'une procédure, la compiler une fois et l'exécuter plusieurs fois. Dans ce cas, vous perdrez la possibilité d'utiliser directement des variables locales du traitement courant qu'il faudra remplacer par des paramètres de la procédure.
<a name="NOTE0_3"></a>


### Utilisation d'une procédure de composant externe 
<a name="utilisation_une_procedure_composant_externe_ELTPARAGRAPHE000067"></a>L'expression est recompilée à chaque appel de la fonction **EvalueExpression**. 

L'appel d'une procédure d'un composant externe doit nommer cette procédure avec son nom complet. 

```wl
EvalueExpression("MonComposant.MaCollection.MaProcédure()"))
```

<a name="NOTE0_4"></a>


### Code dynamique
<a name="code_dynamique_ELTPARAGRAPHE000080"></a>Les **constantes ne peuvent pas être utilisées** dans le code dynamique (définies avec le mot-clé [CONSTANTE](../Motscles/1514012.md)).

Lors de l'utilisation de constantes dans un code toute les occurrences des constantes sont remplacées par leur valeur au moment de la compilation sous l'éditeur, mais la correspondance entre le nom des constantes et leur valeur n'est pas "embarquée" dans l'application. Donc la compilation dynamique ne peut pas utiliser les constantes.

Voici deux alternatives :

1 - Utiliser des variables à la place des constantes : 

```wl
CONSTANTE
	CST_Nom = 1
FIN
```
devient par exemple

```wl
CST_Nom est un entier = 1
```
ou

2 - Dans la chaîne qui contient le code que l'on va compiler dynamiquement, au lieu de laisser le nom de la constante, on remplace le nom de la constante par sa valeur :

```wl
sCode est une chaîne
// Dans la chaîne qui contient le code que l'on va compiler dynamiquement
// au lieu de laisser le nom de la constante comme ici :
sCode=[
Info(CST_Nom)
]
// On remplace le nom de la constante par sa valeur
sCode = Remplace(sCode,"CST_Nom", CST_Nom, MotComplet + SansCasse)
// Il est ensuite possible de compiler le code
SI Compile("ProcDyn", sCode) <> "" ALORS
	Erreur("Erreur de compilation de la procédure dynamique : ", ...
		ErreurInfo())
SINON
	// Puis de l'exécuter
	QUAND EXCEPTION DANS 
		ExécuteTraitement("ProcDyn", trtProcédure)
	FAIRE
		Erreur("Erreur d'exécution de la procédure dynamique : ", ...
			ExceptionInfo())
	FIN
FIN
```


<a name="XComposante"></a>

## Composante :
wd280vm.dll
