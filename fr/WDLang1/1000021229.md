
## Gestion des tâches parallèles
			

<a name="NOTE1"></a>
<a name="NOTE1_1"></a>


## Présentation
<a name="presentation_ELTTEXTE000342"></a>
A l'heure actuelle, la puissance des machines augmente. Les machines ont des processeurs puissants avec plusieurs coeurs. 

Afin d'augmenter les performances des applications et de faire travailler un nombre maximum de coeurs de la machine, il est désormais possible de découper les traitements en une liste de sous-traitements (appelés tâches) et de les exécuter en parallèle plutôt qu'en séquentiel. 

Une tâche est une procédure à exécuter qui peut attendre des paramètres en entrée et retourner un résultat. Ces tâches seront exécutées par la machine dans un ou plusieurs threads en fonction de la disponibilité de la machine.
Une tâche peut être elle-même décomposée en plusieurs sous-tâches.

**Quel est l'intérêt des tâches parallèles ?**
Les tâches parallèles sont utiles pour : 

- **accélérer les temps de traitement de l'application grâce au parallélisme** : plusieurs traitements sont exécutés en parallèle au lieu d'être exécutés séquentiellement : la vitesse de l'application est améliorée. 
	***Un exemple simple*** : lancer un calcul de statistiques d'envoi et de réception d'emails sur chaque adresse email de la base de données. Si le calcul de statistiques sur une adresse email prend une seconde et si la base de données contient 200 000 adresses email, le calcul prend plus de deux jours. 
	Pour aller plus vite, il suffit de lancer une tâche parallèle pour chaque adresse email trouvée. 
	 Cet exemple est détaillé dans le paragraphe [Exemple : Accélérer les traitements](#NOTE4_1).

- **améliorer la réactivité de l'application** : plusieurs traitements longs et bloquants sont effectués en parallèle au lieu d'être exécutés séquentiellement : l'utilisateur n'a pas l'impression d'être bloqué. 
	***Un exemple simple*** : Un champ Table affiche une liste de contacts dont la photo est chargée depuis une adresse Internet. Pour chaque contact, l'application fait une requête Internet (ce qui entraîne un ralentissement). 
	Pour que le remplissage du champ Table ne soit pas bloqué, le traitement d'affichage de ligne lance une tâche parallèle permettant de lancer la requête Internet et de mettre à jour l'IHM si nécessaire. 
	 Cet exemple est détaillé dans le paragraphe [Exemple : Améliorer la réactivité de l'application](#NOTE5_1).






<a name="NOTE2"></a>
<a name="NOTE2_1"></a>


## Principe
<a name="principe_ELTTEXTE000366"></a>
Pour gérer des tâches parallèles, le WLangage propose : 

- un type de variable [TâcheParallèle](../WDLang1/1000021220.md). Ce type de variable permet de manipuler une tâche parallèle. Ce type de variable ne permet pas de modifier les caractéristiques d'une tâche parallèle. 

- des fonctions de gestion des tâches ([TâcheParallèle\*](../WDLang1/1000021300.md)).




Remarque : Il est également possible d'utiliser le type de variable [Description de TâcheParallèle](../WDLang1/1000021586.md). Ce type de variable permet uniquement de décrire une tâche parallèle. Lorsque la tâche parallèle est définie, il sera impossible de modifier ses caractéristiques.  

<a name="NOTE3"></a>
<a name="NOTE3_1"></a>


## Comment le faire ?
<a name="comment_faire_ELTTEXTE000390"></a>


### Principe
<a name="principe_ELTPARAGRAPHE000082"></a>Pour mettre en place une gestion de tâches parallèles, il faut : 

1. Créer et exécuter une tâche parallèle. 

2. Attendre l'exécution de la tâche et récupérer la valeur de retour. 

3. Gérer si nécessaire l'enchaînement des tâches parallèles. 

4. Manipuler si nécessaire les champs depuis une tâche parallèle.   



<a name="NOTE3_2"></a>


### Créer et exécuter une tâche parallèle
<a name="creer_executer_une_tache_parallele_ELTPARAGRAPHE000094"></a>Une tâche parallèle doit être associée à une variable de type [TâcheParallèle](../WDLang1/1000021220.md). 

Il est possible de déclarer une variable de type [TâcheParallèle](../WDLang1/1000021220.md) de plusieurs façons : 

- Déclaration simple. La description de la tâche parallèle est effectuée lors de son exécution avec la fonction [TâcheParallèleExécute](../WDLang1/1000021211.md) : 
	
	```wl
	// Déclare une variable pour manipuler une tâche parallèle
	t est une TâcheParallèle
	// Exécution et description de la tâche parallèle
	t = TâcheParallèleExécute(Proc, ("Premier paramètre", 2))
	```


- Déclaration et description de la tâche parallèle. La tâche parallèle est ensuite exécutée grâce à la fonction [TâcheParallèleExécute](../WDLang1/1000021211.md). 
	
	```wl
	// Construit une tâche parallèle 
	t est une TâcheParallèle(Proc, ("Premier paramètre", 2))
	// Déclenche l'exécution de la tâche parallèle
	TâcheParallèleExécute(t)
	```





Remarque : Lors de la description de la tâche parallèle, il est possible d'indiquer : 

- la procédure à exécuter. 

- les paramètres attendus par la procédure.

- le mode d'exécution de la tâche parallèle : gestion des contextes HFSQL et interactions avec le thread principal. 





<a name="NOTE3_2b"></a>


### Le mot-clé MaTâcheParallèle
<a name="motcle_matacheparallele_ELTPARAGRAPHE000129"></a>Le mot-clé **MaTâcheParallèle** permet de manipuler la tâche parallèle en cours et de connaître ses propriétés. Il est ainsi possible dans le code exécuté par une tâche parallèle d'accéder aux informations concernant la tâche parallèle en cours. Les propriétés accessibles sont celles d'une variable de type [TâcheParallèle](../WDLang1/1000021220.md) : 


| Nom de la propriété | Type manipulé | Effet |
| --- | --- | --- |
| Annulée | Booléen | <br><br>- <u><u><u><u>Vrai</u></u></u></u> si la tâche est annulée, <br><br>- <u><u><u><u>Faux</u></u></u></u> dans le cas contraire. <br><br><br><br><br>Cette propriété est disponible en lecture seulement. |
|  Etat | Constante de type Entier | Etat de la tâche : <br><br>- *tpeAnnulée* : la tâche parallèle est annulée (fonction [TâcheParallèleAnnule](../WDLang1/1000021278.md)). <br><br>- *tpeAnnulationDemandée* : une demande d'annulation a été faite sur la tâche parallèle (fonction [TâcheParallèleDemandeAnnulation](../WDLang1/1000021213.md)). <br><br>- *tpeAttenteExécution* : la tâche parallèle est en attente d'exécution. <br><br>- *tpeAttentePrécédente* : la tâche parallèle attend l'exécution d'une tâche parallèle précédente. <br><br>- *tpeExécutionEnCours* : la tâche parallèle est en cours d'exécution. <br><br>- *tpeNonPlanifiée* : la tâche parallèle n'est pas planifiée. <br><br>- *tpeTerminée* : la tâche parallèle est terminée. <br><br><br><br><br>Cette propriété est disponible en lecture seulement. |
| Identifiant | Entier | Identifiant de tâche. Cet identifiant peut être utilisé par exemple à des fins de débogage. <br><br>Cette propriété est disponible en lecture seulement. |
| Terminée | Booléen | <br><br>- <u><u><u><u>Vrai</u></u></u></u> si la tâche est terminée, <br><br>- <u><u><u><u>Faux</u></u></u></u> dans le cas contraire. <br><br><br>Cette propriété est disponible en lecture seulement. |
| ValeurRenvoyée | Valeur renvoyée par la tâche. | Attention : <br><br>- Si la tâche est toujours en cours, la propriété **ValeurRenvoyée** attend la fin de la tâche.<br><br>- Si la tâche est terminée sans erreur fatale, la propriété renvoie la ou les valeurs de retour de la procédure de la tâche.<br><br><br><br><br>Cette propriété est disponible en lecture seulement. |


<a name="NOTE3_3"></a>


### Attendre l'exécution de la tâche et récupérer la valeur de retour
<a name="attendre_execution_tache_recuperer_valeur_retour_ELTPARAGRAPHE000140"></a>Plusieurs tâches parallèles peuvent être lancées simultanément. Il est possible d'attendre l'exécution d'une ou de plusieurs tâches parallèles avant d'exécuter un traitement : 


|   |   |
| --- | --- |
| [TâcheParallèleAttend](../WDLang1/1000021212.md) | Attend la fin de l'exécution d'une tâche parallèle. |
| [TâcheParallèleAttendToutes](../WDLang1/1000021297.md) | Attend la fin de l'exécution de toutes les tâches parallèles présentes dans un tableau. |





La propriété **ValeurRenvoyée** de la variable de type [TâcheParallèle](../WDLang1/1000021220.md) permet de connaître la valeur renvoyée par la procédure exécutée par la tâche parallèle. 
Attention : Cette valeur est disponible uniquement si la tâche parallèle est terminée. Si la tâche est en cours, l'appel de cette propriété est bloquant jusqu'à la fin de la tâche. 
<a name="NOTE3_4"></a>


### Gérer l'enchaînement des tâches parallèles
<a name="gerer_enchainement_des_taches_paralleles_ELTPARAGRAPHE000155"></a>Plusieurs tâches parallèles peuvent être lancées simultanément. Il est possible de définir l'enchaînement des tâches parallèles : une tâche peut attendre la fin de l'exécution d'une ou plusieurs tâches avant de s'exécuter. Les fonctions suivantes permettent de définir une tâche de continuation : 


|   |   |
| --- | --- |
| [TâcheParallèleExécuteAprès](../WDLang1/1000021214.md) | Indique une tâche parallèle de continuation qui sera exécutée lorsque la tâche parallèle spécifiée sera terminée. |
| [TâcheParallèleExécuteAprèsToutes](../WDLang1/1000021217.md) | Indique une tâche parallèle de continuation qui sera exécutée lorsque toutes les tâches d'un tableau de tâches parallèles seront terminées. |
| [TâcheParallèleExécuteAprèsUne](../WDLang1/1000021216.md) | Indique une tâche parallèle de continuation qui sera exécutée après la première tâche terminée d'un tableau de tâches parallèles. |





Remarque : Dans une tâche de continuation, il est possible : 

- de manipuler la tâche précédente terminée grâce au mot-clé ***MaTâcheParallèlePrécédente*** (fonction [TâcheParallèleExécuteAprès](../WDLang1/1000021214.md) et [TâcheParallèleExécuteAprèsUne](../WDLang1/1000021216.md)). 

- de manipuler les tâches précédentes terminées grâce au mot-clé ***MesTâchesParallèlesPrécédentes*** (fonction [TâcheParallèleExécuteApresToutes](../WDLang1/1000021217.md)). 



<a name="NOTE3_5"></a>


### Manipuler les champs depuis une tâche parallèle
<a name="manipuler_les_champs_depuis_une_tache_parallele_ELTPARAGRAPHE000177"></a>Il n'est pas possible d'agir sur l'interface depuis une tâche parallèle. Il n'est donc pas possible d'affecter un champ, de remplir un champ Table ou Zone répétée. 

Seule une tâche définie avec la constante *tpoThreadPrincipal* pourra s'exécuter dans le thread principal et pourra si nécessaire mettre à jour les champs. 

Remarque : Il est également possible d'utiliser la fonction [ExécuteThreadPrincipal](../WDLang1/1000019862.md) pour exécuter une procédure d'affichage spécifique depuis la tâche parallèle. 

Ces deux méthodes sont utilisée dans l'exemple [Améliorer la réactivité de l'application](#NOTE5_1) présenté dans cette page. 






<a name="NOTE4"></a>
<a name="NOTE4_1"></a>


## Exemple : Accélérer les traitements
<a name="exemple_accelerer_les_traitements_ELTTEXTE000561"></a>


### Accélérer les traitements : calcul de statistiques 
<a name="accelerer_les_traitements_calcul_statistiques_ELTPARAGRAPHE000200"></a>Une application utilise la procédure **CalculeStatAdresseEmail** pour calculer des statistiques d'envoi et de réception sur chaque adresse email du fichier CLIENT. Cette procédure prend en paramètre l'adresse email et calcule toutes les statistiques sur cette adresse. 

Si le calcul de statistiques sur une adresse email prend une seconde et si la base de données contient 200 000 adresses email, le calcul prend plus de deux jours (200 000 secondes). 

Pour aller plus vite, il suffit de lancer une tâche parallèle pour chaque adresse email trouvée. 

Exemple de code : 

- Code initial (avant l'utilisation des tâches parallèles) : 
	
	```wl
	nAdressesEnErreur est un entier
	
	Sablier(Vrai)
	ChronoDébut()
	// Parcours la liste des clients
	POUR TOUT Client 	
		// Lance le calcul de statistiques sur son adresse email
		SI CalculeStatAdresseEmail(Client.Email, 1) = Faux ALORS
			nAdressesEnErreur++
		FIN	
	FIN
	Sablier(Faux)
	LIB_Résultat_1 = ChaîneConstruit("Résultat : %1 adresses en erreur", nAdressesEnErreur)
	Info("Traitement terminé", DuréeVersChaîne(ChronoFin(), "MMm SSs CCC"))
	```


- Code utilisant les tâches parallèles : 
	
	```wl
	nAdressesEnErreur est un entier
	tabTâches est un tableau de TâchesParallèles
	UneTâche est une TâcheParallèle
	
	Sablier(Vrai)
	ChronoDébut()
	// Parcours la liste des clients
	POUR TOUT Client 
		// Lance le calcul de statistiques sur son adresse email à l'aide d'une tâche parallèle
		UneTâche = TâcheParallèleExécute(CalculeStatAdresseEmail, ...
				(Client.Email, 1), tpoCopieLégèreContexteHFSQL)
		// Mémorise cette tâche dans un tableau 
		Ajoute(tabTâches, UneTâche)
	FIN
	
	// Attend la fin de l'exécution des tâches
	TâcheParallèleAttendToutes(tabTâches)
	Sablier(Faux)
	
	// Parcours les tâches
	POUR TOUT UneTâche DE tabTâches
		SI UneTâche..ValeurRenvoyée = Faux ALORS
			nAdressesEnErreur++
		FIN
	FIN
	LIB_Résultat_2 = ChaîneConstruit("Résultat : %1 adresses en erreur", nAdressesEnErreur)
	Info("Traitement terminé", DuréeVersChaîne(ChronoFin(), "MMm SSs CCC"))
	```





<a name="NOTE5"></a>
<a name="NOTE5_1"></a>


## Exemple : Améliorer la réactivité de l'application
<a name="exemple_ameliorer_reactivite_application_ELTTEXTE000585"></a>


### Améliorer la réactivité de l'application
<a name="ameliorer_reactivite_application_ELTPARAGRAPHE000222"></a>Un champ Table affiche une liste de contacts dont la photo est chargée depuis une adresse Internet. Pour chaque contact, l'application fait une requête Internet (ce qui entraîne un ralentissement). 

Pour améliorer la réactivité de l'application, et obtenir une IHM fluide, une tâche parallèle est lancée dans le traitement d'affichage d'une ligne du champ Table. Cette tâche parallèle : 

- reçoit en paramètre l'identifiant du contact. 

- fait la requête Internet pour obtenir l'image. 

- récupère l'image. 

- appelle une fonction pour mettre à jour le champ Table. 




Pour cet exemple, voici deux codes différents : ces deux codes présentent deux façons différentes de mettre à jour l'IHM : 

- l'exemple 1 met à jour l'IHM [via une tâche de continuation](#NOTE5_2). 

- l'exemple 2 met à jour l'IHM [via une procédure exécutée dans le thread principal](#NOTE5_3). 



<a name="NOTE5_2"></a>


### Mise à jour l'IHM via une tâche de continuation
<a name="mise_jour_ihm_via_une_tache_continuation_ELTPARAGRAPHE000247"></a>La mise à jour de l'interface n'étant pas possible depuis une tâche parallèle exécutée dans le thread principal, une tâche de continuation spécifique pour l'affichage est mise en place via la fonction [TâcheParallèleExécuteAprès](../WDLang1/1000021214.md). Un des paramètres passés à la tâche de continuation correspond à la valeur renvoyée par la tâche parallèle principale. Pour spécifier ce paramètre, il suffit d'utiliser le mot-clé ***ValeurRenvoyéeTâchePrécédente***. 

Exemple de code : 

- Code d'affichage d'une ligne de la table : 
	
	```wl
	// Si la photo n'est pas encore renseignée
	SI COL_Photo ~= "" ALORS
		// Positionne l'image de sablier en attendant de récupérer la photo depuis "Internet"
		COL_Photo = IMG_Sablier
		// Lance la récupération de la photo dans une tâche parallèle
		MaTacheRechercheImage est une TâcheParallèle = TâcheParallèleExécute(RechercheImage, ...
			(COL_NumClient), tpoCopieLégèreContexteHFSQL)
		// Lance l'affichage de l'image dans une tâche de continuation 
		// qui interagit avec l'interface
		TâcheParallèleExécuteAprès(MaTacheRechercheImage, AfficheImage, ...
				(COL_NumClient, ValeurRenvoyéeTâchePrécédente), tpoThreadPrincipal)
	FIN
	```


- Code de la procédure "RechercheImage" : Ce traitement permet de récupérer l'image. 
	
	```wl
	PROCEDURE RechercheImage(LOCAL nIDClient est un entier sur 8)
	
	// Récupération de la photo
	Résultat1 est un booléen = HTTPRequête("http://Linkedin.com/photos/id=" + ID)
	SI Résultat1 = Vrai ALORS
		bufPhoto est un Buffer = HTTPDonneRésultat()
		bufPhoto = fChargeBuffer(fRepExe() + fSep() + "Photos\" + ID + ".jpg")
	FIN
	
	RENVOYER bufPhoto
	```


- Code de la procédure "AfficheImage" : Cette procédure permet d'afficher l'image dans la table. 
	
	```wl
	PROCEDURE AfficheImage(nIDClient est un entier sur 8, sCheminPhoto est une chaîne)
	// Recherche le client dans la table
	nIndice est un entier = TableCherche("FEN_MENU.TABLE_Client.COL_NumClient", nIDClient)
	SI nIndice > 0 ALORS
		// Affiche la photo du client
		FEN_Menu.TABLE_Client.COL_Photo[nIndice] = sCheminPhoto
	FIN
	```




<a name="NOTE5_3"></a>


### Mise à jour l'IHM via une procédure exécutée dans le thread principal
<a name="mise_jour_ihm_via_une_procedure_executee_dans_thread_principal_ELTPARAGRAPHE000269"></a>Depuis une tâche parallèle, il est interdit d'accéder aux champs de la fenêtre. Pour afficher l'image, la procédure **AfficheImage** est exécutée via la fonction WLangage [ExécuteThreadPrincipal](../WDLang1/1000019862.md). Cette fonction force l'exécution d'une procédure dans le thread principal. 

Plus simple encore, il est possible d'indiquer à la procédure **AfficheImage** qu'elle s'exécutera toujours dans le thread principal. Il suffit de cliquer sur le bouton ![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=Proc_auto_Ico.gif)
 dans le bandeau de l'éditeur de code et de cocher "Exécuter dans le thread principal". 

Exemple de code : 

- Code d'affichage d'une ligne de la table : 
	
	```wl
	// Si la photo n'est pas encore renseignée
	SI COL_Photo ~= "" ALORS
		// Positionne l'image de sablier en attendant de récupérer la photo depuis "Internet"
		COL_Photo  = IMG_Sablier
		// Lance la récupération de la photo dans une tâche parallèle
		MaTacheRechercheImage est une TâcheParallèle = TâcheParallèleExécute(RechercheImage, ...
			(COL_NumClient), tpoCopieLégèreContexteHFSQL)
	FIN
	```


- Code de la procédure "RechercheImage" : Ce traitement permet de récupérer l'image.
	
	```wl
	PROCEDURE RechercheImage(LOCAL nIDClient est un entier sur 8)
	
	// Récupération de la photo
	Résultat1 est un booléen = HTTPRequête("http://Linkedin.com/photos/id=" + ID)
	SI Résultat1  = Vrai ALORS
		bufPhoto est un Buffer = HTTPDonneRésultat()
		bufPhoto = fChargeBuffer(fRepExe() + fSep() + "Photos\"+ ID + ".jpg")
	FIN
	
	// Appelle la procédure pour afficher l'image
	ExécuteThreadPrincipal(AfficheImage, nIDClient, bufPhoto)
	```


- Code de la procédure "AfficheImage" : Cette procédure permet d'afficher l'image dans la table. 
	
	```wl
	PROCEDURE AfficheImage(nIDClient est un entier sur 8, sCheminPhoto est une chaîne)
	// Recherche le client dans la table
	nIndice est un entier = TableCherche("FEN_MENU.TABLE_Client.COL_NumClient", nIDClient)
	SI nIndice > 0 ALORS
		// Affiche la photo du client
		FEN_Menu.TABLE_Client.COL_Photo[nIndice] = sCheminPhoto
	FIN
	```












