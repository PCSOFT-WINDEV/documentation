


## &lt;Type Buffer&gt;.CrypteStandard (Fonction)

***En anglais : &lt;Buffer type&gt;.EncryptStandard***



<a name="XUtilisation"></a>
<a name="Utilisation"></a>
<a name="description"></a>
Crypte une chaîne de caractères ou un buffer binaire en utilisant un algorithme de chiffrement symétrique (AES, DES, etc.). Ce message crypté pourra être décrypté avec la fonction [DécrypteStandard](../WDLang1/1000021294.md). 

Contrairement aux fonctions [Crypte](../WDLang1/3024014.md) et [Décrypte](../WDLang1/3024035.md), les fonctions **&lt;Type Buffer&gt;.CrypteStandard** et [DécrypteStandard](../WDLang1/1000021294.md) utilisent des algorithmes de cryptage standard qui permettent d'échanger des messages cryptés entre des plateformes d'exécution différentes (Windows, Linux, Android, Java, iOS, PHP, etc.) et/ou avec des outils tiers.

**Remarque** : Le premier appel à la fonction **&lt;Type Buffer&gt;.CrypteStandard** peut être relativement long car il est nécessaire d'initialiser la randomisation. 


<a name="Exemple1"></a>
<a name="sample_code"></a>

## Exemple


```wl
// Cryptage d'une chaîne de caractères en utilisant l'algorithme AES
// ------------------------------------------------------------------
bufMessage est un Buffer = "Message à crypter"
bufClé est un Buffer = HashChaîne(HA_MD5_128, "ma chaîne à crypter")
bufCrypte est un Buffer = bufMessage.CrypteStandard(bufClé, crypteAES128)

// Décryptage en WLangage
------------------------- 
bufRésultat est un Buffer = bufCrypte.DécrypteStandard(bufClé, crypteAES128)
Info(bufRésultat)
```


<a name="1000021293_Exemple2"></a>

```wl
// Cryptage en WLangage
// ---------------------
bufMessage est un Buffer = "Message à crypter"
bufClé est un Buffer = HashChaîne(HA_MD5_128, "ma chaîne à crypter")
bufCrypte est un Buffer = bufMessage.CrypteStandard(bufClé, crypteAES128)

//---------------------------------------------------------------
// Décryptage via un appel à l'API Mcrypt de PHP 
nTailleIV est un entier = 128 / 8
bufIV est un Buffer = bufCrypte[[ A nTailleIV]]
bufDonnées est un Buffer = bufCrypte[[nTailleIV+1 A]]

EXTERNE mcrypt_decrypt//API PHP (à faire dans un traitement serveur WEBDEV PHP)
Trace(mcrypt_decrypt("rijndael-128", bufClé, bufDonnées, "cbc", bufIV))
```

<a name="XSYNTAXE"></a>

## Syntaxe
<a name="SYNTAXE1"></a>

`<Résultat> = <Message>.CrypteStandard(<Clé> [, <Algorithme> [, <Mode d'opération> [, <Remplissage> [, <Vecteur d'initialisation>]]]])`
---

**`<Résultat> : (Buffer binaire)`**



- Résultat du cryptage du message spécifié, 

- Chaîne vide ("") en cas d'erreur. Pour plus de détails sur l'erreur, utilisez la fonction [ErreurInfo](../WDLang1/3013008.md).




Ce buffer est composé de deux parties : 

- Le vecteur d'initialisation (Initialisation Vector ou IV) qui correspond à un bloc de bits généré aléatoirement (ou précisé avec le paramètre &lt;Vecteur d'initialisation&gt;) et qui a été combiné au premier bloc des données cryptées. Ce vecteur est nécessaire pour permettre le décryptage du message. Sa taille correspond à la taille des blocs utilisés par l'algorithme de cryptage (voir paramètre &lt;Algorithme&gt;).

- Les données cryptées.




Si le message doit être décrypté : 

- par la fonction [DécrypteStandard](../WDLang1/1000021294.md), il suffit de passer l'intégralité du buffer à la fonction.

- par un outil tiers, il est nécessaire de découper le buffer pour séparer le vecteur d'initialisation des données cryptées (voir exemple).




Remarque : Si le mode d'opération spécifié est *crypteECB*, aucun vecteur d'initialisation n'est utilisé et dans ce cas la fonction retourne directement les données cryptées.

**`<Message> : (Buffer)`**

Message à crypter.

**`<Clé> : (Buffer)`**

Clé avec laquelle les données doivent être cryptées. La taille de cette clé dépend de l'algorithme de cryptage utilisé. La taille de la clé doit correspondre à celle de l'algorithme. 

Il est conseillé d'utiliser les fonctions de hachage (par exemple fonction [HashChaîne](../WDLang1/1000007111.md)) pour créer une clé à partir d'un mot de passe. Un mot de passe long et composé d'un maximum de caractères alphanumériques et symboles distincts permet une meilleure sécurité de cryptage.

**Développement multiplateforme** : Pour manipuler des chaînes de caractères, il est nécessaire d'utiliser le même format sur toutes les plateformes. Il est conseillé d'utiliser des chaînes au format UTF 8 (et de convertir les chaînes Unicode si nécessaire).

**`<Algorithme> : (Constante optionnelle de type Entier)`**

Algorithme de cryptage à utiliser : 


|   |   |
| --- | --- |
| *crypte3DES* | Triple Data Encryption Standard. <br><br>- Taille de la clé : 192 bits. <br><br>- Taille des blocs : 64 bits.<br><br>- Taille du vecteur d'initialisation (IV) : 64 bits.<br><br><br> |
| *crypteAES128*<br>(Valeur par défaut) | Advanced Encryption Standard. <br><br>- Taille de la clé : 128 bits. <br><br>- Taille des blocs : 128 bits. <br><br>- Taille du vecteur d'initialisation (IV) : 128 bits.<br><br><br> |
| *crypteAES256* | Advanced Encryption Standard. <br><br>- Taille de la clé : 256 bits. <br><br>- Taille des blocs : 128 bits. <br><br>- Taille du vecteur d'initialisation (IV) : 128 bits.<br><br><br> |
| *crypteDES* | Data Encryption Standard. <br><br>- Taille de la clé : 64 bits. <br><br>- Taille des blocs : 64  bits. <br><br>- Taille du vecteur d'initialisation (IV) : 64 bits.<br><br><br><br><br>Attention : cet algorithme est actuellement déprécié. |



**`<Mode d'opération> : (Constante optionnelle de type Entier)`**

Mode de traitement des blocs par l'algorithme de cryptage : 


|   |   |
| --- | --- |
| *crypteCBC* <br>(Valeur par défaut) | Cipher Block Chaining - Enchaînement des blocs |
| *crypteCFB* | Cipher Feedback - Chiffrement à rétroaction. Ce mode de traitement est disponible uniquement si l'algorithme utilisé correspond à la constante *crypteAES256*. <br><br>![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Cette constante n'est pas disponible. |
| *crypteCTR* | Cipher Counter - Chiffrement basé sur un compteur. Ce mode de traitement est disponible uniquement si l'algorithme utilisé correspond à la constante *crypteAES256*. <br><br>![Java](https://doc.pcsoft.fr/ext/images/fr/JAVA.png) Cette constante n'est pas disponible. |
| *crypteECB* | Electronic Code Book - Dictionnaire de codes. Ce mode d'opération est **déconseillé** et ne devrait être utilisé que pour des raisons de compatibilité.<br> Aucun vecteur d'initialisation n'est utilisé et dans ce cas la fonction retourne directement les données cryptées. |



**`<Remplissage> : (Constante optionnelle de type Entier)`**

Mode de remplissage des données cryptées pour être compatibles avec la taille requise par les algorithmes de cryptage par blocs :


|   |   |
| --- | --- |
| *cryptePaddingPKCS* <br>(Valeur par défaut) | Les données sont complétées par des octets dont la valeur correspond au nombre total d'octets ajoutés pour atteindre la taille requise. |
| *cryptePaddingZéro* | Les données sont complétées par des zéros binaires jusqu'à obtenir la taille requise. |



**`<Vecteur d'initialisation> : (Buffer optionnel)`**

Vecteur d'initialisation (IV) à utiliser pour le chiffrement. La taille du buffer dépend de l'algorithme de chiffrement choisi (paramètre &lt;Algorithme&gt;). Si ce paramètre n'est pas précisé, le vecteur d'initialisation est généré aléatoirement.
**Attention** : **Ce paramètre doit être utilisé seulement si vous avez besoin d'un vecteur d'initialisation personnalisé dans votre projet**. Dans le cas contraire, il est fortement conseillé de conserver la génération du vecteur d'initialisation en mode aléatoire.





<a name="NOTE0"></a>
<a name="NOTE0_1"></a>

## Remarques


### Résultats obtenus lors d'un chiffrement AES
<a name="resultats_obtenus_lors_chiffrement_aes_ELTPARAGRAPHE000342"></a>Le chiffrement réalisé avec un algorithme AES utilise un vecteur d'initialisation. Ce vecteur d'initialisation est modifié à chaque appel de la fonction. Il est donc normal de ne jamais obtenir le même résultat lors du chiffrement d'une même information. Cependant, la valeur attendue est bien récupérée lors de l'appel de la fonction [DécrypteStandard](../WDLang1/1000021294.md).

<a name="XComposante"></a>

## Classification Métier / UI :
Code métier
## Composante :
wd280com.dll
