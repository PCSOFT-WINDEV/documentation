
## Timer (Fonction)

***En anglais : Timer***



<a name="XUtilisation"></a>
<a name="Utilisation"></a>
<a name="description"></a>
Appelle périodiquement et automatiquement une procédure du WLangage. Utilisée dans la procédure, la fonction **Timer** permet d'identifier le timer qui a lancé la procédure.

On appelle timer la séquence d'appel périodique d'une procédure. Cet appel périodique sera stoppé grâce à la fonction [FinTimer](../WDLang1/3015007.md).

**Conseil : Dans la majorité des cas, utilisez la fonction [TimerSys](../WDLang1/3015006.md).**

![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png) L'utilisation de procédures automatiques permet d'éviter l'utilisation de la fonction **Timer**. Pour plus de détails, consultez [les procédures automatiques](../Editeurs/9000072.md).
<a name="Exemple1"></a>
<a name="sample_code"></a>

## Exemple


```wl
// Procédure permettant l'affichage régulier de l'heure dans SAI_HEURE1
PROCEDURE Affiche_Heure()
SAI_HEURE1 = HeureSys()

// Traitement à l'ouverture de la fenêtre / de la page
// Affiche_Heure sera automatiquement appelée chaque seconde
SI Timer("Affiche_Heure", 100, 1) = 0 ALORS
	Erreur("Création du timer impossible")
FIN
```



<a name="XSYNTAXE"></a>
<a name="SYNTAXE1"></a>

## Syntaxe

### Lancer périodiquement une procédure

`<Résultat> = Timer(<Nom de la procédure> , <Période> [, <Numéro>])`
---

**`<Résultat> : (Entier)`**



- Numéro du timer ouvert (&lt;Numéro&gt; si ce paramètre a été précisé), 

- 0 si le timer n'a pas pu être ouvert.




**`<Nom de la procédure> : (Chaîne de caractères)`**

Nom de la procédure WLangage à lancer périodiquement.

Remarque : Si ce paramètre correspond au nom d'une procédure interne, le nom de la procédure interne ne doit pas être entre guillemets. 

**`<Période> : (Entier ou Durée)`**

Temps (en centièmes de seconde) entre deux appels à la procédure par timer. La précision de la période dépend de l'état d'attente du système.
Ce paramètre peut correspondre à : 

- un entier correspondant au nombre de centièmes de seconde, 

- une variable de type Durée, 

- l'indication directe de la durée (par exemple '1s' ou '10cs'). 




**`<Numéro> : (Entier optionnel)`**

Numéro imposé du timer. Si ce paramètre est précisé, le numéro du timer sera le numéro choisi. Si ce numéro correspond à un timer existant, il sera arrêté et remplacé par le nouveau timer.




<a name="SYNTAXE2"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png)![Code Utilisateur (MCU)](https://doc.pcsoft.fr/ext/images/fr/MCU.png) 
### Connaître le numéro du timer

`<Résultat> = Timer()`
---

**`<Résultat> : (Entier)`**

Numéro du timer qui a appelé la procédure en cours.  



<a name="NOTE0"></a>
<a name="NOTE0_1"></a>

## Remarques
![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png)![Windows](https://doc.pcsoft.fr/ext/images/fr/WINDOWS.png)![Code Utilisateur (MCU)](https://doc.pcsoft.fr/ext/images/fr/MCU.png) 

### Différences entre les fonctions Timer et TimerSys
<a name="differences_entre_les_fonctions_timer_timersys_ELTPARAGRAPHE000090"></a>

- La fonction **Timer** permet d'utiliser un timer géré par WINDEV. Dans ce cas, la fréquence d'appel est calculée à partir du moment où l'appel du timer a été effectué.

- La fonction [TimerSys](../WDLang1/3015006.md) permet d'utiliser un timer géré par le système. Dans ce cas, la fréquence d'appel est calculée à partir de l'instant de la fin de l'exécution de la procédure.




**Conseil : Dans la majorité des cas, utilisez la fonction TimerSys.** 
En effet, la fonction **Timer** consomme plus de ressources que la fonction [TimerSys](../WDLang1/3015006.md) et ne fonctionne que lorsque des fenêtres WINDEV sont en cours (le timer s'arrête si une boîte de message est affichée).
<a name="NOTE0_2"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png)![Windows](https://doc.pcsoft.fr/ext/images/fr/WINDOWS.png)![Code Utilisateur (MCU)](https://doc.pcsoft.fr/ext/images/fr/MCU.png) 

### Opérations bloquantes ou non
<a name="operations_bloquantes_non_ELTPARAGRAPHE000116"></a>

- Un timer n'est pas bloqué par l'ouverture des menus, l'ouverture d'une fenêtre, l'ouverture des fenêtres des fonctions [Avertissement](../WDLang1/3021009.md), [Confirmer](../WDLang1/3021007.md), [Erreur](../WDLang1/3021013.md), [Info](../WDLang1/3021011.md), [OKAnnuler](../WDLang1/3021004.md) et [OuiNon](../WDLang1/3021005.md).

- Un timer est bloqué par les déplacements et les agrandissements de fenêtre.



<a name="NOTE0_3"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png)![Windows](https://doc.pcsoft.fr/ext/images/fr/WINDOWS.png)![Code Utilisateur (MCU)](https://doc.pcsoft.fr/ext/images/fr/MCU.png) 

### Temps d'exécution de la procédure
<a name="temps_execution_procedure_ELTPARAGRAPHE000144"></a>Si le temps de traitement de la procédure appelée par le timer est supérieur au temps demandé entre chaque appel de la procédure, les appels du timer ne s'empilent pas : il n'y aura qu'un seul appel en attente.
<a name="NOTE0_4"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png)![Windows](https://doc.pcsoft.fr/ext/images/fr/WINDOWS.png)![Code Utilisateur (MCU)](https://doc.pcsoft.fr/ext/images/fr/MCU.png) 

### Traitement d'appel du timer
<a name="traitement_appel_timer_ELTPARAGRAPHE000153"></a>

- Code de projet :

	- Si la fonction **Timer** est appelée dans un code du projet, le timer est associé au projet. Le timer est interrompu par la fonction [FinTimer](../WDLang1/3015007.md) et par la fin de l'exécution de l'application. La procédure appelée par le timer doit être :

		- soit une procédure globale du projet : 
						
			```txt
			Timer("<procédure globale>", 1000)
			```
Il n'est pas possible de passer des paramètres à la procédure appelée (utilisez des variables globales).

		- soit une méthode statique d'une classe : 
						
			```txt
			Timer("<classe>::<méthode statique>", 1000)
			```





- Si la fonction **Timer** est utilisée dans le traitement d'ouverture du projet et si aucune fenêtre n'est ouverte, le timer sera valide sur tout le projet. Il est en attente et sera déclenché automatiquement dès qu'une fenêtre sera ouverte ou lors des appels à la fonction [Multitache](../WDLang1/3015004.md).

- Code d'une fenêtre, d'un champ ou d'une procédure locale :
	Si la fonction **Timer** est appelée dans un code d'une fenêtre, d'un des champs de la fenêtre ou d'une procédure locale de la fenêtre, le timer est associé à la fenêtre. Le timer est interrompu par la fonction [FinTimer](../WDLang1/3015007.md) et par la fermeture de la fenêtre. La procédure appelé par le timer doit être :

	- soit une procédure locale de la fenêtre : 
			
		```txt
		Timer("<procédure locale>", 1000)
		```
Il n'est pas possible de passer des paramètres à la procédure appelée (utilisez des variables globales).

	- soit une procédure globale du projet : 
			
		```txt
		Timer("<procédure globale>", 1000)
		```
Il n'est pas possible de passer des paramètres à la procédure appelée (utilisez des variables globales).

	- soit une méthode statique d'une classe : 
			
		```txt
		Timer("<classe>::<méthode statique>", 1000)
		```





- Code d'une méthode statique de classe :
	Si la fonction **Timer** est appelée dans une méthode statique de classe, le timer est associé à la classe. Le timer est interrompu par la fonction [FinTimer](../WDLang1/3015007.md) et par la fin d'exécution de l'application. La procédure appelée par le timer doit être :

	- soit une méthode statique de la classe : 
			
		```txt
		Timer("::<méthode statique>", 1000)
		```


	- soit une méthode statique d'une autre classe : 
			
		```txt
		Timer("<classe>::<méthode statique>", 1000)
		```


	- soit une procédure globale du projet : 
			
		```txt
		Timer("<procédure globale>", 1000)
		```





- Code d'une méthode d'un objet :
	Si la fonction **Timer** est appelée dans une méthode d'un objet, le timer est associé à l'objet. Le timer est interrompu par [FinTimer](../WDLang1/3015007.md) ou par la libération de l'objet. La procédure appelée par le timer doit être :

	- soit une méthode non statique de l'objet : 
			
		```txt
		Timer("<:méthode>", 1000)
		```


	- soit une méthode statique de la classe de l'objet : 
			
		```txt
		Timer("::<méthode statique>", 1000)
		```


	- soit une méthode statique d'une autre classe : 
			
		```txt
		Timer("<classe>::<méthode>", 1000)
		```


	- soit une procédure globale du projet : 
			
		```txt
		Timer("<procédure globale>", 1000)
		```







<a name="NOTE0_5"></a>
<a name="NOTE0_6"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png)![Windows](https://doc.pcsoft.fr/ext/images/fr/WINDOWS.png)![Code Utilisateur (MCU)](https://doc.pcsoft.fr/ext/images/fr/MCU.png) 

### Timer et fenêtres soeurs
<a name="timer_fenetres_soeurs_ELTPARAGRAPHE000268"></a>Dans le cas de l'ouverture multiple d'une même fenêtre gérant un timer (fenêtres soeurs dans un MDI), il faut utiliser la fonction **Timer** sans préciser le numéro de timer. Ainsi, un numéro de timer sera automatiquement attribué à chaque fenêtre.
<a name="NOTE0_7"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png)![Windows](https://doc.pcsoft.fr/ext/images/fr/WINDOWS.png)![Code Utilisateur (MCU)](https://doc.pcsoft.fr/ext/images/fr/MCU.png) 

### Timer et Thread
<a name="timer_thread_ELTPARAGRAPHE000280"></a>Une procédure lancée par les fonctions **Timer** ou [TimerSys](../WDLang1/3015006.md) à partir d'un thread secondaire (fonction [ThreadExécute](../WDLang1/3077024.md)) ne sera pas appelée. En effet, un thread secondaire n'a pas d'interface (c'est-à-dire pas de fenêtre ouverte) : ce thread secondaire ne reçoit pas les messages du système (la "boucle de message") comme le thread principal de l'application.
<a name="NOTE0_8"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png)![Windows](https://doc.pcsoft.fr/ext/images/fr/WINDOWS.png) 

### Timer et service Windows
<a name="timer_service_windows_ELTPARAGRAPHE000298"></a>Pour utiliser la fonction **Timer** depuis un [Service Windows](../WDLang1/1000017114.md), il est nécessaire d'appeler cette fonction à partir d'une fenêtre ouverte par le code du service. 

**Attention** : Cette solution n'est pas conseillée. Pour répéter un traitement depuis un service, il est conseillé d'appeler ce traitement à partir du code du service (le code du service s'exécutant en boucle).






- ![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=Lesalarmes.gif) ***Exemples unitaires (WINDEV)*** : **Les alarmes** <br>Mise en place d'une alarme pour afficher un message d'alerte dans la barre de titre de la fenêtre active (quelle que soit l'application). <br><br>Nous abordons les principaux thèmes suivants :<br>1/ Les fonctions système (récupération du handle d'une fenêtre)<br>2/ Le déclenchement d'un traitement selon une fréquence donnée (les timers)
- ![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=WDEcrandeveille.gif) ***Exemples didactiques (WINDEV)*** : **WD Ecran de veille** <br>Cet exemple illustre la réalisation d'un économiseur d'écran avec les fonctions WLangage.<br>Dans cet exemple, nous abordons les principaux thèmes suivants :<br>1/ l'appel périodique d'une procédure (les "timers")<br>2/ la gestion des événements Windows <br>3/ les fonctions système (appel d'API Windows)<br>Pour utiliser l'écran de veille :<br>- Renommer l'exécutable (.EXE) en .SCR<br>- Copier le fichier dans le répertoire de Windows (Ex: C:\WINDOWS)<br>- Ouvrir la fenêtre de propriétés d'affichage du bureau<br>- Choisir l'onglet "Ecran de Veille"<br>- Sélectionnez l'écran de veille généré avec WINDEV
- ![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=WDQuibloque.gif) ***Exemples didactiques (WINDEV)*** : **WD Qui bloque** <br>Cet exemple montre comment signaler aux utilisateurs d'une base de données HFSQL en réseau "qui" bloque un enregistrement inaccessible.<br><br>Dans cet exemple, nous abordons les principaux thèmes suivants :<br>1/ la gestion des accès concurrentiels<br>2/ le rafraîchissement automatique par timer<br>3/ la gestion d'un fichier "système" pour mémoriser des informations sur les verrous posés.<br><br>Résumé de l'exemple livré avec WINDEV :	<br>Cet exemple réalisé avec WINDEV est composé de 2 projets :<br>- WD Qui bloque : application de test gérant un fichier "client" en réseau<br>- WD Superviseur blocages : outil d'aministration pour visualiser les verrous posés et éventuellement forcer un déblocage.<br>Un utilisateur peut avoir conservé une fiche de saisie ouverte depuis un certain temps ; ce qui risque de gêner les autres utilisateurs.<br>Le bouton 'Libérez SVP' permet d'envoyer un message à l'utilisateur concerné pour lui demander de libérer l'enregistrement.<br>Le bouton 'Débloquer !' permet de forcer le déblocage de l'enregistrement. <br>Attention : Cette opération va envoyer un message forçant la fermeture de l'application ayant effectué le blocage.
- ![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=Gestiondestimers.gif) ***Exemples unitaires (WINDEV Mobile)*** : **Gestion des timers** <br>Mise en place d'un timer :<br>- démarrer un timer<br>- exécuter un code à chaque appel du timer<br>- arrêter un timer
- ![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=LesfonctionsChrono.gif) ***Exemples unitaires (WINDEV Mobile)*** : **Les fonctions Chrono** <br>Utilisation des fonctions WLangage "Chrono".<br>Ces fonctions permettent de calculer le temps écoulé entre le début (Fonction ChronoDébut) et la fin (Fonction ChronoFin)
- ![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=Gestiondestimers.gif) ***Exemples unitaires (WEBDEV)*** : **Gestion des timers** <br>Mise en place d'un timer :<br>- Démarrage d'un timer<br>- Exécution d'un code à chaque appel du timer<br>- Arrêt d'un timer



<a name="XComposante"></a>

## Composante :
wd280vm.dll
