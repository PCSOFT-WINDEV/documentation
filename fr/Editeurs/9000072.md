


## Procédures automatiques
			



<a name="NOTE1"></a>
<a name="NOTE1_1"></a>


## Présentation
<a name="presentation_ELTTEXTE000400"></a>
La programmation des timers, des threads, des procédures différées est désormais automatique, gérée par l'environnement.

Au lieu de programmer les traitements et de les synchroniser par le code WLangage, il suffit de configurer les options d'automatisme de la procédure.

C'est la fin des fonctions [TimerSys](../WDLang1/3015006.md), [Timer](../WDLang1/3015008.md), [ThreadExécute](../WDLang1/3077024.md), ... Ces fonctions sont bien entendu toujours présentes pour compatibilité.

Voici quelques exemples de traitements définissables sans une seule ligne de code :

- lancer une procédure toutes les 10 secondes (vérifier une boîte email, vérifier la présence d'un fichier sur le réseau, ...)

- idem, mais en ne commençant que 5 minutes après le lancement du programme.

- exécuter la procédure en tâche de fond (dans un thread), donc sans attendre sa valeur de retour.






<a name="NOTE2"></a>
<a name="NOTE2_1"></a>


## Comment le faire ?
<a name="comment_faire_ELTTEXTE000424"></a>


### Automatiser une procédure
<a name="automatiser_une_procedure_ELTPARAGRAPHE000044"></a>Pour automatiser une procédure :

1. Affichez le code de la procédure.

2. Affichez la fenêtre de description des automatismes de la procédure :

	- Cliquez sur l'icône ![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=Proc_auto_Ico.gif) présente dans le bandeau de la procédure.

	- Sélectionnez l'option "Paramétrer les automatismes de la procédure" dans le menu contextuel de la procédure (volet "Explorateur de projet").

	- Sélectionnez l'option "Propriétés" du menu contextuel de la procédure dans le volet "Code".




3. Dans la fenêtre qui s'affiche, sélectionnez le type d'automatisme : <br>![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=Proc_Auto%20-%20HC%20N%B0001.gif)


	- [Timer/Procédure différée](#NOTE2_2),

- [Thread (pour compatibilité)](#NOTE2_3),

- [Thread sécurisé](#NOTE2_3),

- [Thread principal](#NOTE2_4),



<a name="NOTE2_2"></a>


### Cas des timers / Procédures différées
<a name="cas_des_timers_procedures_differees_ELTPARAGRAPHE000089"></a>Les options sont les suivantes : 

- Nombre de fois : <br>![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=Timer_Comment.gif)
La procédure peut être exécutée :

	- ***une fois*** : la procédure s'arrêtera automatiquement après son exécution.

	- ***plusieurs fois*** : la procédure s'exécutera plusieurs fois d'affilé. Dans ce cas, il est possible d'espacer les exécutions de la procédure. Un timer sera donc mis en place automatiquement.




- Espacement entre les appels : Lorsque l'exécution est multiple ou infinie, permet de définir le délai entre 2 exécutions. 

	- ***un nombre infini de fois*** : la procédure s'exécutera un nombre infini de fois. Dans ce cas, il est possible d'espacer les exécutions de la procédure. Un timer sera donc mis en place automatiquement. 




- Il est possible de paramétrer les appels suivants de la procédure : 

	- **Ignorer le timer et exécuter immédiatement la procédure** : 
			Dans ce cas, un seul timer est en cours. Tout autre appel exécute immédiatement la procédure. 
			Exemple : rafraîchissement automatique toutes les minutes, exécuté immédiatement si on presse F5. 

	- **Déclencher un nouveau timer** : 
			Dans ce cas, plusieurs timers s'exécutent simultanément. 
			Exemple : déclencher un "polling" sur des éléments passés en paramètre.

	- **Relancer le timer existant** : 
			Le timer en cours est arrêté puis relancé, le délai avant la prochaine exécution est remis à zéro. 
			Exemple : déclencher une opération lorsque l'utilisateur arrête de taper au clavier. 




- Quand : <br>![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=Timer_Quand.gif&type=thumb)
La procédure peut être exécutée :

	- ***immédiatement*** : la procédure est exécutée dès qu'elle est appelée dans le code.

	- ***avec un démarrage automatique*** : la procédure est exécutée automatiquement après le code d'initialisation (de la fenêtre, de la page ou du projet). 

	- ***en différé*** : le procédure est exécutée après le délai spécifié. 
			Si l'exécution est différée, il est possible de conserver ou non cette attente pour les futurs appels de la procédure.

	- ***à la fin du traitement contenant l'appel*** : la procédure est exécutée lorsque le traitement contenant l'appel de la procédure est fini.

	- ***à la fin de l'événement contenant l'appel*** : la procédure est exécutée lorsque le traitement contenant l'appel de la procédure sera fini. Pour plus de détails, consultez le paragraphe [Option "A la fin de l'événement contenant l'appel"](#NOTE3_3).








<a name="NOTE2_3"></a>


### Cas des threads : thread (pour compatibilité) et thread sécurisé
<a name="cas_des_threads_thread_pour_compatibilite_thread_securise_ELTPARAGRAPHE000141"></a>Cette option permet de spécifier si la procédure doit s'exécuter en tâche de fond (dans un thread). 

Thread sécurisé : 
Lorsqu'un thread est sécurisé : 

- une erreur de compilation est affichée si les champs sont manipulés dans le thread (ou si la procédure est combinée avec l'attribut "UI"). 

- une exception est générée : 

	- lors de l'accès aux champs, 

	- si la fonction [ThreadArrête](../WDLang1/3077019.md) est utilisée. 




- la fermeture de la fenêtre qui a lancé le thread provoque une demande d'arrêt (mais le thread peut continuer à s'exécuter après la fermeture de la fenêtre). 




Les options sont les suivantes : 

- Nombre de fois : <br>![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=Thread_Comment.gif)
La procédure peut :

	- être exécutée ***une fois*** : la procédure s'arrêtera automatiquement après son exécution.

	- être exécutée ***plusieurs fois*** : la procédure s'exécutera plusieurs fois d'affilé. Dans ce cas, il est possible d'espacer les exécutions de la procédure. Un timer sera donc mis en place automatiquement.

	- être exécutée ***un nombre infini de fois*** : la procédure s'exécutera un nombre infini de fois. Dans ce cas, il est possible d'espacer les exécutions de la procédure. Un timer sera donc mis en place automatiquement.

	- **utiliser ou non HFSQL** : Cette option permet de spécifier si le thread doit faire des accès à des fichiers de données HFSQL. 
			Deux types d'accès sont disponibles : 

		- Copie de contexte complète : Permet de copier le contexte des connexions, des positions, des requêtes, ...

		- Copie de contexte légère : Permet de copier uniquement le contexte des connexions.




- Quand : <br>![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=Thread_Quand.gif&type=thumb)
La procédure peut être exécutée :

	- ***immédiatement*** : la procédure est exécutée dès qu'elle est appelée dans le code et automatiquement après le code d'initialisation (si l'option "Exécution automatique après le code d'initialisation" a été cochée).

	- ***en différé*** : le procédure est exécutée après le délai spécifié. 
			Si l'exécution est différée, il est possible de conserver ou non cette attente pour les futurs appels de la procédure.

	- ***à la fin du traitement contenant l'appel*** : la procédure est exécutée lorsque le traitement contenant l'appel de la procédure est fini.

	- ***à la fin de l'événement contenant l'appel*** : la procédure est exécutée lorsque le traitement contenant l'appel de la procédure sera fini. Pour plus de détails, consultez le paragraphe [Option "A la fin de l'événement contenant l'appel"](#NOTE3_3).






<a name="NOTE2_4"></a>


### Cas du thread principal
<a name="cas_thread_principal_ELTPARAGRAPHE000195"></a>Cette option permet d'appeler une procédure dans le thread principal à partir d'un thread secondaire. Cette option est notamment utilisée pour accéder à l'UI. <br>![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=Proc_Auto%20-%20HC%20N%B0004.gif&type=thumb)


Deux cas sont possibles : 

- Mode synchrone : Le thread secondaire **attend** la fin de l'exécution de la procédure du thread principal avant de continuer l'exécution. Cette option est équivalente à la fonction [ExécuteThreadPrincipal](../WDLang1/1000019862.md). 

- Mode asynchrone : Le thread secondaire **n'attend pas** la fin de l'exécution de la procédure du thread principal avant de continuer l'exécution. Cette option est équivalente à la fonction [ExécuteThreadPrincipalAsynchrone](../WDLang1/1410088684.md). 








<a name="NOTE3"></a>


## Remarques
<a name="remarques_ELTTEXTE000466"></a>
<a name="NOTE3_2"></a>


### Tableau récapitulatif
<a name="tableau_recapitulatif_ELTPARAGRAPHE000222"></a>Le tableau suivant permet de visualiser les différents cas d'exécution des procédures selon les options d'automatisme choisies :

|   |   | Appels suivants sans conserver l'espacement ou l'attente | Appels suivants avec conservation de l'espacement ou de l'attente |
| --- | --- | --- | --- |
| Procédure différée (option "Différé" cochée) | 1er appel manuel | Temporisation puis lancement de la procédure | Temporisation puis lancement de la procédure |
| Appels suivants | Lancement de la procédure | Temporisation puis lancement de la procédure |
| Procédure différée, répétée avec temporisation (options "Différé", "Infini" et "Espacer les appels" cochées) | 1er appel manuel | Temporisation -&gt; Procédure -&gt; temporisation-&gt; Procédure ... | Temporisation -&gt; Procédure -&gt; temporisation-&gt; Procédure ... |
| Appel suivants | Lancement de la procédure (une seule fois) | Temporisation -&gt; Procédure -&gt; temporisation-&gt; Procédure ... |
| Procédure différée, exécutée automatiquement (options "Différé" et "Exécution automatique..." cochées) | 1er appel automatique | Temporisation puis lancement de la procédure | Temporisation puis lancement de la procédure |
| Appels suivants | Lancement de la procédure | Temporisation puis lancement de la procédure |
| Procédure différée, exécutée automatiquement, répétée avec temporisation (options "Différé", "Infini", "Espacer les appels" et "Exécution automatique..." cochées) | 1er appel automatique | Temporisation -&gt; Procédure -&gt; temporisation-&gt; Procédure ... | Temporisation -&gt; Procédure -&gt; temporisation-&gt; Procédure ... |
| Appels suivants | Lancement de la procédure (une seule fois) | Temporisation -&gt; Procédure -&gt; temporisation-&gt; Procédure ... |


<a name="NOTE3_3"></a>


### Option "A la fin de l'événement contenant l'appel"
<a name="option_fin_evenement_contenant_appel_ELTPARAGRAPHE000290"></a>Les procédures avec l'option "A la fin de l'événement contenant l'appel" appelées depuis une procédure de callback (par exemple procédures utilisées par les fonctions [fListeFichier](../WDLang1/3036058.md), [Evénement](../WDLang1/3015011.md), ...) sont exécutées à la fin de chaque appel de la callback.

Exemple :

```txt
// -----------------
// cas normal
// -----------------
Clic de bouton
// début du code du clic de bouton
Proc1
// début du code de Procédure1
Proc2
// début du code de Procédure2

Appel de Procédure FinEvénément
// fin du code de Proc2
// fin du code de Proc1
// fin du code du clic de bouton
Exécution de Procédure FinEvénément
```



```txt
// -------------------
// cas callback
// -------------------
Clic de bouton
Proc1
Proc2
utilisation de la fonction fListeFichier
Procédure Callback1
// début du code de Procédure Callback1
ProcCallback2
// début du code de Procédure Callback2
Appel de ProcFinEvénément
// fin du code de ProcédureCallback2
// fin du code de ProcédureCallback1
Exécution de ProcFinEvénément
ProcédureCallback1
// début du code de ProcédureCallback1
ProcédureCallback2
// début du code de ProcédureCallback2
Appel de ProcFinEvénément
// fin du code de ProcédureCallback2
// fin du code de ProcédureCallback1
Exécution de ProcFinEvénément
```

<a name="NOTE3_4"></a>


### Arrêter une procédure automatique
<a name="arreter_une_procedure_automatique_ELTPARAGRAPHE000308"></a>Pour arrêter une procédure automatique, il suffit d'utiliser la fonction [FinAutomatismeProcédure](../WDLang1/3013034.md).
<a name="NOTE3_5"></a>


### Procédure avec lancement automatique de threads
<a name="procedure_avec_lancement_automatique_threads_ELTPARAGRAPHE000318"></a>Rappel : En WLangage, par défaut, chaque procédure fait une section critique automatique. Deux threads ne peuvent donc pas exécuter en même temps la même procédure.

Si une procédure qui déclenche automatiquement un thread est appelée deux fois :

- en mode par défaut : la première procédure se lance et la seconde procédure attend que la première ait fini pour se lancer.

- en mode ***threadSectionCritique*** (défini avec la fonction [ThreadMode](../WDLang1/3077028.md)), les deux threads se déclenchent en même temps.



<a name="NOTE3_6"></a>


### Programmation Orientée Objet (POO)
<a name="programmation_orientee_objet_poo_ELTPARAGRAPHE000333"></a>Lorsqu'un automatisme de procédure est défini sur une méthode de classe pour une exécution infinie par timer, un seul appel pour toutes les instances pourra être fait :

- si l'automatisme de la méthode est configuré avec "Faire uniquement l'appel" : seule une des instances de la classe fera l'appel de la méthode via le timer.

- si l'automatisme de la méthode est configuré avec "Lancer un timer supplémentaire" : toutes les instances de la classe feront un appel de la méthode pour l'instance en cours.


Si l'automatisme est configuré pour une exécution infinie dans un thread, toutes les instances de la classe feront un appel de la méthode pour l'instance en cours.
<a name="NOTE3_7"></a>



- ![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=LesfonctionsChrono.gif) ***Exemples unitaires (WINDEV)*** : **Les fonctions Chrono** <br>Utilisation des fonctions ChronoXXX.<br>Ces fonctions permettent de calculer le temps écoulé entre le début (Fonction ChronoDébut) et la fin (Fonction ChronoFin)
- ![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=WDEcrandeveille.gif) ***Exemples didactiques (WINDEV)*** : **WD Ecran de veille** <br>Cet exemple illustre la réalisation d'un économiseur d'écran avec les fonctions WLangage.<br>Dans cet exemple, nous abordons les principaux thèmes suivants :<br>1/ l'appel périodique d'une procédure (les "timers")<br>2/ la gestion des événements Windows <br>3/ les fonctions système (appel d'API Windows)<br>Pour utiliser l'écran de veille :<br>- Renommer l'exécutable (.EXE) en .SCR<br>- Copier le fichier dans le répertoire de Windows (Ex: C:\WINDOWS)<br>- Ouvrir la fenêtre de propriétés d'affichage du bureau<br>- Choisir l'onglet "Ecran de Veille"<br>- Sélectionnez l'écran de veille généré avec WINDEV
- ![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=WDQuibloque.gif) ***Exemples didactiques (WINDEV)*** : **WD Qui bloque** <br>Cet exemple montre comment signaler aux utilisateurs d'une base de données HFSQL en réseau "qui" bloque un enregistrement inaccessible.<br><br>Dans cet exemple, nous abordons les principaux thèmes suivants :<br>1/ la gestion des accès concurrentiels<br>2/ le rafraîchissement automatique par timer<br>3/ la gestion d'un fichier "système" pour mémoriser des informations sur les verrous posés.<br><br>Résumé de l'exemple livré avec WINDEV :	<br>Cet exemple réalisé avec WINDEV est composé de 2 projets :<br>- WD Qui bloque : application de test gérant un fichier "client" en réseau<br>- WD Superviseur blocages : outil d'aministration pour visualiser les verrous posés et éventuellement forcer un déblocage.<br>Un utilisateur peut avoir conservé une fiche de saisie ouverte depuis un certain temps ; ce qui risque de gêner les autres utilisateurs.<br>Le bouton 'Libérez SVP' permet d'envoyer un message à l'utilisateur concerné pour lui demander de libérer l'enregistrement.<br>Le bouton 'Débloquer !' permet de forcer le déblocage de l'enregistrement. <br>Attention : Cette opération va envoyer un message forçant la fermeture de l'application ayant effectué le blocage.
- ![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=Gestiondestimers.gif) ***Exemples unitaires (WEBDEV)*** : **Gestion des timers** <br>Mise en place d'un timer :<br>- Démarrage d'un timer<br>- Exécution d'un code à chaque appel du timer<br>- Arrêt d'un timer
- ![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=Gestiondestimers.gif) ***Exemples unitaires (WINDEV Mobile)*** : **Gestion des timers** <br>Mise en place d'un timer :<br>- démarrer un timer<br>- exécuter un code à chaque appel du timer<br>- arrêter un timer
- ![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=Lesalarmes.gif) ***Exemples unitaires (WINDEV)*** : **Les alarmes** <br>Mise en place d'une alarme pour afficher un message d'alerte dans la barre de titre de la fenêtre active (quelle que soit l'application). <br><br>Nous abordons les principaux thèmes suivants :<br>1/ Les fonctions système (récupération du handle d'une fenêtre)<br>2/ Le déclenchement d'un traitement selon une fréquence donnée (les timers)
- ![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=LesfonctionsChrono.gif) ***Exemples unitaires (WINDEV Mobile)*** : **Les fonctions Chrono** <br>Utilisation des fonctions WLangage "Chrono".<br>Ces fonctions permettent de calculer le temps écoulé entre le début (Fonction ChronoDébut) et la fin (Fonction ChronoFin)


