


## RAD MVP
			



<a name="NOTE1"></a>
<a name="NOTE1_1"></a>


## Présentation
<a name="presentation_ELTTEXTE000310"></a>
WINDEV propose un RAD MVP qui génère les fenêtres "table" et "fiche" et les classes Présentation et Modèle nécessaires.

Les fenêtres correspondent aux Vues du MVP.

Le code généré est librement et entièrement adaptable en fonction des besoins : il s'agit de la génération d'un squelette de base de l'application.

**Attention** : Ce mode de développement utilise la POO : il est obligatoire d'en maîtriser les concepts. Ce mode de développement est un mode de développement avancé. 



<a name="NOTE2"></a>
<a name="NOTE2_1"></a>
![WINDEV](https://doc.pcsoft.fr/ext/images/fr/WD.png) 

## Comment le faire ?
<a name="comment_faire_ELTTEXTE000334"></a>


### Les étapes de la génération de la fenêtre
<a name="les_etapes_generation_fenetre_ELTPARAGRAPHE000032"></a>Pour générer une fenêtre en mode "RAD MVP" : 

1. Cliquez sur ![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=ico_nouveau.gif)
 parmi les boutons d'accès rapide : 

	- La fenêtre de création d'un nouvel élément s'affiche : cliquez sur "Fenêtre" puis sur "Fenêtre". 

	- L'assistant de création d'une fenêtre se lance.




2. Dans l'assistant : 

	- Cliquez sur l'onglet "RAD". 

	- Sélectionnez le pattern "RAD MVP". 

	- Sélectionnez le type de fenêtre à générer (Fiche ou Table). 

	- Validez l'assistant de création d'une fenêtre.

	- L'assistant de génération RAD MVP se lance.  




3. Dans l'assistant : 

	- Indiquez si le RAD doit créer une nouvelle classe Présentation (option nécessaire si vous n'avez pas déjà utilisé le RAD MVP). 

	- Indiquez si le RAD doit créer une nouvelle classe Modèle (option nécessaire si vous n'avez pas déjà utilisé le RAD MVP). 

	- Sélectionnez le fichier de données à manipuler. 

	- Sélectionnez les rubriques à manipuler. 

	- Indiquez si le RAD doit créer une nouvelle classe de gestion des erreurs (option nécessaire si vous n'avez pas déjà utilisé le RAD MVP). 

	- Personnalisez si nécessaire le nom des classes qui vont être générées. 

	- Sélectionnez les membres de la classe modèle à afficher dans la fenêtre (la vue). 

	- Indiquez le titre et le nom de la fenêtre qui va être générée. 




4. Validez l'assistant. 



<a name="NOTE2_2"></a>


### Les éléments générés par le RAD
<a name="les_elements_generes_par_rad_ELTPARAGRAPHE000064"></a>Lors d'une génération d'une fenêtre Fiche et d'une fenêtre Table sur un fichier de données "MonFichierExemple", le RAD MVP génère 6 classes et 2 fenêtres.

Le RAD MVP génère 2 classes de "base" :

- **MBase** : classe de base de toutes les classes Modèle (M pour Modèle). Elle contient les fonctionnalités de base du code métier (qui seront partagées avec les autres classes modèles grâce à l'héritage).

- **CErreur** : classe de gestion des erreurs. Cette classe centralise le code de gestion des erreurs qui pourraient éventuellement remonter des différentes classes (erreurs métier ou de base de données).




Le RAD MVP a généré également 2 classes de la couche "Modèle", spécifiques au projet :

- **MMonFichierExemple** : classe reflétant les données métier. Dans cet exemple, cette classe "mappe" directement la structure du fichier "MonFichierExemple" de la base de données (grâce à l'attribut "mapping").

- **MTableauMonFichierExemple** : classe modèle pour la fenêtre table. Elle contient donc un tableau d'objets MMonFichierExemple.




Le RAD MVP a également généré 2 classes de la couche "Présentation", spécifiques au projet.

- **PTableMonFichierExemple** : gère l'affichage des données dans la vue / fenêtre table.

- **PFicheMonFichierExemple** : gère l'affichage des données dans la vue / fenêtre fiche.



<a name="NOTE2_3"></a>


### Gestion des erreurs dans les classes générées par le RAD MVP
<a name="gestion_des_erreurs_dans_les_classes_generees_par_rad_mvp_ELTPARAGRAPHE000086"></a>Dans le RAD MVP, les erreurs sont gérées via une classe **CErreur**. Chaque procédure de la présentation attend un paramètre de type **CErreur**. Les vues peuvent ainsi récupérer les erreurs éventuelles générées par la présentation.

```wl
clErreur est un CErreur
// Validation
SI PAS gclPresentation.bOK(clErreur) ALORS
	Erreur(clErreur.FormateMessage())
	RETOUR
FIN
```
En effet, seule la vue affiche les erreurs éventuelles (et non le modèle ou la présentation).

Ce mode de gestion des erreurs (procédure attendant le paramètre **CErreur**) incite à plus de rigueur dans le développement de l'application.

<a name="NOTE3"></a>
<a name="NOTE3_1"></a>


## WLangage : Spécificités permettant de simplifier l'architecture MVP
<a name="wlangage_specificites_permettant_simplifier_architecture_mvp_ELTTEXTE000370"></a>


### Présentation
<a name="presentation_ELTPARAGRAPHE000098"></a>Afin de simplifier la mise en oeuvre d'une architecture MVP, il est important de connaître et de comprendre les éléments spécifiques du WLangage :

- l'attribut **mapping** (ainsi que les mots-clés **MonFichierMappé** et **MaCléUniqueMappée**),

- l'attribut **associé**,

- l'attribut **présentation**,

- les fonctions [DemandeMiseAJourUI](../WDLang1/1000023899.md) et [DemandeMiseAJourUIParent](../WDLang1/1000023900.md) et l'événement "Mise à jour" de la fenêtre (ou de l'état).


Le RAD MVP utilise ces fonctionnalités, mais elles sont utilisables librement dans tout type d'architecture.


<a name="NOTE3_2"></a>


### Attribut "mapping"
<a name="attribut_mapping_ELTPARAGRAPHE000131"></a>L'attribut **mapping** permet de réaliser une "liaison directe" entre la classe et le fichier de données.

Exemple : 

```wl
MMonFichierExemple est une Classe,mapping = MonFichierExemple
```
Grâce à cet attribut : 

- la fonction [MémoireVersFichier](../WDLang1/3013070.md) va automatiquement recopier la valeur des membres de la classe dans les rubriques de l'enregistrement en cours du fichier de données. 

- la fonction [FichierVersMémoire](../WDLang1/3013071.md) va automatiquement recopier les rubriques de l'enregistrement en cours du fichier de données dans les membres de la classe.




**Important** : 

- Par défaut, pour que ce mécanisme fonctionne, les noms des membres de la classe doivent être identiques aux noms des rubriques dans le fichier de données.

- En cas de besoin : l'attribut **mapping** permet d'utiliser des préfixes ou des noms différents de ceux de l'analyse. Il suffit de réutiliser le mot-clé **mapping** sur les membres de la classe pour recréer la liaison entre le membre et sa rubrique de l'analyse. 
	Exemple : 
	
	```wl
	m_sTitreBien est une chaîne ANSI <mapping=TitreBien>
	```




<a name="NOTE3_3"></a>


### Mots-clés MonFichierMappé et MaCléUniqueMappée
<a name="motscles_monfichiermappe_macleuniquemappee_ELTPARAGRAPHE000160"></a>Dans la classe MBase générée par le RAD MVP, deux mots-clés sont utilisés pour simplifier la gestion du mapping : MonFichierMappé et MaCléUniqueMappée. Ces mots-clés servent à connaître, au niveau de la classe de base MBase, le fichier et la clé unique du modèle : 

- **MonFichierMappé** référence le fichier de données défini avec le mot-clé **mapping** dans la classe "Modèle". 
	Par exemple, le code suivant est utilisé dans la méthode bEnregistrer de la classe MBase : 
	
	```wl
	HRAZ(MonFichierMappé)
	```

	Ce code va effectuer un appel à la fonction [HRAZ](../WDLang4/3044118.md) sur le fichier de données pour lequel le RAD a été généré. 

- **MaCléUniqueMappée** référence la rubrique définie par le mapping "clé unique" dans la classe "Modèle".
	Par exemple, dans la classe MMonFichierExemple, MaCléUniqueMappée est équivalent à la rubrique IDMonFichierExemple :
	
	```wl
	m_nIDMonFichierExemple est un entier<mapping=IDMonFichierExemple, clé unique>
	```



Ces mots-clés permettent de faire du code générique dans cette classe de base. 
<a name="NOTE3_4"></a>


### Attribut "associé"
<a name="attribut_associe_ELTPARAGRAPHE000185"></a>L'attribut **associé** permet d'accéder aux membres, aux méthodes et aux propriétés d'une classe Modèle depuis sa classe Présentation, sans avoir à effectuer de "rebonds".
Exemple : 

```wl
PFicheMonFichierExemple est une Classe
PROTÉGÉ
m_clModeleCourant est un MMonFichierExemple <associé>
```
Dans l'exemple ci-dessus, les objets PFicheMonFichierExemple ont un membre "associé" de type MMonFichierExemple.

Les objets PFicheMonFichierExemple exposent alors directement les méthodes, propriétés et membres de la classe associée, sans avoir besoin de les redéfinir.

Grâce à l'attribut **associé**, il n'est plus nécessaire de recréer systématiquement toutes les propriétés dans la classe présentation pour exposer les membres du modèle.

L'architecture MVP générée par le RAD contient des classes génériques et des classes spécifiques au projet. Elle est entièrement personnalisable !

Il suffira de créer les méthodes et les propriétés souhaitées dans la classe "Présentation" pour surcharger les comportements du modèle.

Il est possible de lier un champ à un membre ou à une propriété de classe "Présentation". Il est donc possible d'effectuer cette liaison sur tous les membres ou propriétés du "Modèle", exposés par la classe "Présentation" grâce à ce mécanisme de "façade".
<a name="NOTE3_5"></a>


### Attribut "présentation" : gestion de l'actualisation des vues
<a name="attribut_presentation_gestion_actualisation_des_vues_ELTPARAGRAPHE000207"></a>L'attribut **présentation** est utilisé lors de la déclaration globale des fenêtres générées. Il permet d'associer une classe de la couche présentation à une vue (fenêtre ou état). 

Par exemple : 

```wl
PROCEDURE FEN_Table_MonFichierExemple(...
	gclPresentation est un PTableMonFichierExemple dynamique<présentation>=Null)
```
Grâce à cet attribut, l'appel de l'événement de mise à jour de l'affichage de la fenêtre sera déclenché par :

- tout appel à la fonction [DemandeMiseAJourUI](../WDLang1/1000023899.md) ou [DemandeMiseAJourUIParent](../WDLang1/1000023900.md) depuis une classe déclarée comme &lt;présentation&gt;,

- tout appel depuis toute classe associée à la classe &lt;présentation&gt;. 




**Par exemple**, lors de la suppression d'un élément dans une fenêtre Table générée par le RAD MVP, une demande de mise à jour de l'UI est effectuée par l'appel à la fonction [DemandeMiseAJourUI](../WDLang1/1000023899.md) :

- MTableauMonFichierExemple est un membre associé de PTableMonFichierExemple,

- PTableMonFichierExemple est défini comme "présentation" de la fenêtre "FEN_Table_MonFichierExemple".




L'événement de mise à jour de la fenêtre table "FEN_Table_MonFichierExemple" sera alors automatiquement appelé lors d'une suppression d'un élément.

L'événement de mise à jour de l'UI permet de regrouper tous les traitements de mises à jour de l'affichage de la fenêtre plutôt que de les répartir dans plusieurs événements (clic, etc.).

Ce mécanisme se retrouve également dans la fenêtre fiche. La fenêtre fiche est liée à la classe présentation PFicheMonFichierExemple contenant un membre associé MMonFichierExemple. Les demandes de mise à jour effectuées dans MMonFichierExemple "impactent" donc bien la fenêtre fiche.

**Attention** : L'événement de mise à jour de l'UI ne doit pas être exécuté "n'importe où". 

**Important** : les fonctions [DemandeMiseAJourUI](../WDLang1/1000023899.md) et [DemandeMiseAJourUIParent](../WDLang1/1000023900.md) sont asynchrones : l'événement de mise à jour de l'UI est exécuté à la fin du traitement en cours et les appels à la fonction [DemandeMiseAJourUI](../WDLang1/1000023899.md) ou [DemandeMiseAJourUIParent](../WDLang1/1000023900.md) ne sont pas empilés. Ces fonctions et ce mécanisme très pratique sont utilisables même en dehors d'une architecture MVP. **Ce fonctionnement offre un gros avantage** : si une boucle de traitement dans le modèle fait 50 appels à la fonction [DemandeMiseAJourUI](../WDLang1/1000023899.md), le WLangage ne réalisera qu'un seul et unique appel en sortie du traitement (évite de voir l'UI clignoter).
Note : pour effectuer une demande de mise à jour de l'UI de manière synchrone, il suffit d'utiliser la fonction WLangage [ExécuteMiseAJourUI](../WDLang1/1000023901.md) (ou [ExécuteMiseAJourUIParent](../WDLang1/1000023902.md)).


