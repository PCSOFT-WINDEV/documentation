


## Instructions SQL 
			



<a name="NOTE1"></a>
<a name="NOTE1_1"></a>


## Présentation
<a name="presentation_ELTTEXTE001014"></a>
Les principales instructions SQL autorisées dans les requêtes SQL gérées par WINDEV et WEBDEV sont les suivantes :

- [SELECT](#NOTE2)

- [INSERT](#NOTE3)

- [UPDATE](#NOTE4)

- [DELETE](#NOTE5)

- [CREATE TABLE](#NOTE6)

- [CREATE TABLE AS](#CREATEAS)

- [DROP TABLE](#NOTE7)

- [ALTER TABLE](#NOTE8)

- [CREATE INDEX](#NOTE9)

- [DROP INDEX](#NOTE17)

- [GRANT](#NOTE10)

- [REVOKE](#NOTE11)

- [CREATE VIEW](#NOTE12)

- [DROP VIEW](#NOTE13)

- [CREATE MATERIALIZED VIEW](#NOTE14)

- [DROP MATERIALIZED VIEW](#NOTE15)

- [REFRESH MATERIALIZED VIEW](#NOTE16)

- [OPTIMIZE TABLE](#NOTE18_1)




Pour plus de détails sur les instructions SQL, consultez une documentation spécifique au langage SQL.

Pour connaître toutes les commandes SQL (fonctions, clauses, opérateurs, ...) utilisables dans une requête SQL gérée par HFSQL, consultez [Commandes utilisables dans une requête SQL gérée par HFSQL](../Editeurs/2034006.md).



**Remarques** : 

- Ces instructions sont utilisables :

	- dans le code SQL des requêtes créées sous l'éditeur de requêtes. Ces requêtes sont ensuite exécutées grâce à la fonction [HExécuteRequête](../WDLang4/3044080.md).

	- dans le code SQL des requêtes exécutées avec la fonction du WLangage [HExécuteRequêteSQL](../WDLang4/3044084.md).




- Le caractère " peut être utilisé comme délimiteur d'identifiant dans les requêtes SQL comme prévu par la norme SQL92.


|   |   |   |
| --- | --- | --- |
| ![](https://doc.pcsoft.fr/fr-FR/images/image.awp?langid=5&name=ER.png) | Important | **[L'éditeur de requêtes Utilisateur](../Presentation/3088004.md)** ne permet pas de créer des requêtes en code SQL utilisant les ordres INSERT, UPDATE ou DELETE. |





<a name="NOTE2"></a>
<a name="NOTE2_1"></a>


## SELECT
<a name="select_ELTTEXTE001062"></a>


### SELECT
<a name="select_ELTPARAGRAPHE000110"></a>L'instruction **SELECT** permet de rechercher des enregistrements dans un ou plusieurs fichiers. 

**Format d'utilisation** :


```txt
SELECT [ALL/DISTINCT] NomDesRubriques AS NomDesRubriquesUtilisé
FROM NomDesFichiers AS NomDesFichiersUtilisé
[WHERE JointuresFichiers [AND] ConditionsSélection]
[GROUP BY NomDesRubriques [HAVING Condition]]
[ORDER BY NomDesRubriques]
```


**Exemple** : Le code SQL suivant permet de visualiser la somme totale des commandes par client habitant en Côte d'Or. Le résultat sera regroupé par nom du client, par code postal et par ville. Seuls les clients ayant un cumul des commandes supérieur à 3000 Euros seront conservés. Le résultat sera trié par ordre croissant selon le cumul des commandes :


```sql
SELECT CLIENT.NomClient AS NomClient,
CLIENT.CodePostal AS CodePostal,
CLIENT.Ville AS Ville,
SUM(COMMANDE.TotalTTC) AS TotalTTC
FROM CLIENT AS CLI, COMMANDE AS COM
WHERE CLI.NumClient = COM.NumClient
AND CodePostal LIKE '21%'
GROUP BY NomClient, CodePostal, Ville
HAVING TotalTTC > 3000
ORDER BY TotalTTC ASC
```


**Remarques** :

- Le mot-clé **DISTINCT** permet de supprimer les enregistrements dupliqués (doublons) du résultat de la requête.

- Pour plus de détails sur les conditions de sélection, consultez [Conditions de sélection dans une requête SQL](../Editeurs/2034008.md).

- Une requête de sélection peut être réalisée avec l'éditeur de requêtes. Pour plus de détails, consultez [Création d'une requête de sélection](../Editeurs/2032062.md).

- Dans la syntaxe de l'instruction SELECT, le paramètre NomDesRubriques peut contenir une ou plusieurs conditions de sélection. Par exemple : 
	
	```sql
	SELECT NomClient, Age>18 AS Majeur FROM Client
	```







- L'instruction **SELECT** peut être utilisée comme une expression scalaire, c'est-à-dire qu'il est possible d'utiliser l'instruction **SELECT** à la place d'une valeur ou d'une colonne dans des instructions comme **INSERT**, **UPDATE**, **SELECT**, etc. 
	Par exemple : 
	
	```sql
	INSERT INTO table (nom, valeur) VALUES ( 'Rome a Rick', 
	       (SELECT MAX(nombre) FROM table2) )
	```

	
	```sql
	UPDATE client SET cattc = (SELECT sum(facture.total_ttc) 
	       FROM facture WHERE facture.reference=client.reference)
	```

	
	```sql
	SELECT NomDesRubriques AS NomDesRubriquesUtilisé,
	       (SELECT COUNT(*) FROM Table2 WHERE Rub=NomDesRubriquesUtilisé)
	       FROM Table1
	```





Remarque : La requête SELECT utilisée comme expression scalaire doit renvoyer un résultat sur une seule colonne et une seule ligne.


### Cas particulier : SELECT multifichiers
<a name="cas_particulier_select_multifichiers_ELTPARAGRAPHE000156"></a>L'instruction SELECT permet également de sélectionner dans une requête multifichier toutes les colonnes d'un fichier de données grâce à la syntaxe suivante : 


```sql
SELECT Ligne_Commande.*,Commande.NumCommande, ...
FROM Commande, Ligne_Commande
```


Cette syntaxe est particulièrement intéressante dans le cadre de jointures et évite la saisie fastidieuse de chaque nom de rubrique. 


### Cas particuliers : SELECT sans FROM ou SELECT utilisant une table virtuelle
<a name="cas_particuliers_select_sans_from_select_utilisant_une_table_virtuelle_ELTPARAGRAPHE000167"></a>L'instruction SELECT permet également d'exécuter des requêtes ne portant pas sur des tables : 

- soit en utilisant la syntaxe sans clause "FROM". 
	Exemple : 
	
	```sql
	SELECT TO_CHAR(12,'RN')
	```


- soit en utilisant la table virtuelle DUAL. Cette table virtuelle contient une seule rubrique (nommée "dummy") et un seul enregistrement. 
	Exemple : 
	
	```sql
	SELECT CURRENT_DATE FROM DUAL
	```






### Exécuter une procédure stockée
<a name="executer_une_procedure_stockee_ELTPARAGRAPHE000183"></a>L'instruction SELECT permet également d'exécuter directement des procédures stockées. 

La syntaxe pour exécuter la procédure stockée est la suivante : 

```txt
SELECT NomDeLaProcédureStockée(ParamètreNumérique,'ParamètreChaîne',....) [FROM DUAL]
```


Remarques : 

- La procédure stockée doit être une fonction stockée : elle doit toujours renvoyer une valeur. Dans le cas contraire, une erreur d'exécution sera générée. 

- Si le nom de la procédure stockée est identique à celui d'une fonction ou procédure du projet, il est nécessaire de préfixer son nom par le nom de la collection de procédures stockées. 

- Le résultat d'une procédure stockée peut également être un des paramètres d'une requête de type SELECT. 




Pour plus de détails, consultez [Procédures et requêtes stockées (HFSQL Client/Serveur)](../WDLang4/3044360.md). 



<a name="NOTE3"></a>
<a name="NOTE3_1"></a>


## INSERT
<a name="insert_ELTTEXTE001104"></a>


### INSERT
<a name="insert_ELTPARAGRAPHE000207"></a>L'instruction **INSERT** permet d'ajouter  : 

- un enregistrement dans un fichier de données. 

- plusieurs enregistrements dans un fichier de données.




Son format d'utilisation est :


```txt
INSERT INTO NomDuFichier (NomDesRubriques)
VALUES (ValeurRubriques ajout 1), (ValeurRubriques ajout 2), ... , (ValeurRubriques ajout N)
```


**Exemples** : Les codes SQL suivants permettent d'insérer :

- un nouveau client dans le fichier CLIENT (l'ensemble des informations du client est fourni). 
	
	```sql
	INSERT INTO CLIENT
	VALUES (77, 'Martin', 'Julie', '1 rue Giono',...
	'69000', 'Lyon')
	```


- un nouveau client dans le fichier CLIENT : seuls le numéro, le nom et le prénom du client sont fournis :
	
	```sql
	INSERT INTO CLIENT (NumClient, NomClient, PrénomClient)
	VALUES (77, 'Martin', 'Julie')
	```


- 3 produits dans un fichier PRODUIT : 
	
	```sql
	INSERT INTO PRODUIT
	VALUES ('Ref01', 'Eau minérale'), ('Ref02', 'Beurre'), ('Ref03', 'Eponge')
	```





**Remarques** :

- Une requête d'insertion peut être créée sous l'éditeur de requêtes. Pour plus de détails, consultez [Création d'une requête d'insertion](../Editeurs/2032058.md).

- Pour connaître la valeur de l'identifiant automatique lors d'une requête de type INSERT sur des fichiers HFSQL (requête exécutée par la fonction [HExécuteRequêteSQL](../WDLang4/3044084.md), [HExécuteRequête](../WDLang4/3044080.md) ou [SQLExec](../WDLang4/3072007.md)), utilisez la variable SQL.IDAuto.

- Il n'est pas possible d'utiliser l'instruction INSERT pour copier les données d'un fichier HFSQL dans un autre fichier HFSQL.

- La variable [H.NbEnregRequêteModification](../WDLang4/3087002.md) permet de connaître le nombre d'enregistrements insérés.



<a name="NOTE3_2"></a>


### INSERT avec sélection
<a name="insert_avec_selection_ELTPARAGRAPHE000259"></a>L'instruction **INSERT** peut également être utilisée pour insérer une sélection d'enregistrements réalisée par une requête SELECT. Son format d'utilisation devient :

```txt
INSERT INTO NomDuFichier [(NomDesRubriques)] SELECT ...
```
**Remarques** :

- Le nombre de rubriques à insérer doit être identique au nombre de valeurs renvoyées par la requête SELECT.

- Si aucune rubrique n'est précisée dans l'instruction INSERT, toutes les rubriques du fichier sont prises en compte.

- Ce type de requête ne peut pas être créé directement dans l'éditeur de requêtes.




<a name="NOTE4"></a>
<a name="NOTE4_1"></a>


## UPDATE
<a name="update_ELTTEXTE001134"></a>
L'instruction** UPDATE** permet de mettre à jour des enregistrements dans un fichier. Son format d'utilisation est le suivant :

```txt
UPDATE NomDuFichier
SET NomDeLaRubrique = Expression
[WHERE Conditions]
```

**Exemples** : 

- Le code SQL suivant permet de modifier la civilité et le nom du client Montgomery :
	
	```sql
	UPDATE CLIENT
	SET Civilité = 'Mme',
	NomClient = 'Darwin'
	WHERE NomClient = 'Montgomery'
	```


- Le code SQL suivant permet de modifier le nom du client dans le fichier Client. Pour les enregistrements ayant le même identifiant, le nom du client dans le fichier Client est remplacé par le nom du client dans le fichier Client_Svg :
	
	```sql
	UPDATE CLIENT, CLIENT_SVG
	SET CLIENT.Nom = CLIENT_SVG.Nom
	WHERE CLIENT.ID = CLIENT_SVG.ID
	```





**Remarques** sur l'utilisation de l'instruction **UPDATE** dans WINDEV :

- La clause WHERE accepte des sous-sélections (par SELECT), à condition que la sous-sélection soit relative à un autre fichier.

- L'expression **SET** n'accepte pas de sous-sélection (pas de commande SELECT directement après **SET**). De la même façon il n'est pas possible de faire une jointure au niveau de la partie UPDATE de la requête.
	La requête suivante est acceptée :
	
	```sql
	UPDATE ARTICLE SET PrixVente = 1000
	WHERE RefArticle IN (SELECT COMMANDE.RefArticle FROM COMMANDE) 
	-- Sous-requête dans le WHERE: OK
	```

	La requête suivante **n'est pas acceptée** :
	
	```sql
	UPDATE Article 
	SET PrixVente = (SELECT AVG(COMMANDE.PrixUnit) FROM COMMANDE 
	-- Sous-requête dans le SET: NON VALIDE
	WHERE COMMANDE.RefArticle = ARTICLE.RefArticle
	GROUP BY COMMANDE.RefArticle)
	WHERE RefArticle IN (SELECT COMMANDE.RefArticle FROM COMMANDE)
	```

	Et de la même façon la requête suivante **n'est pas acceptée** :
	
	```sql
	UPDATE Article INNER JOIN PRODUIT ON (Article.IdArticle = Produit.IdProduit)
	 -- Jointure dans le UPDATE : NON VALIDE
	SET Article.PrixVente = Produit.PrixVente
	WHERE RefArticle IN (SELECT COMMANDE.RefArticle FROM COMMANDE)
	```


- Une requête de mise à jour peut être créée directement sous l'éditeur de requêtes. Pour plus de détails, consultez [Création d'une requête de modification](../Editeurs/2032057.md).

- L'apostrophe sert de délimiteur pour les chaînes dans les requêtes SQL. Si la valeur à écrire doit contenir une apostrophe, cette valeur doit être précédée du caractère **antislash** ('\\'). Par exemple :
	
	```sql
	UPDATE CLIENT
	SET Adresse = 'Rue de l\'écluse'
	WHERE NomClient = 'Montgomery'
	```


- La variable [H.NbEnregRequêteModification](../WDLang4/3087002.md) permet de connaître le nombre d'enregistrements mis à jour.




<a name="NOTE5"></a>
<a name="NOTE5_1"></a>


## DELETE
<a name="delete_ELTTEXTE001158"></a>
L'instruction **DELETE** permet de supprimer des enregistrements dans un fichier. Son format d'utilisation est le suivant :

```txt
DELETE FROM NomDuFichier
WHERE Conditions
```


**Exemple** : Le code SQL suivant permet de supprimer les clients nés entre le 01/01/1971 et le 01/01/1975 :


```sql
DELETE FROM CLIENT
WHERE CLIENT.DateNaissance BETWEEN '19710101' AND '19750101'
```


**Remarque** : Une requête de suppression peut être créée directement avec l'éditeur de requêtes. Pour plus de détails, consultez [Création d'une requête de suppression](../Editeurs/2032047.md).

<a name="NOTE6"></a>
<a name="NOTE6_1"></a>


## CREATE TABLE
<a name="create_table_ELTTEXTE001182"></a>
L'instruction CREATE TABLE permet de décrire une table et de la créer. Son format d'utilisation est le suivant :

```txt
CREATE TABLE NomTable
(
	Description de la rubrique1,
	Description de la rubrique2,
	 ...
	Description Index1,
	Description Index2,
	 ...
)
```


Dans cette syntaxe :

- les paramètres "Description de rubrique" correspondent à :
	
	```txt
	NomRubrique type  [DEFAULT 'valeur' | DEFAULT NULL] [NOT NULL] 
	   [UNIQUE] [PRIMARY KEY]  [AUTO_INCREMENT] [COMMENT 'libellé'] [COLLATE 'langue']
	```
où :

	- **NomRubrique** : nom à donner à la rubrique. 

	- **Type** : Type de la rubrique (choisi parmi les types disponibles présentés ci-dessous). 

	- **DEFAULT** : permet de fixer la valeur par défaut de la rubrique. 

	- **NOT NULL** : permet d'interdire d'affecter la valeur NULL à la rubrique. 

	- **UNIQUE** : permet de définir une rubrique avec ou sans doublons. 

	- **PRIMARY KEY** : permet de définir une clé primaire. 

	- **AUTO_INCREMENT** : permet de définir un identifiant automatique pour les rubriques de type entier.

	- **COMMENT** : permet de définir le libellé de la rubrique.

	- **COLLATE** : permet de définir la langue de tri de la rubrique (par exemple : 'FR_BE').




- les paramètres "Description d'index" correspondent à :
	
	```txt
	INDEX  NomIndex ( rub1 [ASC | DESC] [CI] [AI] [PI], rub2 ... ) [UNIQUE]
	```
où :

	- **ASC et DESC** : permet de définir le sens du tri. 

	- **CI** : permet d'indiquer que la case est ignorée.

	- **AI** : permet d'indiquer que les accents sont ignorés.

	- **PI** : permet d'indiquer que la ponctuation est ignorée.







**Remarque** : Ce type de requête ne peut pas être créé avec l'assistant de l'éditeur de requêtes.
<a name="NOTE6_2"></a>


### Types disponibles
<a name="types_disponibles_ELTPARAGRAPHE000372"></a>Les types disponibles sont :


|   |   |
| --- | --- |
| CHARACTER | Chaîne de caractères |
| CHARACTER(Taille) | Chaîne sur taille |
| VARCHAR(Taille) | Chaîne sur taille |
| CHARACTER VARYING(Taille) | Chaîne sur taille |
| CHAR VARYING(Taille) | Chaîne sur taille |
| NVARCHAR(Taille) | Chaîne Unicode sur taille |
| VARCHAR(Taille) BINARY | Chaîne binaire sur taille |
| BINARY(Taille) | Chaîne binaire sur taille |
| VARBINARY(Taille) | Chaîne binaire sur taille |
| BLOB | Mémo binaire |
| CLOB | Mémo texte |
| TEXT | Mémo texte |
| NCLOB | Mémo Unicode |
| NTEXT | Mémo Unicode |
| NUMBER(Précision) | Entier |
| NUMBER(Précision, échelle) | Entier |
| DECIMAL(Précision) | Réel |
| DECIMAL(Précision, échelle) | Réel |
| TINYINT UNSIGNED | Entier non signé sur 1 octet |
| SMALLINT UNSIGNED | Entier non signé sur 2 octets |
| INTEGER UNSIGNED | Entier non signé sur 4 octets |
| BIGINT UNSIGNED | Entier non signé sur 8 octets |
| TINYINT | Entier signé sur 1 octet |
| SMALLINT | Entier signé sur 2 octets |
| INTEGER | Entier signé sur 4 octets |
| BIGINT | Entier signé sur 8 octets |
| FLOAT | Réel sur 4 octets |
| REAL | Réel sur 8 octets |
| DOUBLE PRECISION | Réel sur 8 octets |
| MONEY | Monétaire |
| DATE | DATE |
| DATETIME | Date heure |
| TIME | Heure |
| SECUREPASSWORD | Mot de passe sécurisé |



<a name="CREATEAS"></a>
<a name="CREATEAS_1"></a>


## CREATE TABLE AS
<a name="create_table_ELTTEXTE001212"></a>
L'instruction CREATE TABLE AS permet de décrire une table et de la créer à partir du résultat d'une requête de sélection. Les colonnes de la table ont les noms et les types de données associés aux colonnes en sortie de la requête de type SELECT.

Son format d'utilisation est le suivant :

```txt
CREATE TABLE NomTable AS RequêteSélection [WITH NO DATA]
```
Dans cette syntaxe : 

- RequêteSélection est une requête de sélection (SELECT). La requête est exécutée et la table est créée à partir du résultat de cette requête de sélection. 

- L'option "WITH NO DATA" permet de créer uniquement la structure de la table (sans les données contenues dans le résultat de la requête de sélection). 




Attention : La table créée peut avoir un index différent de la table d'origine. 

**Remarque** : Ce type de requête ne peut pas être créé avec l'assistant de l'éditeur de requêtes.

<a name="NOTE7"></a>
<a name="NOTE7_1"></a>


## DROP TABLE
<a name="drop_table_ELTTEXTE001236"></a>
L'instruction DROP TABLE permet de supprimer physiquement une table. Son format d'utilisation est le suivant :

```txt
DROP TABLE [ IF EXISTS ] name [, ...]
```


**Remarques** :

- IF EXISTS permet de ne pas renvoyer d'erreur si la table n'existe pas.

- Ce type de requête ne peut pas être créé avec l'assistant de l'éditeur de requêtes.




<a name="NOTE8"></a>
<a name="NOTE8_1"></a>


## ALTER TABLE
<a name="alter_table_ELTTEXTE001260"></a>
L'instruction ALTER TABLE permet de changer la structure d'une table existante. Par exemple, vous pouvez ajouter ou supprimer des colonnes, des index, changer le type des colonnes existantes, renommer ces colonnes, ou la table elle-même. Son format d'utilisation est le suivant :

```txt
ALTER TABLE NomTable Action [, Action] ....
```


Dans cette syntaxe : 

- les paramètres "Action" correspondent à une des actions suivantes :
	
	```txt
	ADD [COLUMN] Description de rubrique
	ADD [COLUMN] (Description de rubrique1 [,Description de rubrique2]....)		
	DROP [COLUMN] [IF EXISTS] NomRubrique	
	DROP [COLUMN] [IF EXISTS] (NomRubrique1 [, NomRubrique2]...)	
	ALTER [COLUMN] NomRubrique [SET DATA] TYPE alter_type_desc	
	ALTER [COLUMN] NomRubrique SET DEFAULT <valeur>	
	ALTER [COLUMN] NomRubrique DROP DEFAULT
	ADD [UNIQUE / PRIMARY KEY] INDEX [<NomIndex>] (Description d'index
				 [, Description d'index2], ...)
	DROP INDEX [IF EXISTS] NomIndex			
	DROP INDEX [IF EXISTS] (NomIndex1 [, NomIndex2]...)	
	RENAME COLUMN NomRubrique TO Nouveau_NomRubrique
	```





- Les paramètres "Description de rubrique" correspondent à :
	
	```txt
	NomRubrique type  [DEFAULT 'valeur' | DEFAULT NULL] [NOT NULL] [UNIQUE] [PRIMARY KEY]
	  [AUTO_INCREMENT] [COMMENT 'libellé'] [COLLATE 'langue']
	```
où :

	- **NomRubrique** : nom à donner à la rubrique. 

	- **Type** : Type de la rubrique (choisi parmi les types disponibles présentés ci-dessus). 

	- **DEFAULT** : permet de fixer la valeur par défaut de la rubrique. 

	- **NOT NULL** : permet d'interdire d'affecter la valeur NULL à la rubrique. 

	- **UNIQUE** : permet de définir une rubrique avec ou sans doublons. 

	- **PRIMARY KEY** : permet de définir une clé primaire. 

	- **AUTO_INCREMENT** : permet de définir un identifiant automatique pour les rubriques de type entier.

	- **COMMENT** : permet de définir le libellé de la rubrique.

	- **COLLATE** : permet de définir la langue de tri de la rubrique (par exemple : 'FR_BE').

	- **SECUREPASSWORD** : permet de définir que la rubrique est du type "Mot de passe". 




- les paramètres "Description d'index" correspondent à :
	
	```txt
	NomRubrique [ASC | DESC] [CI] [AI] [PI]
	```
où :

	- **ASC et DESC** : permet de définir le sens du tri. 

	- **CI** : permet d'indiquer que la case est ignorée.

	- **AI** : permet d'indiquer que les accents sont ignorés.

	- **PI** : permet d'indiquer que la ponctuation est ignorée.







**Remarques** : 

- Ce type de requête ne peut pas être créé avec l'assistant de l'éditeur de requêtes.

- Pour utiliser la table modifiée lors du ALTER (sans analyse liée au projet), il faut utiliser la fonction [HDéclareExterne](../WDLang4/3044204.md) après l'exécution de la requête de type ALTER TABLE.




<a name="NOTE9"></a>
<a name="NOTE9_1"></a>


## CREATE INDEX
<a name="create_index_ELTTEXTE001284"></a>
L'instruction CREATE INDEX est équivalente à l'instruction ALTER TABLE pour créer des index. Cette instruction permet d'ajouter des index à une table existante. Son format d'utilisation est le suivant :

```txt
CREATE [UNIQUE] INDEX [NomIndex] ON NomTable (Description d'index [, Description d'index]... )
```


Dans ce code, les paramètres "Description d'index" correspondent à :

```txt
NomRubrique [ASC | DESC] [CI] [AI] [PI]
```


où :

- **ASC et DESC** : permet de définir le sens du tri. 

- **CI** : permet d'indiquer que la case est ignorée.

- **AI** : permet d'indiquer que les accents sont ignorés.

- **PI** : permet d'indiquer que la ponctuation est ignorée.




**Remarque** : Ce type de requête ne peut pas être créé avec l'assistant de l'éditeur de requêtes.

Il est possible d'utiliser l'instruction CREATE INDEX sur une vue matérialisée. Dans ce cas, le paramètre NomTable correspond au nom d'une vue matérialisée. Si la vue est rafraîchie, les index sont mis à jour automatiquement : il n'est pas nécessaire de recréer les index.

**Exemple :** Création d'une vue matérialisée et en même temps d'une clé composée sur cette vue. 

```sql
-- Création d'une vue matérialisée
CREATE MATERIALIZED VIEW MaVueMaterialisee AS 
	SELECT    
    	 Client.Departement, Client.Aff, Client.TypeAdherent, COUNT(*) AS Qte 
 	FROM Client  
 	WHERE Client.Solde>0 AND Client.Type=2  
 	AND Client.Famille IN ('A', 'D', 'O')  
 	GROUP BY Client.Departement, Client.Aff, Client.TypeAdherent; 
	--';' pour pouvoir mettre une autre instruction SQL après
	--Avec une clé composée
CREATE INDEX clecomp ON MaVueMaterialisee (Departement ASC CI AI PI,
			Aff ASC CI AI PI,TypeAdherent ASC)
```


<a name="NOTE17"></a>
<a name="NOTE17_1"></a>


## DROP INDEX
<a name="drop_index_ELTTEXTE001308"></a>
L'instruction DROP INDEX permet de supprimer physiquement un index d'une table. Son format d'utilisation est le suivant :

```txt
DROP INDEX  [ IF EXISTS ] NomIndex ON NomTable
```


où **IF EXISTS** : permet de ne pas renvoyer d'erreur si l'index n'existe pas.

**Remarque** : Ce type de requête ne peut pas être créé avec l'assistant de l'éditeur de requêtes.





<a name="NOTE10"></a>
<a name="NOTE10_1"></a>


## GRANT
<a name="grant_ELTTEXTE001332"></a>
Les requêtes de type GRANT permettent de donner des droits sur un serveur HFSQL. Cette instruction est équivalente à donner le droit *hAutorisé* à l'élément. Son format d'utilisation est le suivant :

- Donner les droits demandés sur les tables spécifiées aux utilisateurs spécifiés : 
	
	```txt
	GRANT droit[, droit [, ... ]] ON [TABLE] table [, table [, ...]]  
				TO utilisateur [, utilisateur [, ...]]
	```


- Donner les droits demandés sur les bases spécifiées aux utilisateurs spécifiés.
	
	```txt
	GRANT droit[, droit [, ... ]] ON DATABASE database [, database [, ...]] 
				TO utilisateur [, utilisateur [, ...]]
	```


- Donner les droits demandés sur le serveur.
	
	```txt
	GRANT droit[, droit [, ... ]] 
				TO utilisateur [, utilisateur [, ...]]
	```





**Remarque** : 

- Ce type de requête ne peut pas être créé avec l'assistant de l'éditeur de requêtes.

- Ces requêtes ne peuvent pas êtres utilisées sur une base de données HFSQL Classic ni sur une base de données accédée par les Connecteurs natifs. 




**Droits disponibles**
Les droits disponibles sont :


|   |   |
| --- | --- |
| **Droit SQL** | **Droit HFSQL** |
| INSERT | hDroitAjout |
| LOCK | hDroitBlocage |
| MANAGE RIGHTS | hDroitChangeDroit |
| OWNER | hDroitChangePropriétaire |
| MANAGE DUPLICATE | hDroitGèreDoublon |
| SELECT | hDroitLecture |
| MAINTENANCE | hDroitMaintenance |
| ALTER | hDroitModifAuto |
| UPDATE | hDroitModification |
| DELETE | hDroitSuppression |
| DELETE FILE | hDroitSuppressionFichier |
| REFERENCES | hDroitChangeLiaison |
| CONNECT | hDroitConnexion |
| ENCRYPTED CONNECT | hDroitConnexionCryptée |
| CREATE | hDroitCréationFichier |
| DEBUG | hDroitDéboguer |
| RUN PROCEDURE | hDroitExécutionProcédure |
| MANAGE REFERENCES | hDroitGèreIntégrité |
| MANAGE PROCEDURE | hDroitGestionProcédure |
| MANAGE TRIGGER | hDroitGestionTrigger |
| FORBID ACCESS | hDroitInterditAccèsBaseDeDonnées |
| BACKUP | hDroitSauvegarde |
| DELETE DATABASE | hDroitSuppressionBDD |
| STOP | hDroitArrêtServeur |
| CHANGE PASSWORD | hDroitChangeMotDePasse |
| CREATE DATABASE | hDroitCréationBDD |
| DISCONNECT | hDroitDéconnecteClient |
| SEND MESSAGE | hDroitEnvoieMessageVersClient |
| MANAGE TASK | hDroitGèreTâche |
| MANAGE SERVER | hDroitGestionServeur |
| MANAGE USER | hDroitGestionUtilisateur |
| READ LOG | hDroitLectureLogStat |
| PRIORITY | hDroitPriorité |
| REPLICATE | hDroitRéplicationServeur |
| SEE USER | hDroitVisualisationUtilisateur |



<a name="NOTE11"></a>
<a name="NOTE11_1"></a>


## REVOKE
<a name="revoke_ELTTEXTE001356"></a>
Les requêtes de type REVOKE permettent de retirer des droits (passent les droits en hHérité) sur un serveur HFSQL). Son format d'utilisation est le suivant :

- Mettre les droits demandés en hérité sur les tables spécifiées aux utilisateurs spécifiés.
	
	```txt
	REVOKE droit[, droit [, ... ]] ON [TABLE] table [, table [, ...]]  
				FROM utilisateur [, utilisateur [, ...]]
	```


- Mettre les droits demandés en hérité sur les bases spécifiées aux utilisateurs spécifiés.
	
	```txt
	REVOKE droit[, droit [, ... ]] ON DATABASE database [, database [, ...]] 
				FROM utilisateur [, utilisateur [, ...]]
	```


- Mettre les droits demandés en hérité sur le serveur.
	
	```txt
	REVOKE droit[, droit [, ... ]] FROM utilisateur [, utilisateur [, ...]]
	```





**Remarque** 

- Ce type de requête ne peut pas être créé avec l'assistant de l'éditeur de requêtes.

- Ces requêtes ne fonctionnent pas en HFSQL Classic ni via les Connecteurs Natifs. 




**Droits disponibles** : Les droits disponibles sont identiques à la commande SQL GRANT. Vous trouverez le tableau des droits au niveau de la commande GRANT.

<a name="NOTE12"></a>
<a name="NOTE12_1"></a>


## CREATE VIEW
<a name="create_view_ELTTEXTE001380"></a>
L'instruction **CREATE VIEW** permet de créer une vue SQL. Les vues SQL sont assimilées à des fichiers temporaires en mémoire. Une vue SQL est généralement un extrait d'un fichier ou de plusieurs fichiers. Une vue peut à son tour être manipulée par une commande SELECT.

Pour plus de détails sur les vues SQL, consultez [Vue SQL](../WDLang4/9000157.md). 

Son format d'utilisation est le suivant :

```txt
CREATE VIEW Vue [ ( Alias 1, Alias 2, ..., Alias N) ] AS RequêteSELECT
```


Dans cette syntaxe : 

- Vue est le nom de la vue. 

- Alias 1, Alias 2, Alias N représentent les noms d'alias donnés aux rubriques issues de la requête SELECT.

- RequêteSELECT est la requête de type SELECT permettant de sélectionner les enregistrements présents dans la vue. 




**Exemple SQL** : Création d'une vue SQL contenant uniquement la société, le nom et le téléphone des clients : 

```sql
CREATE VIEW V_Clients
AS SELECT Société, Nom, Téléphone FROM Clients
```


<a name="NOTE13"></a>
<a name="NOTE13_1"></a>


## DROP VIEW
<a name="drop_view_ELTTEXTE001404"></a>
La fonction **DROP VIEW** permet de supprimer une vue.

```txt
DROP VIEW [IF EXISTS] Vue 1 [, Vue 2, ...Vue N] [RESTRICT | CASCADE]
```


- Si le mot-clé **IF EXISTS** est indiqué et que la vue (ou les vues) n'existe(nt) pas, un message d'erreur est généré.

- Vue 1, Vue 2, ..., Vue N représentent la liste des vues à détruire.

- Si le mot-clé **RESTRICT** est indiqué, la vue n'est pas supprimée dans le cas où celle-ci est en cours d'utilisation.

- Si le mot-clé **CASCADE** est indiqué, la vue est supprimée ainsi que les vues dépendantes.




<a name="NOTE14"></a>
<a name="NOTE14_1"></a>


## CREATE MATERIALIZED VIEW
<a name="create_materialized_view_ELTTEXTE001428"></a>
Une vue matérialisée est une vue persistante : un fichier est créé sur disque avec le contenu de la vue. Cette vue pourra être manipulée plus tard par une autre application que celle qui l'a créée.

La fonction **CREATE MATERIALIZED VIEW** permet de créer une vue matérialisée.

```txt
CREATE MATERIALIZED VIEW Vue [ ( Alias 1, Alias 2, ...Alias N) ] 
	AS instruction SELECT [WITH [ NO ] DATA]
```


- Le mot-clé **WITH DATA** crée une vue avec les données.

- Le mot-clé **WITH NO DATA** crée une vue vide sans les données.




**Remarque** 

- Ce type de requête ne peut pas être créé avec l'assistant de l'éditeur de requêtes.

- Ces requêtes ne peuvent pas fonctionner en HFSQL Classic ni avec les Connecteurs Natifs. 




<a name="NOTE15"></a>
<a name="NOTE15_1"></a>


## DROP MATERIALIZED VIEW
<a name="drop_materialized_view_ELTTEXTE001452"></a>
La fonction **DROP MATERIALIZED VIEW** permet de supprimer physiquement sur le disque une vue matérialisée.

```txt
DROP MATERIALIZED VIEW [IF EXISTS] Vue 1 [, Vue 2, ...Vue N] [RESTRICT | CASCADE]
```


- Si le mot-clé **IF EXISTS** est indiqué et que la vue (ou les vues) n'existe(nt) pas, un message d'erreur est généré.

- Vue 1, Vue 2, ..., Vue N représentent la liste des vues à détruire.

- Si le mot-clé **RESTRICT** est indiqué, la vue n'est pas supprimée dans le cas où celle-ci est en cours d'utilisation.

- Si le mot-clé **CASCADE** est indiqué, la vue est supprimée ainsi que les vues dépendantes.




<a name="NOTE16"></a>
<a name="NOTE16_1"></a>


## REFRESH MATERIALIZED VIEW
<a name="refresh_materialized_view_ELTTEXTE001476"></a>
La fonction **REFRESH MATERIALIZED VIEW** permet d'actualiser le contenu sur le disque d'une vue matérialisée. La vue est recalculée dans sa totalité.

```txt
REFRESH MATERIALIZED VIEW Vue [WITH [ NO ] DATA]
```


- Le mot-clé **WITH DATA** actualise la vue avec les nouvelles données.

- Le mot-clé **WITH NO DATA** actualise la vue vide sans les données.




<a name="NOTE18"></a>
<a name="NOTE18_1"></a>


## OPTIMIZE TABLE
<a name="optimize_table_ELTTEXTE001500"></a>
La fonction **OPTIMIZE TABLE** permet de réorganiser et réindexer un fichier de données et de reconstruire les index de ce fichier. Cette opération permet notamment d'améliorer les performances.

Cette fonction est équivalente à utiliser la fonction WLangage [HRéindexe](../WDLang4/3044133.md) pour la réorganisation et réindexation d'un fichier de données.


```txt
OPTIMIZE TABLE NomFichier
```


NomFichier représente le nom du fichier à réorganiser.

Remarque : 

- Cette fonction est bloquante : le fichier de données n'est pas accessible durant l'exécution de la fonction. Il faut s'assurer que le fichier n'est pas en cours d'utilisation lors de l'appel de la fonction.

- Cette fonction ne peut pas être utilisée avec les Connecteurs Natifs. 

- Par défaut, la réindexation effectuée correspond aux paramètres suivants : réindexation normale, réindexation des index full text, réindexation en tâche de fond, avec un taux de densité de 80%. Pour utiliser d'autres paramètres, utilisez la fonction [HRéindexe](../WDLang4/3044133.md). 





