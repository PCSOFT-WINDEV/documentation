


## Fonctions SQL utilisables dans les requêtes SQL
			



<a name="NOTE1"></a>
<a name="NOTE1_1"></a>


## Présentation
<a name="presentation_ELTTEXTE002863"></a>
Les principales fonctions SQL pouvant être utilisées sur des requêtes en code SQL sont les suivantes (classées par thème) :


|   |   |
| --- | --- |
| <br><br>- extraction de caractères :<br><br><br> | <br><br>- [ELT](#SQL_ELT)<br><br>- [EXTRACTVALUE](#SQL_EXTRACTVALUE)<br><br>- [LEFT](#SQL_LEFT)<br><br>- [RIGHT](#SQL_RIGHT)<br><br>- [MID](#SQL_MID), <br><br>- [SPLIT_PART](#SQL_SPLITPART)<br><br>- [SUBSTR](#SQL_MID) et [SUBSTRING](#SQL_MID)<br><br><br> |
| <br><br>- suppression de caractères :<br><br><br> | <br><br>- [BTRIM](#SQL_BTRIM)<br><br>- [LTRIM](#SQL_LTRIM)<br><br>- [RTRIM](#SQL_RTRIM)<br><br>- [TRIM](#SQL_TRIM)<br><br><br> |
| <br><br>- substitution de caractères :<br><br><br> | <br><br>- [OVERLAY](#SQL_OVERLAY)<br><br>- [REPLACE](#SQL_REPLACE)<br><br>- [REVERSE](#SQL_REVERSE)<br><br>- [TRANSLATE](#SQL_TRANSLATE)<br><br><br> |
| <br><br>- fusion de chaînes :<br><br><br> | <br><br>- [CONCAT](#SQL_CONCAT)<br><br>- [GROUP_CONCAT](#SQL_GROUP_CONCAT)<br><br>- [STRING_AGG](#SQL_STRING_AGG)<br><br><br> |
| <br><br>- complétion de chaînes :<br><br><br> | <br><br>- [LPAD](#SQL_LPAD)<br><br>- [REPEAT](#SQL_REPEAT)<br><br>- [RPAD](#SQL_RPAD)<br><br>- [SPACE](#SQL_SPACE)<br><br><br> |
| <br><br>- conversion en chaîne de caractères :<br><br><br> | <br><br>- [TO_CHAR](#SQL_TO_CHAR)<br><br>- [CHAR](#SQL_CHAR)<br><br>- [CHR](#SQL_CHR)<br><br>- [CAST](#SQL_CAST)<br><br>- [CONVERT](#SQL_CONVERT)<br><br><br> |
| <br><br>- modification de la casse d'une chaîne de caractères :<br><br><br> | <br><br>- [INITCAP](#SQL_INITCAP)<br><br>- [LOWER](#SQL_LOWER)<br><br>- [UPPER](#SQL_UPPER)<br><br>- [LCASE](#SQL_LCASE)<br><br>- [UCASE](#SQL_UCASE)<br><br><br> |
| <br><br>- taille d'une chaîne de caractères :<br><br><br> | <br><br>- [LEN](#SQL_LEN) et [LENGTH](#SQL_LENGTH)<br><br>- CHARACTER_LENGTH, CHAR_LENGTH et OCTET_LENGTH<br><br><br> |
| <br><br>- position d'une chaîne de caractères :<br><br><br> | <br><br>- [INSTR](#SQL_INSTR)<br><br>- [FIELD](#SQL_FIELD)<br><br>- [FIND_IN_SET](#SQL_FIND_IN_SET)<br><br>- [PATINDEX](#SQL_PATINDEX)<br><br>- [POSITION](#SQL_POSITION)<br><br><br> |
| <br><br>- nombre d'enregistrements dans un fichier :<br><br><br> | <br><br>- [COUNT](#SQL_COUNT)<br><br><br> |
| <br><br>- calculs de numériques :<br><br><br> | <br><br>- [AVG](#SQL_AVG)<br><br>- [MAX](#SQL_MAX)<br><br>- [MIN](#SQL_MIN)<br><br>- [SUM](#SQL_SUM)<br><br>- [EVERY](#SQL_EVERY)<br><br><br>Voir aussi les [fonctions mathématiques SQL](../Editeurs/2034002.md). |
| <br><br>- sélection des n premiers ou des n derniers enregistrements :<br><br><br> | <br><br>- [TOP](#SQL_TOP)<br><br>- [BOTTOM](#SQL_BOTTOM)<br><br>- [LIMIT](#SQL_LIMIT)<br><br><br> |
| <br><br>- code ASCII<br><br><br> | <br><br>- [ASCII](#SQL_ASCII)<br><br><br> |
| <br><br>- Divers<br><br><br> | <br><br>- [UNICODE](#SQL_UNICODE)<br><br>- [CURRENT_USER](#SQL_CURRENT_USER)<br><br>- [SYSTEM_USER](#SQL_SYSTEM_USER)<br><br>- [USERNAME](#SQL_USER_NAME)<br><br><br> |
| <br><br>- phonétique<br><br><br> | <br><br>- [SOUNDEX, SOUND LIKE](#SQL_SOUNDEX, SOUND LIKE)<br><br>- [SOUNDEX2, SOUND2 LIKE](#SQL_SOUNDEX2, SOUND2 LIKE)<br><br><br> |
| <br><br>- gestion des dates<br><br><br> | <br><br>- [ADD_MONTHS](#SQL_ADD_MONTHS)<br><br>- [LAST_DAY](#SQL_LAST_DAY)<br><br>- [MONTHS_BETWEEN](#SQL_MONTHS_BETWEEN)<br><br>- [NEW_TIME](#SQL_NEW_TIME)<br><br>- [NEXT_DAY](#SQL_NEXT_DAY)<br><br>- [ROUND](#SQL_ROUND)<br><br>- [SYSDATE](#SQL_SYSDATE)<br><br>- [TRUNC](#SQL_TRUNC)<br><br>- [DAY](#SQL_DAY)<br><br>- [DAYOFMONTH](#SQL_DAYOFMONTH)<br><br>- [DAYOFWEEK](#SQL_DAYOFWEEK)<br><br>- [DAYOFYEAR](#SQL_DAYOFYEAR)<br><br>- [CURRENT_TIMESTAMP](#SQL_CURRENT_TIMESTAMP)<br><br>- [GETDATE](#SQL_GETDATE)<br><br>- [GETUTCDATE](#SQL_GETUTCDATE)<br><br>- [ISDATE](#SQL_ISDATE)<br><br>- [EOMONTH](#SQL_EOMONTH)<br><br>- [DATEADD](#SQL_DATEADD)<br><br>- [DATEDIFF](#SQL_DATEDIFF), [DATEDIFF_BIG](#SQL_DATEDIFF)<br><br>- [DATETIMEFROMPARTS](#SQL_DATETIMEFROMPARTS), [DATEFROMPARTS](#SQL_DATEFROMPARTS), [DATEPART](#SQL_DATEPART)<br><br>- [MONTH](#SQL_YEAR_MONTH), [YEAR](#SQL_YEAR_MONTH)<br><br><br> |
| <br><br>- fonctions de comparaison<br><br><br> | <br><br>- [COALESCE](#SQL_COALESCE)<br><br>- [GREATEST](#SQL_GREATEST)<br><br>- [IFNULL, ISNULL](#SQL_NVL_IF_NULL_IS_NULL)<br><br>- [NULLIF](#SQL_NULLIF)<br><br>- [LEAST](#SQL_LEAST)<br><br>- [NVL](#SQL_NVL_IF_NULL_IS_NULL)<br><br><br> |
| <br><br>- Instruction conditionnelle<br><br><br> | <br><br>- [DECODE](#SQL_DECODE)<br><br>- [CASE](#SQL_CASE)<br><br><br> |
| <br><br>- Recherche "full-text"<br><br><br> | <br><br>- [MATCH AGAINST](#SQL_MATCH AGAINST)<br><br><br> |
| <br><br>- Vérification<br><br><br> | <br><br>- [MD5](#SQL_MD5)<br><br>- [SHA et SHA1](#SQL_SHA)<br><br><br> |
| <br><br>- Expression régulière<br><br><br> | <br><br>- [REGEXP ou NOT REGEXP (négation)](#SQL_REGEXP)<br><br>- [RLIKE ou NOT RLIKE (négation)](#SQL_REGEXP)<br><br>- [~ ou !~ (négation)](#SQL_REGEXP)<br><br>- [REGEXP_LIKE ou NOT REGEXP_LIKE (négation)](#SQL_REGEXP)<br><br><br> |
| <br><br>- Fonctions et opérateurs sur les bits<br><br><br> | <br><br>- [BITAND, BITOR, BITXOR, BITNOT](#SQL_BITS)<br><br>- [BITANDNOT](#SQL_BITS)<br><br><br><br><br> |
| <br><br>- Opérateurs sur les JSON<br><br><br> | <br><br>- [JSON_OBJECT](#SQL_JSONOBJECT), [JSON_OBJECTAGG](#SQL_JSONOBJECTAGG)<br><br>- [JSON_ARRAY](#SQL_JSONARRAY), [JSON_ARRAYAGG](#SQL_JSONARRAYAGG)<br><br>- [IS JSON](#SQL_ISJSON)<br><br>- [JSON_EXISTS](#SQL_JSONEXISTS)<br><br>- [JSON_VALUE](#SQL_JSONVALUE)<br><br>- [JSON_QUERY](#SQL_JSONQUERY)<br><br><br> |


Pour plus de détails sur les fonctions SQL, consultez une documentation spécifique au langage SQL.

Pour connaître toutes les commandes SQL (fonctions, clauses, opérateurs, ...) utilisables dans une requête SQL gérée par HFSQL, consultez [Commandes utilisables dans une requête SQL gérée par HFSQL](../Editeurs/2034006.md).

**Remarques** :

- Ces instructions sont utilisables :

	- dans le code SQL des requêtes créées sous l'éditeur de requêtes. Ces requêtes sont ensuite exécutées grâce à la fonction [HExécuteRequête](../WDLang4/3044080.md).

	- dans le code SQL des requêtes exécutées avec la fonction du WLangage [HExécuteRequêteSQL](../WDLang4/3044084.md).




- Sauf indication contraire, ces fonctions sont utilisables sur tous les types de sources de données (Oracle, Access, SQL Server, ...).






<a name="NOTE2"></a>
<a name="NOTE2_1"></a>


## Fonctions SQL
<a name="fonctions_sql_ELTTEXTE002893"></a>


### Expression scalaire
<a name="expression_scalaire_ELTPARAGRAPHE000453"></a>Chaque paramètre passé à ces fonctions SQL correspond à une expression (appelée "Expression scalaire").

Une expression peut correspondre :

- à une ***constante*** : chaîne de caractères, entier, réel, caractère, ... Par exemple : 125, 'A', 'Dupont'.

- au ***nom d'une rubrique***.

- au ***résultat d'une autre fonction SQL***.

- à un ***calcul sur une expression***. Par exemple : "MaRubrique1+LEN(MaRubrique2)+1"



<a name="SQL_ELT"></a>
**ELT**
La fonction **ELT** renvoie la nième chaîne de caractères d'une liste de chaînes.

**Format d'utilisation** :

```txt
ELT(Numéro de la chaîne, Chaîne1, Chaîne2, Chaîne3, ...)
```


**Exemple** : Le code SQL suivant permet de sélectionner la première chaîne de la liste :

```sql
SELECT ELT(1, 'ej', 'Heja', 'hej', 'foo')
```

<a name="SQL_EXTRACTVALUE"></a>
**EXTRACTVALUE**
La fonction **EXTRACTVALUE** permet de manipuler des chaînes XML. Cette fonction renvoie le texte (CDATA) du premier noeud texte qui est un fils de l'élément correspondant à l'expression XPATH. Si plusieurs correspondances sont trouvées, le contenu du premier noeud texte fils de chaque noeud correspondant à l'expression XPATH est retourné sous forme d'une chaîne délimitée par des espaces. 

**Format d'utilisation** :

```txt
EXTRACTVALUE(Fragment de XML, Expression XPATH)
```


Le paramètre &lt;Fragment de XML&gt; doit être un fragment de XML valide. Il doit contenir une unique racine. 

**Exemple** : Le code suivant permet de compter les éléments trouvés : 

```sql
SELECT ExtractValue('<a><b/></a>', 'count(/a/b)') 
FROM CLIENT 
WHERE CLCLEUNIK=1
```

<a name="SQL_LEFT"></a>


### LEFT
<a name="left_ELTPARAGRAPHE000499"></a>La fonction **LEFT** extrait la partie gauche (c'est-à-dire les premiers caractères) d'une expression.
![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) Cette fonction ne peut pas être utilisée sur une source de données PostgreSQL.

**Format d'utilisation** :

```txt
LEFT(Expression initiale, Nombre de caractères à extraire)
```


**Exemple** : Le code SQL suivant permet de lister les départements des clients :

```sql
SELECT LEFT(CodePostal, 2)
FROM CLIENT
```

<a name="SQL_RIGHT"></a>


### RIGHT
<a name="right_ELTPARAGRAPHE000515"></a>La fonction **RIGHT** extrait la partie droite (c'est-à-dire les derniers caractères) d'une expression.

**Format d'utilisation** :

```txt
RIGHT(Expression initiale, Nombre de caractères à extraire)
```


**Exemple** : Le code SQL suivant permet d'extraire les cinq derniers caractères du nom des clients :

```sql
SELECT RIGHT(Nom, 5)
FROM CLIENT
```

<a name="SQL_MID"></a>


### MID, SUBSTR et SUBSTRING
<a name="mid_substr_substring_ELTPARAGRAPHE000528"></a>Les fonctions **MID, SUBSTR et SUBSTRING** permettent d'extraire une sous-chaîne du contenu d'une expression à partir d'une position donnée.

Si la position donnée correspond à :

- un nombre négatif, l'extraction se fera à partir de la fin de la chaîne.

- à 0, l'extraction se fera à partir du début de la chaîne (équivalent à la position 1).




Si la valeur absolue de la position donnée (connue grâce à la fonction [ABS](../Editeurs/2034002.md)) est supérieure au nombre de caractères de l'expression initiale, une chaîne vide est retournée.

**Exemple** : Le code SQL suivant permet d'extraire les villes dont le second caractère est un "A" :

```sql
SELECT 
	CODEPOSTAUX.IDCedex AS IDCedex,	
	CODEPOSTAUX.CodePostal AS CodePostal,	
	CODEPOSTAUX.Ville AS Ville,	
	SUBSTR(CODEPOSTAUX.Ville, 2, 1) AS Formule1
FROM 
	CODEPOSTAUX
WHERE 
	SUBSTR(CODEPOSTAUX.Ville, 2, 1) = 'A'
```

<a name="NOTE2_5"></a>


### MID
<a name="mid_ELTPARAGRAPHE000548"></a>La fonction **MID** peut être utilisée uniquement sur une source de données de type Access.

**Format d'utilisation** :

```txt
MID(Expression initiale, Position de départ, Nombre de caractères à extraire)
```


**Exemple** : Le code SQL suivant permet d'extraire les 3ème et 4ème caractères du nom des clients :

```sql
SELECT MID(Nom, 3, 2)
FROM CLIENT
```

<a name="NOTE2_6"></a>


### SUBSTR
<a name="substr_ELTPARAGRAPHE000561"></a>La fonction **SUBSTR** peut être utilisée uniquement sur une source de données de type Oracle, HFSQL Classic ou HFSQL Client/Serveur.

**Format d'utilisation** :

```txt
SUBSTR(Expression initiale, Position de départ, Nombre de caractères à extraire)
```


**Exemple** : Le code SQL suivant permet d'extraire les 3ème et 4ème caractères du nom des clients :

```sql
SELECT SUBSTR(Nom, 3, 2)
FROM CLIENT
```

<a name="SQL_SPLITPART"></a>
**SPLIT_PART**
La fonction **SPLIT_PART** découpe une chaîne de caractères selon le séparateur spécifié et renvoie la nième partie de la chaîne.

**Format d'utilisation** :

```txt
SPLIT_PART(Expression initiale, Délimiteur, Numéro de la partie à extraire)
```


**Exemple** : Le code SQL suivant permet d'extraire les 3 premiers mots correspondants à l'adresse :

```sql
SELECT split_part(ADRESSE,' ',1), split_part(ADRESSE,' ',2),split_part(ADRESSE,' ',3) 
FROM CLIENT 
WHERE CLCLEUNIK=2
```

<a name="SQL_BTRIM"></a>


### BTRIM
<a name="btrim_ELTPARAGRAPHE000591"></a>La fonction **BTRIM** supprime une séquence de caractères en début ou en fin de chaîne. 

**Format d'utilisation** :

```txt
BTRIM(<Chaîne d'origine>, [<Chaîne à supprimer>])
```


**Exemple** : Supprimer la chaîne 'AB' de la chaîne 'ABRACADABRA'

```sql
BTRIM('ABRACADABRA','AB')
```
Dans cet exemple, le résultat est 'RCDR'.
<a name="SQL_LTRIM"></a>


### LTRIM
<a name="ltrim_ELTPARAGRAPHE000605"></a>La fonction **LTRIM** renvoie une chaîne de caractères :

- soit sans les espaces situés à gauche.

- soit sans une liste de caractères.




La suppression des caractères s'effectue de la gauche vers la droite. Cette suppression est sensible à la casse (majuscule/minuscule). Cette suppression s'arrête sur le premier caractère trouvé n'appartenant pas à la liste spécifiée.

La suppression de caractères spécifiques ne peut pas être réalisée sur une source de données de type Access ou SQL Server.

**Format d'utilisation** :

```txt
-- Suppression des espaces situés à gauche
LTRIM(Expression initiale)
-- Suppression d'une liste de caractères
LTRIM(Expression initiale, Caractères à supprimer)
```


**Exemple** : Le nom des clients est précédé de la civilité des clients ("Mr.", "Mme." ou "Melle."). Le code SQL suivant permet de :

- supprimer la civilité de chaque nom (lettres "M", "r", "m", "e" et "l" et le caractère point).

- supprimer l'espace précédent le nom (espace qui était présent entre la civilité et le nom).



```sql
-- Suppression des caractères
SELECT LTRIM(Nom, 'Mrmel.')
FROM CLIENT
-- Suppression de l'espace
SELECT LTRIM(Nom)
FROM CLIENT
```
Dans cet exemple :

| Si le nom du client est : | La chaîne retournée est : |
| --- | --- |
| 'Melle. DUPONT' | 'DUPONT' |
| 'Mr. CIRVAL' | 'CIRVAL' |
| 'Mme. Dubois' | 'Dubois' |


<a name="SQL_RTRIM"></a>


### RTRIM
<a name="rtrim_ELTPARAGRAPHE000647"></a>La fonction **RTRIM** renvoie une chaîne de caractères :

- soit sans les espaces situés à droite.

- soit sans une liste de caractères.




La suppression des caractères s'effectue de la droite vers la gauche. Cette suppression est sensible à la casse (majuscule/minuscule). Cette suppression s'arrête sur le premier caractère trouvé n'appartenant pas à la liste spécifiée.

La suppression de caractères spécifiques ne peut pas être réalisée sur une source de données de type Access ou SQL Server.

**Format d'utilisation** :

```txt
-- Suppression des espaces situés à droite
RTRIM(Expression initiale)
-- Suppression d'une liste de caractères
RTRIM(Expression initiale, Caractères à supprimer)
```


**Exemple** : Le code SQL suivant permet de supprimer les caractères 'E', 'U' et 'R' situés à droite du nom des clients :

```sql
SELECT RTRIM(Nom, 'EUR')
FROM CLIENT
```
Dans cet exemple :

| Si le nom du client est : | La chaîne retournée est : |
| --- | --- |
| 'DUVALEUR' | 'DUVAL' |
| 'DRAFUREUR' | 'DRAF' |
| 'Galteur' | 'Galteur' |
| 'FOURMALTE' | 'FOURMALTE' |
| 'BENUR' | 'BEN' |


<a name="SQL_TRIM"></a>


### TRIM
<a name="trim_ELTPARAGRAPHE000693"></a>La fonction **TRIM** renvoie une chaîne de caractères :

- soit sans les espaces situés à gauche et à droite.

- soit sans une chaîne de caractères située en début et en fin de chaîne.

- soit sans une chaîne de caractères située en début de chaîne.

- soit sans une chaîne de caractères située en fin de chaîne.




La suppression des caractères s'effectue de la droite vers la gauche. Cette suppression est sensible à la casse (majuscule/minuscule). Cette suppression s'arrête sur le premier caractère trouvé n'appartenant pas à la chaîne spécifiée.

**Format d'utilisation** :

```txt
-- Suppression des espaces situés à gauche et à droite
TRIM(Expression initiale)
-- Suppression d'une chaîne de caractères située en début et en fin de chaîne
TRIM(Expression initiale, Chaîne à supprimer)
-- OU
TRIM(BOTH Chaîne à supprimer FROM Expression initiale)
-- Suppression d'une chaîne de caractères située en début de chaîne
TRIM(LEADING Chaîne à supprimer FROM Expression initiale)
-- Suppression d'une chaîne de caractères située en fin de chaîne
TRIM(TRAILING Chaîne à supprimer FROM Expression initiale)
```

<a name="SQL_OVERLAY"></a>


### OVERLAY
<a name="overlay_ELTPARAGRAPHE000712"></a>La fonction **OVERLAY** permet de remplacer une chaîne de caractères dans une autre. 

**Format d'utilisation** :

```txt
OVERLAY(<Chaîne d'origine> PLACING <Chaîne à remplacer> 
FROM <Position de début> [FOR <Longueur>])
```


Exemple : Le code SQL suivant permet de remplacer "verte" par "rouge" : 

```sql
SELECT OVERLAY('Pomme verte' PLACING 'rouge' FROM 7) FROM Produit
```

<a name="SQL_REPLACE"></a>


### REPLACE
<a name="replace_ELTPARAGRAPHE000725"></a>La fonction **REPLACE** renvoie une chaîne de caractères :

- soit en remplaçant toutes les occurrences d'un mot présent dans une chaîne par un autre mot.

- soit en remplaçant toutes les occurrences d'un mot présent dans une chaîne.




Le remplacement s'effectue de la droite vers la gauche. Ce remplacement est sensible à la casse (majuscule/minuscule). Ce remplacement s'arrête sur le premier caractère trouvé n'appartenant pas à la chaîne spécifiée.

**Format d'utilisation** :

```txt
-- Remplacement de toutes les occurrences d'un mot par un autre
REPLACE(Expression initiale, Chaîne à remplacer, Nouvelle chaîne)
-- Suppression de toutes les occurrences d'un mot
REPLACE(Expression initiale, Chaîne à supprimer)
```

<a name="SQL_REVERSE"></a>
**REVERSE**
La fonction **REVERSE** renvoie une chaîne de caractères dont l'ordre des caractères est l'inverse de la chaîne initiale. 

**Format d'utilisation** :

```txt
REVERSE(Chaîne initiale)
```

<a name="SQL_TRANSLATE"></a>


### TRANSLATE
<a name="translate_ELTPARAGRAPHE000752"></a>La fonction **TRANSLATE** renvoie une chaîne de caractères en remplaçant tous les caractères indiqués par d'autres caractères. Si un caractère à remplacer n'a pas sa correspondance, ce caractère est supprimé.

Le remplacement s'effectue de la droite vers la gauche. Ce remplacement est sensible à la casse (majuscule/minuscule).

**Format d'utilisation** :

```txt
-- Remplacement des caractères
TRANSLATE(Expression initiale, Caractères à remplacer, Nouveaux caractères)
```


Exemple : Le code SQL suivant permet de remplacer :

- le caractère "é" par le caractère "e".

- le caractère "è" par le caractère "e".

- le caractère "à" par le caractère "a".

- le caractère "ù" par le caractère "u".





```sql
SELECT TRANSLATE(MonChamp, 'éèàù', 'eeau')
FROM MaTable
```

<a name="SQL_CONCAT"></a>


### CONCAT
<a name="concat_ELTPARAGRAPHE000773"></a>La fonction **CONCAT** concatène plusieurs chaînes entre elles.

**Format d'utilisation** :

```txt
CONCAT(Chaîne 1, Chaîne 2 [, ..., Chaîne N])
```


![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) CONCAT n'est pas géré par Sybase.




<a name="SQL_GROUP_CONCAT"></a>


### GROUP_CONCAT
<a name="groupconcat_ELTPARAGRAPHE000790"></a>La clause **GROUP_CONCAT** permet de regrouper dans une même chaîne de caractères les différentes valeurs non nulles d'une rubrique issue d'une série d'enregistrements.

Chaque valeur peut être séparée par un caractère particulier (un espace, un ";", etc.). 

Cette fonction est utile par exemple pour regrouper des résultats en une seule ligne.

Si une clause GROUP BY est utilisée, les valeurs regroupées peuvent être assemblées sur un critère différent.

**Format d'utilisation** :


```txt
GROUP_CONCAT(<Nom colonne> SEPARATOR <Caractère de séparation>)
```


où : 

- &lt;Nom colonne&gt; représente la rubrique à regrouper.

- &lt;Caractère de séparation&gt; représente le caractère qui va séparer chaque valeur.




**Exemple** : Le code SQL suivant permet de récupérer la liste des jours de la semaine et celle des jours du week-end sur une ligne. Les jours sont séparés par un point virgule. 

La table "JOURSEMAINE" manipulée est la suivante : 

| TypeJour | NomJour |
| --- | --- |
| JourDeSemaine | Lundi |
| JourDeSemaine | Mardi |
| JourDeSemaine | Mercredi |
| JourDeSemaine | Jeudi |
| JourDeSemaine | Vendredi |
| Week-end | Samedi |
| Week-end | Dimanche |






```sql
SELECT TypeJour, GROUP_CONCAT(NomJour SEPARATOR ';')
FROM JOURSEMAINE
GROUP BY TypeJour
```


Le résultat affiché sera le suivant : 

```txt
'JourDeSemaine', 'Lundi;Mardi;Mercredi;Jeudi;Vendredi'
'Week-end', 'Samedi;Dimanche'
```





<a name="SQL_STRING_AGG"></a>


### STRING_AGG
<a name="stringagg_ELTPARAGRAPHE000858"></a>La fonction **STRING_AGG** permet de concaténer des chaînes non nulles d'une liste de valeurs.

**Format d'utilisation** :

```txt
STRING_AGG(chaîne, séparateur)
```
**Exemple** : 

Le code suivant permet de renvoyer dans une seule chaîne, la liste des modes de livraison séparée par un ';'.

```sql
select string_agg(libelle,';') as str from livraison
```


Contenu du fichier livraison : 

- Transporteur

- Colis Expresss

- Recommandé

- Pris sur place




Résultat retourné par la fonction STRING_AGG : "Transporteur;Colis Expresss;Recommandé;Pris sur place". 
<a name="SQL_LPAD"></a>


### LPAD
<a name="lpad_ELTPARAGRAPHE000881"></a>La fonction **LPAD** renvoie une chaîne de taille déterminée. Pour atteindre la taille requise, cette chaîne est complétée à gauche :

- soit par des espaces.

- soit par un caractère ou une chaîne donnée.




**Format d'utilisation** :

```txt
-- Complétion par des espaces
LPAD(Expression initiale, Longueur)
-- Complétion par un caractère
LPAD(Expression initiale, Longueur, Caractère)
-- Complétion par une chaîne de caractères
LPAD(Expression initiale, Longueur, Chaîne de caractères)
```

<a name="SQL_REPEAT"></a>
**REPEAT**
La fonction **REPEAT** renvoie une chaîne de caractères constituée de la n fois la répétition de la chaîne initiale. 

- Si n est inférieur ou égal à 0, la fonction renvoie une chaîne vide. 

- Si la chaîne initiale ou n sont NULL, la fonction renvoie NULL. 




**Format d'utilisation** :

```txt
REPEAT(Chaîne initiale, n)
```


**Exemple** : Le code suivant permet de répéter 3 fois le nom du contact : 

```sql
SELECT REPEAT(NOMCONTACT,14) 
FROM CLIENT  
WHERE CLCLEUNIK=10
```

<a name="SQL_RPAD"></a>


### RPAD
<a name="rpad_ELTPARAGRAPHE000912"></a>La fonction **RPAD** renvoie une chaîne de taille déterminée. Pour atteindre la taille requise, cette chaîne est complétée à droite :

- soit par des espaces.

- soit par un caractère ou une chaîne donnée.




**Format d'utilisation** :

```txt
-- Complétion par des espaces
RPAD(Expression initiale, Longueur)
-- Complétion par un caractère
RPAD(Expression initiale, Longueur, Caractère)
-- Complétion par une chaîne de caractères
RPAD(Expression initiale, Longueur, Chaîne de caractères)
```

<a name="SQL_SPACE"></a>
**SPACE**
La fonction **SPACE** renvoie une chaîne constituée de N espaces. 

**Format d'utilisation** :

```txt
SPACE(N)
```

<a name="SQL_TO_CHAR"></a>
**TO_CHAR**
La fonction **TO_CHAR** permet de convertir en chaîne de caractères : 

- une dateheure,

- une valeur numérique.




**Format d'utilisation** :

**1. Conversion d'une dateheure :** 

```txt
TO_CHAR(<Valeur dateheure>, <Format dateheure> [, <Options dateheure>])
```


Dans cette syntaxe : 

- Le paramètre &lt;Format dateheure&gt; peut correspondre à un des éléments suivants : 

	- "-", "/", ",", ".", ";", ":"

	- "text" : caractères de ponctuation (séparation) pour une date et/ou une heure.

	- AD, A.D. : Indicateur de l'ère AD pour une date (Après Jésus-Christ)

	- AM, A.M. : Indicateur du méridien AM pour l'heure (Anté méridien)

	- BC, B.C. : Indicateur de l'ère BC pour une date (Avant Jésus-Christ)

	- CC ou SCC Siècle : 

		- Si les deux derniers chiffres du siècle sur 4 chiffres sont compris entre 01 et 99 (inclus), le siècle est représenté par les 2 derniers chiffres de l'année.

		- Si les deux derniers chiffres du siècle sur 4 chiffres sont 00, alors le siècle est représenté par les 2 premiers chiffres de l'année.
						Par exemple, 2002 retourne 02; 2000 retourne 20.




- D : Numéro du jour dans la semaine (1-7). 

- DAY : Jour en lettres. 

- DD : Numéro du jour dans le mois (1-31).

- DDD : Numéro du jour dans l'année (1-366).

- DY : Jour en lettres abrégé

- FF [1..9] : Fractions de secondes. Le chiffre représente le nombre de chiffres représentant la fraction de seconde. Exemples :

	- 'HH:MI:SS.FF'

	- SELECT TO_CHAR(SYSTIMESTAMP, 'SS.FF3') from dual;

- Le paramètre &lt;Options dateheure&gt; est une chaîne de caractères contenant les mots-clés suivants : 

	- "NLS_DATE_LANGUAGE='langue en us'"

	- "NLS_NUMERIC_CHARACTERS ='dg'" : ‘dg' est une chaîne de deux caractères dont le premier correspond au séparateur décimal et le second correspond au séparateur de groupement (entre millier et centaine par exemple).
			Exemple : ‘NLS_DATE_LANGUAGE=*french*, NLS_NUMERIC_CHARACTERS =*, ‘*







**2. Conversion d'une valeur numérique** : 

```txt
TO_CHAR(<Valeur numérique>, <Format numérique> [, <Options numérique>])
```


- Le paramètre &lt;Format numérique&gt; peut correspondre à un des éléments suivants : 

	- , (virgule). Positionne une virgule à l'emplacement indiqué. Exemple : 9,999

	- . (point). Positionne une point à l'emplacement indiqué. Exemple : 99.99

	- 0. Complète avec des zéros devant ou derrière. Exemple : 0999 ou 9990

	- 9. Représente les chiffres. Exemple : 9999

	- B. Remplace les zéros par des espaces. Exemple : B9999

	- C. Positionne le symbole de devise selon la norme ISO quand le paramètre NLS_ISO_CURRENCY est utilisé. Exemple : C999

	- D. Indique la position du séparateur décimal quand le paramètre NLS_NUMERIC_CHARACTER est utilisé. Le (.) est le séparateur par défaut. Exemple : 99D99

	- EEEE. Retourne une valeur au format scientifique. Exemple : 9.9EEEE

	- G. Indique le séparateur de milliers quand le paramètre NLS_NUMERIC_CHARACTER est utilisé. Il est possible de spécifier plusieurs séparateurs de milliers. Exemple : 9G999

	- L. Indique la position du symbole de devise quand le paramètre NLS_ISO_CURRENCY est utilisé. Exemple : L999

	- MI. Place le signe - après des valeurs négatives. Exemple : 9999MI

	- PR. Place les valeurs négatives entre des chevrons. Exemple : 9999PR

	- rn ou RN. Retourne la valeur en chiffres romains en majuscules ou minuscules.

	- S. Indique le signe +/- Positif ou Négatif. Exemple : S9999

	- U. Indique le symbole monétaire Euro quand le paramètre NLS_DUAL_CURRENCY est utilisé. Exemple : U9999

	- V. Retourne la valeur en puissance de 10. Exemple 999V99

	- X. Retourne la valeur en hexadécimal. Exemple : XXXX




- Dans cette syntaxe, le paramètre &lt;Options numérique&gt; est une chaîne de caractères contenant les mots-clés suivants : 

	- "NLS_CURRENCY='monnaie en us'"

	- "NLS_NUMERIC_CHARACTERS ='dg'" : ‘dg' est une chaîne de deux caractères dont le premier correspond au séparateur décimal et le second correspond au séparateur de groupement (entre millier et centaine par exemple).
			Exemple : NLS_CURRENCY='$', NLS_NUMERIC_CHARACTERS='dg'







Remarque : Par défaut la langue, la monnaie, et les séparateurs sont déterminés par la nation en cours.
<a name="SQL_CHAR"></a>
**CHAR**
La fonction CHAR permet de convertir un code ASCII (un entier) en caractère.


**Format d'utilisation** :

```txt
CHAR(<Code ASCII>)
```
&lt;Code ASCII&gt; est un numérique et correspond au caractère ASCII à convertir, compris entre 0 et 255. Dans le cas contraire, le caractère renvoyé par la fonction est NULL.

Le résultat de la fonction est le caractère correspondant au code ASCII du paramètre &lt;Code ASCII&gt;. 

**Remarque** : Le résultat renvoyé dépend de l'alphabet courant.
<a name="SQL_CHR"></a>
**CHR**
La fonction CHR permet de convertir un code ASCII (un entier) en caractère.

```txt
CHR(<Code ASCII>)
```
&lt;Code ASCII&gt; est un numérique et correspond au caractère ASCII à convertir, compris entre 0 et 255. Dans le cas contraire, le caractère renvoyé par la fonction est NULL.

Le résultat de la fonction est le caractère correspondant au code ASCII du paramètre &lt;Code ASCII&gt;. 

**Remarques** : 

- Le résultat renvoyé dépend de l'alphabet courant.

- Si on est en UTF8, l'entier envoyé est interprété comme un "code point" sinon le caractère renvoyé correspond au caractère modulo 256.



<a name="SQL_CAST"></a>
**CAST**
La fonction CAST permet de convertir une donnée d'un type dans un autre.

```txt
CAST(Expression AS Type)
```


- Le paramètre &lt;Expression&gt; représente la valeur à convertir.

- Le paramètre &lt;Type&gt; représente le nouveau type dans lequel l'expression est convertie. Les types disponibles sont :





|   |   |
| --- | --- |
| CHARACTER | Chaîne de caractères |
| CHARACTER(Taille) | Chaîne sur taille |
| VARCHAR(Taille) | Chaîne sur taille |
| CHARACTER VARYING(Taille) | Chaîne sur taille |
| CHAR VARYING(Taille) | Chaîne sur taille |
| NVARCHAR(Taille) | Chaîne Unicode sur taille |
| VARCHAR(Taille) BINARY | Chaîne binaire sur taille |
| BINARY(Taille) | Chaîne binaire sur taille |
| VARBINARY(Taille) | Chaîne binaire sur taille |
| BLOB | Mémo binaire |
| CLOB | Mémo texte |
| TEXT | Mémo texte |
| NCLOB | Mémo Unicode |
| NTEXT | Mémo Unicode |
| NUMBER(Précision) | Entier |
| NUMBER(Précision, échelle) | Entier |
| DECIMAL(Précision) | Réel |
| DECIMAL(Précision, échelle) | Réel |
| TINYINT UNSIGNED | Entier non signé sur 1 octet |
| SMALLINT UNSIGNED | Entier non signé sur 2 octets |
| INTEGER UNSIGNED | Entier non signé sur 4 octets |
| BIGINT UNSIGNED | Entier non signé sur 8 octets |
| TINYINT | Entier signé sur 1 octet |
| SMALLINT | Entier signé sur 2 octets |
| INTEGER | Entier signé sur 4 octets |
| BIGINT | Entier signé sur 8 octets |
| FLOAT | Réel sur 4 octets |
| REAL | Réel sur 8 octets |
| DOUBLE PRECISION | Réel sur 8 octets |
| MONEY | Monétaire |
| DATE | DATE |
| DATETIME | Date heure |
| TIME | Heure |

Le résultat de la fonction est la valeur convertie.

Exemple : 

```sql
CAST(126.12 AS INTEGER)
```
Ce code renvoie : "126". 
<a name="SQL_CONVERT"></a>
**CONVERT**


La fonction CONVERT permet de convertir une chaîne de caractères d'un alphabet vers un autre.

**Format d'utilisation** :

```txt
CONVERT(Texte à convertir, alphabet utilisé, nouvel alphabet)
```


**Exemple** : Conversion d'une chaîne UTF-8 en LATIN1 : 

```sql
SELECT CONVERT('texte en utf8', 'UTF8', 'LATIN1')
```


Remarque : Cette fonction n'est pas disponible pour les requêtes SQL exécutées sur des fichiers HFSQL en Android. 
<a name="SQL_INITCAP"></a>
**INITCAP**
La fonction **INITCAP** renvoie une chaîne dans laquelle la première lettre de chaque mot est mise en majuscule et toutes les autres lettres sont mises en minuscules. 

**Format d'utilisation** :

```txt
INITCAP(<Chaîne>)
```


Exemple : 

```sql
INITCAP('iL Fait beau')
```
Ce code renvoie : "Il Fait Beau". 
<a name="SQL_LOWER"></a>


### LOWER
<a name="lower_ELTPARAGRAPHE001267"></a>La fonction **LOWER** convertit une expression en minuscules.

La fonction **LOWER** ne peut pas être utilisée sur une source de données de type Access.

**Format d'utilisation** :

```txt
LOWER(Expression initiale)
```


**Exemple** : Le code SQL suivant permet de convertir en minuscules le prénom des clients :

```sql
SELECT LOWER(Prénom)
FROM CLIENT
```

<a name="SQL_UPPER"></a>


### UPPER
<a name="upper_ELTPARAGRAPHE001282"></a>La fonction **UPPER** convertit une expression en majuscules.

La fonction **UPPER** ne peut pas être utilisée sur une source de données de type Access.

**Format d'utilisation** :

```txt
UPPER(Expression initiale)
```


**Exemple** : Le code SQL suivant permet de convertir en majuscules les villes des clients :

```sql
SELECT UPPER(Ville)
FROM CLIENT
```

<a name="SQL_LCASE"></a>
**LCASE**
La fonction **LCASE** retourne une chaîne avec tous les caractères en minuscules en fonction du jeu de caractères courant.

**Format d'utilisation** :

```txt
LCASE(Expression initiale)
```


**Exemple** : Le code SQL suivant permet de convertir en minuscules les villes des clients :

```sql
SELECT LCASE(Ville)
FROM CLIENT
```

<a name="SQL_UCASE"></a>
**UCASE**
La fonction **UCASE** retourne une chaîne avec tous les caractères en majuscules en fonction du jeu de caractères courant.

**Format d'utilisation** :

```txt
UCASE(Expression initiale)
```


**Exemple** : Le code SQL suivant permet de convertir en majuscules les villes des clients :

```sql
SELECT UCASE(Ville)
FROM CLIENT
```

<a name="NOTE2_17"></a>


### LEN / LENGTH
<a name="len_length_ELTPARAGRAPHE001327"></a>Les fonctions **LEN et LENGTH** renvoient la taille (le nombre de caractères) d'une expression.

Cette taille comprend tous les caractères y compris les caractères espace et 0 binaire.
<a name="SQL_LEN"></a>


### LEN
<a name="len_ELTPARAGRAPHE001336"></a>La fonction **LEN** peut être utilisée sur tous les types de source de données, sauf les sources de données de type Oracle. Pour les sources de données de type Oracle, utilisez la fonction **LENGTH**.

**Format d'utilisation** :

```txt
LEN(Expression initiale)
```


**Exemple** : Le code SQL suivant permet d'obtenir la taille des noms des clients :

```sql
SELECT LEN(Nom)
FROM CLIENT
```

<a name="SQL_LENGTH"></a>


### LENGTH
<a name="length_ELTPARAGRAPHE001349"></a>La fonction **LENGTH** peut être utilisée uniquement sur une source de données de type Oracle.

**Format d'utilisation** :

```txt
LENGTH(Expression initiale)
```


**Exemple** : Le code SQL suivant permet d'obtenir la taille des noms des clients :

```sql
SELECT LENGTH(Nom)
FROM CLIENT
```

<a name="SQL_INSTR"></a>


### INSTR
<a name="instr_ELTPARAGRAPHE001362"></a>La fonction **INSTR** renvoie la position d'une chaîne de caractères dans une expression.

La fonction **INSTR** peut être utilisée uniquement sur une source de données de type Oracle ou supportant la norme SQL-92.

**Format d'utilisation** :

```txt
INSTR(Expression initiale, Chaîne à rechercher, Position de départ, Occurrence)
```


**Exemple** : Le code SQL suivant permet d'obtenir la position de la première occurrence de la lettre "T" dans chaque nom de ville des clients :

```sql
SELECT INSTR(Ville, 'T', 1, 1)
FROM CLIENT
```

<a name="SQL_FIELD"></a>
**FIELD**
La fonction **FIELD** renvoie l'index de la chaîne recherchée dans la liste.

Si la chaîne n'est pas trouvée, la fonction renvoie 0. 

**Format d'utilisation** :

```txt
FIELD(Chaîne à rechercher, Chaîne1, Chaîne2, ...)
```

<a name="SQL_FIND_IN_SET"></a>
**FIND_IN_SET**
La fonction **FIND_IN_SET** retourne la position d'une chaîne dans une liste de valeurs.

Si la chaîne n'est pas trouvée, la fonction renvoie 0. 

**Format d'utilisation** :

```txt
FIND_IN_SET(<Chaîne à rechercher>, <Liste de valeurs>)
```


Le paramètre &lt;Liste de valeurs&gt; correspond à une chaîne de caractères contenant les valeurs séparées par une virgule. 

Exemple : Le code suivant renvoie 3 : 


```sql
FIND_IN_SET('Rouge','Bleu,Jaune,Rouge,Vert')
```

<a name="SQL_PATINDEX"></a>


### PATINDEX
<a name="patindex_ELTPARAGRAPHE001411"></a>La fonction **PATINDEX** renvoie la position de la première occurrence d'une chaîne de caractères correspondant à une valeur spécifiée (avec des caractères génériques).

Les caractères génériques autorisés sont les suivants :

- '%' : représente zéro, un ou plusieurs caractères.

- '_' : représente un caractère unique.




Ces caractères génériques peuvent être combinés.

La fonction **PATINDEX** peut être utilisée sur une source de données de type HFSQL Classic ou de type SQL Server.

**Format d'utilisation** :

```txt
PATINDEX(Valeur à rechercher, Expression)
```


**Exemple** : Le tableau ci-dessous indique la position de la première occurrence trouvée en fonction de différentes valeurs recherchées :

   |   | --- | --- |
| --- | --- |
|   | Valeur recherchée |
| **Nom de ville** | '%E%' | '%E_' | '%AR%' |
| MONTPELLIER | 6 | 10 | 0 |
| PARIS | 0 | 0 | 2 |
| TARBES | 5 | 5 | 2 |
| TOULOUSE | 8 | 0 | 0 |
| VIENNE | 3 | 0 | 0 |


<a name="SQL_POSITION"></a>


### POSITION
<a name="position_ELTPARAGRAPHE001519"></a>La fonction **POSITION** renvoie la position d'une chaîne de caractères dans une expression.

**Format d'utilisation** :

```txt
POSITION(Chaîne à rechercher IN Expression initiale)
POSITION(Chaîne à rechercher IN Expression initiale, Position de départ)
```


Exemple :

```wl
TestREQ est une Source de Données
sCodeSQL est une chaîne = [
SELECT POSITION( 'No' IN Nom ) As PosNom
FROM cooperateur
LIMIT 0 , 30
]

SI PAS HExécuteRequêteSQL(TestREQ, MaConnexion, hRequêteSansCorrection, sCodeSQL) ALORS 
	Erreur(HErreurInfo())
FIN
POUR TOUT TestREQ 
	Trace(TestREQ.PosNom )
FIN
```

<a name="SQL_COUNT"></a>


### COUNT
<a name="count_ELTPARAGRAPHE001532"></a>La fonction **COUNT** renvoie :

- le nombre d'enregistrements sélectionnés dans un fichier.

- le nombre de valeurs non nulles d'une rubrique.

- le nombre de valeurs différentes et non nulles d'une rubrique.




**Format d'utilisation** :

```txt
COUNT(*)
COUNT(Rubrique)
COUNT(DISTINCT Rubrique)
```


**Exemples** :

- Le code SQL suivant permet d'obtenir le nombre de produits présents dans le fichier Produit :
	
	```sql
	SELECT COUNT(*)
	FROM PRODUIT
	```


- Le code SQL suivant permet d'obtenir le nombre de produits sur lesquelles un taux de TVA de 5,5 % est appliqué :
	
	```sql
	SELECT COUNT(TauxTVA)
	FROM PRODUIT
	WHERE TauxTVA = '5.5'
	```


- Le code SQL suivant permet d'obtenir le nombre des taux de TVA différents et non nuls :
	
	```sql
	SELECT COUNT(DISTINCT PRODUIT.TauxTVA)
	FROM PRODUIT
	```




<a name="SQL_AVG"></a>


### AVG
<a name="avg_ELTPARAGRAPHE001558"></a>La fonction **AVG** calcule :

- soit la moyenne d'un ensemble de valeurs non nulles.

- soit la moyenne d'un ensemble de valeurs différentes et non nulles.




**Format d'utilisation** :

```txt
AVG(Rubrique) 
AVG(DISTINCT Rubrique)
```


**Exemples** :

- Le code SQL suivant permet d'obtenir le salaire moyen des employés :
	
	```sql
	SELECT AVG(Salaire)
	FROM EMPLOYE
	```


- Le code SQL suivant permet d'obtenir la moyenne des salaires différents des employés :
	
	```sql
	SELECT AVG(DISTINCT Salaire)
	FROM EMPLOYE
	```




<a name="SQL_MAX"></a>


### MAX
<a name="max_ELTPARAGRAPHE001580"></a>La fonction **MAX** renvoie la plus grande valeur des valeurs présentes dans une rubrique pour tous les enregistrements sélectionnés dans le fichier.

La fonction MAX utilisée dans une requête sans regroupement doit renvoyer un et un seul enregistrement. Si la requête contient des regroupements, il y aura un enregistrement par regroupement.

Si la source de données contient des enregistrements, l'enregistrement retourné par la requête contiendra la valeur maximale.

Si la source de données ne contient pas d'enregistrements, la valeur du MAX dans l'enregistrement retourné est NULL.

**Format d'utilisation** :

```txt
MAX(Rubrique) 

MAX(DISTINCT Rubrique)
```


**Exemple** : Le code SQL suivant permet d'obtenir le salaire maximal des employés :

```sql
SELECT MAX(Salaire)
FROM EMPLOYE
-- Equivalent à :
-- SELECT MAX(DISTINCT Salaire)
-- FROM EMPLOYE
```

<a name="SQL_MIN"></a>


### MIN
<a name="min_ELTPARAGRAPHE001599"></a>La fonction **MIN** renvoie la plus petite valeur des valeurs non nulles présentes dans une rubrique pour tous les enregistrements sélectionnés dans le fichier.

**Format d'utilisation** :

```txt
MIN(Rubrique)

MIN(DISTINCT Rubrique)
```


**Exemple** : Le code SQL suivant permet d'obtenir le salaire minimal des employés :

```sql
SELECT MIN(Salaire)
FROM EMPLOYE
-- Equivalent à :
-- SELECT MIN(DISTINCT Salaire)
-- FROM EMPLOYE
```

<a name="SQL_SUM"></a>


### SUM
<a name="sum_ELTPARAGRAPHE001612"></a>La fonction **SUM** renvoie :

- soit la somme totale des valeurs non nulles présentes dans une rubrique pour tous les enregistrements sélectionnés dans le fichier.

- soit la somme totale des valeurs différentes et non nulles présentes dans une rubrique pour tous les enregistrements sélectionnés dans le fichier. 




**Format d'utilisation** :

```txt
SUM(Rubrique)

SUM(DISTINCT Rubrique)
```


**Exemples** :

- Le code SQL suivant permet d'obtenir la somme totale des salaires :
	
	```sql
	SELECT SUM(Salaire)
	FROM EMPLOYE
	```


- Le code SQL suivant permet d'obtenir la somme totale des salaires différents :
	
	```sql
	SELECT SUM(DISTINCT Salaire)
	FROM EMPLOYE
	```





**Remarque** : La rubrique manipulée par la fonction **SUM** ne doit pas correspondre au résultat d'une opération. Ainsi, la syntaxe suivante génère une erreur :

```sql
SELECT (A*B) AS C, SUM C
FROM MONFICHIER
```


Cette syntaxe doit être remplacée par la syntaxe suivante :

```sql
SELECT (A*B) AS C, SUM(A*B)
FROM MONFICHIER
```

<a name="SQL_EVERY"></a>


### EVERY
<a name="every_ELTPARAGRAPHE001644"></a>La fonction **EVERY** est une fonction d'agrégation (comme l'ordre SUM par exemple), c'est-à-dire que la fonction agit sur un groupe de données et renvoie une valeur.

La fonction **EVERY** renvoie : 

- <u><u><u><u>Vrai</u></u></u></u> si tous les arguments qu'elle a reçu sont vérifiés et vrai.

- <u><u><u><u>Faux</u></u></u></u> si au moins un des arguments n'est pas vérifié.




**Format d'utilisation** :

```txt
EVERY(Expression 1, Expression 2, ..., Expression N)
```


**Exemple** :
Le code SQL suivant permet d'obtenir la liste des sociétés ayant des employés dont le salaire est supérieur à 10000 :

```sql
SELECT societe.nom, every(employe.salaire > 10000) as riche 
FROM societe NATURAL JOIN employe GROUP BY societe.nom
```

<a name="SQL_TOP"></a>


### TOP
<a name="top_ELTPARAGRAPHE001669"></a>La fonction **TOP** renvoie uniquement les n premiers enregistrements du résultat d'une requête.

La fonction **TOP** ne peut pas être utilisée sur une source de données de type Oracle ou PostgreSQL.

**Format d'utilisation** :

```txt
TOP Nombre du dernier enregistrement sélectionné
```


**Exemple** : Le code SQL suivant permet de lister les 10 meilleurs clients :

```sql
SELECT TOP 10 SUM(COMMANDE.TotalTTC) AS TotalTTC,
CLIENT.NomClient
FROM CLIENT, COMMANDE
WHERE CLIENT.NumClient = COMMANDE.NumClient
GROUP BY NomClient
ORDER BY TotalTTC DESC
```


**Remarque** : 

- Il est conseillé d'utiliser la fonction **TOP** sur une requête triée. Dans le cas contraire, les enregistrements retournés par la fonction **TOP** seront sélectionnés selon leur numéro d'enregistrement.

- Il est possible de passer un paramètre à la fonction **TOP**. Le paramètre peut être : 

	- défini dans l'éditeur de requêtes. Pour plus de détails, consultez [Requête de sélection : Afficher les n premiers / derniers enregistrements](../Editeurs/2032022.md). 

	- défini directement dans le code SQL. Par exemple : 



	```sql
	SELECT TOP {pNombreClientsMax}
	Client.IDClient AS IDClient,
	Client.Nom AS Nom,
	Client.Prénom AS Prénom,
	Client.Email AS Email,
	Client.PointsFidélités AS PointsFidélités
	FROM
	Client
	```




<a name="SQL_BOTTOM"></a>


### BOTTOM
<a name="bottom_ELTPARAGRAPHE001699"></a>La fonction **BOTTOM** renvoie uniquement les n derniers enregistrements du résultat d'une requête.

La fonction **BOTTOM** peut être utilisée uniquement sur une source de données de type HFSQL.

**Format d'utilisation** :

```txt
BOTTOM Nombre du dernier enregistrement sélectionné
```


**Exemple** : Le code SQL suivant permet de lister les 10 plus mauvais clients :

```sql
SELECT BOTTOM 10 SUM(COMMANDE.TotalTTC) AS TotalTTC,
CLIENT.NomClient
FROM CLIENT, COMMANDE
WHERE CLIENT.NumClient = COMMANDE.NumClient
GROUP BY NomClient
ORDER BY TotalTTC DESC
```


**Remarque** : 

- Il est conseillé d'utiliser la fonction **BOTTOM** sur une requête triée. Dans le cas contraire, les enregistrements retournés par la fonction **BOTTOM** seront sélectionnés selon leur numéro d'enregistrement.

- Il est possible de passer un paramètre à la fonction **BOTTOM**. Le paramètre peut être : 

	- défini dans l'éditeur de requêtes. Pour plus de détails, consultez [Requête de sélection : Afficher les n premiers / derniers enregistrements](../Editeurs/2032022.md). 

	- défini directement dans le code SQL. 






<a name="SQL_LIMIT"></a>


### LIMIT
<a name="limit_ELTPARAGRAPHE001727"></a>La fonction **LIMIT** renvoie uniquement les n premiers enregistrements du résultat d'une requête.

La fonction **LIMIT** ne peut pas être utilisée sur une source de données de type Oracle ou PostgreSQL.

**Format d'utilisation** :

```txt
LIMIT Nombre du dernier enregistrement sélectionné
```


**Exemple** : Le code SQL suivant permet de lister les 10 meilleurs clients :

```sql
SELECT SUM(COMMANDE.TotalTTC) AS TotalTTC,
CLIENT.NomClient
FROM CLIENT, COMMANDE
WHERE CLIENT.NumClient = COMMANDE.NumClient
GROUP BY NomClient
ORDER BY TotalTTC DESC
LIMIT 10
```


**Remarque** : 

- Il est conseillé d'utiliser la fonction **LIMIT** sur une requête triée. Dans le cas contraire, les enregistrements retournés par la fonction **TOP** seront sélectionnés selon leur numéro d'enregistrement.

- Il est possible de passer un paramètre à la fonction **LIMIT**. Le paramètre peut être : 

	- défini dans l'éditeur de requêtes. Pour plus de détails, consultez [Requête de sélection : Afficher les n premiers / derniers enregistrements](../Editeurs/2032022.md). 

	- défini directement dans le code SQL. 






<a name="SQL_ASCII"></a>


### ASCII
<a name="ascii_ELTPARAGRAPHE001755"></a>La fonction **ASCII** renvoie le code ASCII :

- soit d'un caractère. 

- soit du première caractère d'une chaîne.




Si le caractère ou la chaîne de caractères spécifiée correspond à une chaîne vide (""), la fonction **ASCII** renvoie 0.

**Format d'utilisation** :

```txt
-- Code ASCII d'un caractère
ASCII(Caractère)
-- Code ASCII du premier caractère d'une chaîne
ASCII(Chaîne de caractères)
```

<a name="SQL_UNICODE"></a>


### UNICODE
<a name="unicode_ELTPARAGRAPHE001770"></a>La fonction **UNICODE** renvoie la valeur entière définie par la norme Unicode :

- soit d'un caractère. 

- soit du première caractère d'une chaîne.




**Format d'utilisation** :

```txt
-- Code Unicode d'un caractère
UNICODE(Caractère)
-- Code Unicode du premier caractère d'une chaîne
UNICODE(Chaîne de caractères)
```

<a name="SQL_CURRENT_USER"></a>


### CURRENT_USER
<a name="currentuser_ELTPARAGRAPHE001785"></a>La fonction **CURRENT_USER** renvoie le nom de l'utilisateur de la connexion en cours.

**Format d'utilisation** :

```txt
CURRENT_USER()
```


**Exemple** : Le code suivant met à jour l'auteur de la modification de la table CLIENT : 

```sql
UPDATE CLIENT SET USER=CURRENT_USER() WHERE IDCLIENT=1
```

<a name="SQL_SYSTEM_USER"></a>


### SYSTEM_USER
<a name="systemuser_ELTPARAGRAPHE001800"></a>La fonction **SYSTEM_USER** renvoie le nom de l'utilisateur de la connexion en cours.

**Format d'utilisation** :

```txt
SYSTEM_USER()
```


**Exemple** : Le code suivant met à jour l'auteur de la modification de la table CLIENT : 

```sql
UPDATE CLIENT SET USER=SYSTEM_USER() WHERE IDCLIENT=1
```

<a name="SQL_USER_NAME"></a>


### USER_NAME
<a name="username_ELTPARAGRAPHE001815"></a>La fonction **USER_NAME** renvoie le nom de l'utilisateur de la connexion en cours.

**Format d'utilisation** :

```txt
USER_NAME()
```


**Exemple** : Le code suivant met à jour l'auteur de la modification de la table CLIENT : 

```sql
UPDATE CLIENT SET USER=USER_NAME() WHERE IDCLIENT=1
```

<a name="SQL_SOUNDEX, SOUND LIKE"></a>


### SOUNDEX, SOUND LIKE
<a name="soundex_sound_like_ELTPARAGRAPHE001828"></a>Les fonctions **SOUNDEX** et **SOUND LIKE** renvoient la représentation phonétique d'une chaîne de caractères (basé sur un algorithme anglo-saxon).

**Format d'utilisation** :

```txt
SOUNDEX(Chaîne)

SOUND LIKE(Chaîne)
```


**Exemple** : Le code SQL suivant permet de lister les clients dont le nom correspond phonétiquement à "Henry" :

```sql
SELECT CLIENT.NomClient
FROM CLIENT 
WHERE SOUNDEX(CLIENT.NomClient) = SOUNDEX('Henry')
```



```sql
SELECT CLIENT.NomClient
FROM CLIENT 
WHERE CLIENT.NomClient SOUND LIKE 'Henry'
```


Remarque : la fonction SOUNDEX utilisée sur plusieurs bases différentes (HFSQL, Oracle, MySQL, ...) peut renvoyer des résultats différents selon la base utilisée. 

![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) SOUND LIKE n'est pas géré par Oracle, MySQL, Progress ou Informix. 

SOUNDEX n'est pas géré par Informix. 
<a name="SQL_SOUNDEX2, SOUND2 LIKE"></a>


### SOUNDEX2, SOUND2 LIKE
<a name="soundex2_sound2_like_ELTPARAGRAPHE001851"></a>Les fonctions **SOUNDEX2** et **SOUND2 LIKE** renvoient la représentation phonétique d'une chaîne de caractères (basé sur un algorithme proche du français).

**Format d'utilisation** :

```txt
SOUNDEX2(Chaîne)

SOUND2 LIKE(Chaîne)
```


**Exemple** : Le code SQL suivant permet de lister les clients dont la ville correspond phonétiquement à "Montpellier" :

```sql
SELECT CLIENT.NomVille
FROM CLIENT 
WHERE SOUNDEX2(CLIENT.NomVille) = SOUNDEX2('Montpellier')
```



```sql
SELECT CLIENT.NomVille
FROM CLIENT 
WHERE CLIENT.NomVille SOUND2 LIKE 'Montpellier'
```


![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) SOUNDEX2 et SOUNDEX2 LIKE ne sont pas gérés par Oracle, SQL Server, MySQL, Progress, Informix ou DB2. 
<a name="SQL_ADD_MONTHS"></a>


### ADD_MONTHS
<a name="addmonths_ELTPARAGRAPHE001870"></a>La fonction **ADD_MONTHS** permet d'ajouter plusieurs mois à une date spécifiée.

**Format d'utilisation** :

```txt
ADD_MONTHS(Date,Nombre de mois)
```


**Exemple** : Le code SQL suivant permet de sélectionner les commandes du mois d'avril 2003.

```sql
SELECT DATECDE,
	ADD_MONTHS('20070203',2) AS AM 
FROM COMMANDE
```


![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) ADD_MONTHS n'est pas géré par SQL Server, MySQL, Informix, DB2 ou Sybase.
<a name="SQL_LAST_DAY"></a>


### LAST_DAY
<a name="lastday_ELTPARAGRAPHE001887"></a>La fonction **LAST_DAY** permet d'obtenir la date du dernier jour du mois spécifié.

**Format d'utilisation** :

```txt
LAST_DAY(Date)
```


**Exemple** : Le code SQL suivant permet de sélectionner les commandes du mois de février 2008 : 

```sql
SELECT LAST_DAY('20080203') as LD,
	DATECDE 
FROM COMMANDE
WHERE COMMANDE.CLCLEUNIK=2 order by DATECDE
```


![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) LAST_DAY n'est pas géré par Informix, DB2 ou Sybase.
<a name="SQL_DAY"></a>


### DAY
<a name="day_ELTPARAGRAPHE001906"></a>La fonction **DAY** renvoie le jour du mois, c'est-à-dire un nombre compris entre 1 et 31.

**Format d'utilisation** :

```txt
DAY(Date)
```

<a name="SQL_DAYOFMONTH"></a>


### DAYOFMONTH
<a name="dayofmonth_ELTPARAGRAPHE001918"></a>La fonction **DAYOFMONTH** renvoie le jour dans le mois (compris entre 1 et 31).

**Format d'utilisation** :

```txt
DAYOFMONTH(Date)
```

<a name="SQL_DAYOFWEEK"></a>


### DAYOFWEEK
<a name="dayofweek_ELTPARAGRAPHE001930"></a>La fonction **DAYOFWEEK** renvoie le jour dans la semaine (1 pour Dimanche, 2 pour Lundi, etc.). 

**Format d'utilisation** :

```txt
DAYOFWEEK(Date)
```

<a name="SQL_DAYOFYEAR"></a>


### DAYOFYEAR
<a name="dayofyear_ELTPARAGRAPHE001942"></a>La fonction **DAYOFYEAR** renvoie le jour dans l'année (compris entre 1 et 366). 

**Format d'utilisation** :

```txt
DAYOFYEAR(Date)
```

<a name="SQL_EOMONTH"></a>


### EOMONTH
<a name="eomonth_ELTPARAGRAPHE001954"></a>La fonction **EOMONTH** renvoie le dernier jour du mois contenant la date spécifiée. 

**Format d'utilisation** :

```txt
EOMONTH(Date de départ [, Nombre de mois à ajouter ] )
```
où : 

- Date de départ : Date dont on veut le dernier jour du mois.

- Nombre de mois à ajouter : Nombre de mois à ajouter à la date de départ avant de calculer le dernier jour du mois. 



<a name="SQL_YEAR_MONTH"></a>


### YEAR et MONTH
<a name="year_month_ELTPARAGRAPHE001970"></a>Les fonctions **YEAR** et **MONTH** permettent d'obtenir respectivement l'année et le mois d'une date. 

**Format d'utilisation** :

```txt
YEAR date
```



```txt
MONTH date
```


où date correspond : 

- soit à la date écrite en entier : date du type ANNEE - MOIS - JOUR (AAAMMJJ ou AAAA-MM-JJ)

- soit à une date partielle. dans ce cas, les informations manquantes sont des 0

- soit uniquement une année (ANNEE)

- soit uniquement l'année et le mois (ANNEE-MOIS)




Remarque : 

- La date se décode de gauche à droite : pour qu'une date soit valide, il faut que toutes les informations disponibles soient valides. 

- Si le format est non correct, la fonction retourne NULL. 



<a name="SQL_CURRENT_TIMESTAMP"></a>


### CURRENT_TIMESTAMP
<a name="currenttimestamp_ELTPARAGRAPHE001996"></a>La fonction **CURRENT_TIMESTAMP** renvoie l'heure locale du serveur (au format date-heure). 

**Format d'utilisation** :

```txt
CURRENT_TIMESTAMP()
```

<a name="SQL_GETDATE"></a>


### GETDATE
<a name="getdate_ELTPARAGRAPHE002008"></a>La fonction **GETDATE** renvoie l'heure locale du serveur (au format date-heure). 

**Format d'utilisation** :

```txt
GETDATE()
```

<a name="SQL_GETUTCDATE"></a>


### GETUTCDATE
<a name="getutcdate_ELTPARAGRAPHE002020"></a>La fonction **GETUTCDATE** renvoie l'heure UTC du serveur (au format date-heure). 

**Format d'utilisation** :

```txt
GETUTCDATE()
```

<a name="SQL_DATEADD"></a>


### DATEADD
<a name="dateadd_ELTPARAGRAPHE002032"></a>La fonction **DATEADD** ajoute une valeur à la date de départ et renvoie la nouvelle date correspondante.  

**Format d'utilisation** :

```txt
DATEADD(Partie à ajouter, nombre, date )
```
où : 

- Partie à ajouter : Partie de la date à laquelle le nombre doit être ajouté. Ce paramètre peut correspondre à : 
	

| Partie de la date	 | Abréviations |
| --- | --- |
| year | yy, yyyy |
| quarter | qq, q |
| month	 | mm, m |
| dayofyear	 | dy, y |
| day	 | dd, d |
| week	 | wk, ww |
| weekday | dw, w |
| hour | hh |
| minute	 | mi, n |
| second	 | ss, s |
| millisecond | ms |
| microsecond	 | mcs |
| nanosecond	 | ns |



- Nombre : entier correspondant au nombre d'unités à ajouter. 

- date : date ou date-heure à manipuler. 



<a name="SQL_DATEDIFF"></a>


### DATEDIFF et DATEDIFF_BIG
<a name="datediff_datediffbig_ELTPARAGRAPHE002107"></a>La fonction **DATEDIFF** calcule la différence entre deux dates dans l'unité spécifiée. La valeur de retour est un entier signé. 

La fonction **DATEDIFF_BIG** calcule la différence entre deux dates dans l'unité spécifiée. La valeur de retour est un entier très grand signé. 

**Format d'utilisation** :

```txt
DATEDIFF(Partie utilisée, Date de départ, Date de fin) 

DATEDIFF_BIG(Partie utilisée, Date de départ, Date de fin)
```
où : 

- Partie utilisée : Partie de la date sur laquelle le calcul sera effectué. Ce paramètre peut correspondre à : 
	

| Partie de la date	 | Abréviations |
| --- | --- |
| year | yy, yyyy |
| quarter | qq, q |
| month	 | mm, m |
| dayofyear	 | dy, y |
| day	 | dd, d |
| week	 | wk, ww |
| weekday | dw, w |
| hour | hh |
| minute	 | mi, n |
| second	 | ss, s |
| millisecond | ms |
| microsecond	 | mcs |
| nanosecond	 | ns |



- Date de départ : date ou date-heure de départ du calcul. 

- Date de fin : date ou date-heure de fin du calcul. 



<a name="SQL_DATEPART"></a>


### DATEPART
<a name="datepart_ELTPARAGRAPHE002184"></a>La fonction **DATEPART** renvoie l'entier correspondant à la partie demandée de la date-heure spécifiée.  

**Format d'utilisation** :

```txt
DATEPART(Partie utilisée, date)
```
où : 

- Partie utilisée : Partie de la date à extraire. Ce paramètre peut correspondre à : 
	

| Partie de la date	 | Abréviations |
| --- | --- |
| year | yy, yyyy |
| quarter | qq, q |
| month	 | mm, m |
| dayofyear	 | dy, y |
| day	 | dd, d |
| week	 | wk, ww |
| weekday | dw, w |
| hour | hh |
| minute	 | mi, n |
| second	 | ss, s |
| millisecond | ms |
| microsecond	 | mcs |
| nanosecond	 | ns |



- Date de départ : date ou date-heure manipulée. 



<a name="SQL_DATETIMEFROMPARTS"></a>


### DATETIMEFROMPARTS
<a name="datetimefromparts_ELTPARAGRAPHE002258"></a>La fonction **DATETIMEFROMPARTS** renvoie une date-heure correspondant aux éléments spécifiés. 

**Format d'utilisation** :

```txt
DATETIMEFROMPARTS(Année, Mois, Jours, Heures, Minutes, Secondes, Millisecondes)
```

<a name="SQL_DATEFROMPARTS"></a>


### DATEFROMPARTS
<a name="datefromparts_ELTPARAGRAPHE002270"></a>La fonction **DATEFROMPARTS** renvoie une date correspondant aux éléments spécifiés. 

**Format d'utilisation** :

```txt
DATEFROMPARTS(Année, Mois, Jours)
```

<a name="SQL_MONTHS_BETWEEN"></a>


### MONTHS_BETWEEN
<a name="monthsbetween_ELTPARAGRAPHE002280"></a>La fonction **MONTHS_BETWEEN** permet d'obtenir le nombre de mois entre deux dates spécifiées.

**Format d'utilisation** :

```txt
MONTHS_BETWEEN(Date1, Date2)
```


**Exemple** : Le code SQL suivant permet de sélectionner les commandes entre deux dates : 

```sql
SELECT DATECDE,
	MONTHS_BETWEEN('20070203','20070102') AS MB 
FROM COMMANDE
```


**Exemple** : Le code SQL suivant permet de sélectionner les clients selon leur âge : 

```sql
SELECT CLIENT.IDCLIENT,
	CLIENT.NOM,CLIENT.PRENOM,   
    -- Nombre de mois divisé par 12 en réel : nombre d'années
	CAST(MONTHS_BETWEEN(SYSDATE,CLIENT.DATE_NAISSANCE)/12 AS FLOAT) AS Age
FROM 
	CLIENT
WHERE 
	-- uniquement les clients majeurs
	Age >= 18
```


![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) MONTHS_BETWEEN n'est pas géré par MySQL, Informix, DB2 ou Sybase.
<a name="SQL_NEW_TIME"></a>


### NEW_TIME
<a name="newtime_ELTPARAGRAPHE002300"></a>La fonction **NEW_TIME** permet d'obtenir une date après conversion de fuseau horaire.

**Format d'utilisation** :

```txt
NEW_TIME(Date, Fuseau Horaire 1, Fuseau Horaire 2)
```


**Exemple** : 

```sql
SELECT NEW_TIME('200311010145', 'AST', 'MST') as NTI 
FROM CLIENT
```


Remarque : Si les fuseaux horaires correspondent à chaîne vide (""), le résultat sera une valeur DateHeure à 0.

![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) NEW_TIME n'est pas géré par SQL Server, MySQL, Progress, Informix, DB2 ou Sybase.
<a name="SQL_NEXT_DAY"></a>


### NEXT_DAY
<a name="nextday_ELTPARAGRAPHE002319"></a>La fonction **NEXT_DAY** permet d'obtenir le premier jour de la semaine suivant la date spécifiée ou le jour spécifié.

**Format d'utilisation** :

```txt
NEXT_DAY(Date, Jour)
```


**Exemple** : 

```sql
SELECT NEXT_DAY('20071007','dimanche') AS NXD 
FROM CLIENT
```


![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) NEXT_DAY n'est pas géré par SQL Server, MySQL, Progress, Informix, DB2 ou Sybase. 
<a name="SQL_ROUND"></a>


### ROUND
<a name="round_ELTPARAGRAPHE002336"></a>La fonction **ROUND** permet d'arrondir la date au format spécifié.

**Format d'utilisation** :

```txt
ROUND(Date, Format)
```


**Exemple** : 

```sql
SELECT DATECDE,
	ROUND(DATECDE,'YYYY') AS TR 
FROM COMMANDE
```


![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) ROUND n'est pas géré par Progress, DB2 et Sybase. 
<a name="SQL_SYSDATE"></a>


### SYSDATE
<a name="sysdate_ELTPARAGRAPHE002353"></a>La fonction **SYSDATE** permet d'obtenir la date et l'heure courante.

**Format d'utilisation** :

```txt
SYSDATE
```


**Exemple** : 

```sql
SELECT SYSDATE as SY FROM CLIENT WHERE CLCLEUNIK=1
```


![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png)  SYSDATE n'est pas géré par Informix et Sybase.
<a name="SQL_TRUNC"></a>


### TRUNC
<a name="trunc_ELTPARAGRAPHE002370"></a>La fonction **TRUNC** permet de tronquer la date au format spécifié.

**Format d'utilisation** :

```txt
TRUNC(Date, Format)
```
Le paramètre "Format" peut correspondre aux valeurs suivantes : 

- Siècle : "CC" ou "SCC"

- Année : "Y", "YEAR", "YY", "YYY", "YYYY", "SYEAR", "SYYYY"

- Année ISO : "I", "IY", "IY", "IYYY" : 	ISOYear

- Trimestre : "Q"

- Mois : "MM", "MON", "MONTH"

- Premier jour du mois qui est le même jour de la semaine : "W"

- Premier jour de la semaine : "D", "DAY", "DY"

- Jour : "DD", "DDD", "J"

- Heure : "HH", "HH12", "HH24"

- Minutes : "MI" 




**Exemple** : 

```sql
SELECT DATECDE,
TRUNC(DATECDE) AS TR 
FROM COMMANDE 
WHERE COCLEUNIK
```


![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) TRUNC n'est pas géré par SQL Server, MySQL, Progress, DB2 et Sybase.
<a name="SQL_ISDATE"></a>


### ISDATE
<a name="isdate_ELTPARAGRAPHE002401"></a>La fonction **ISDATE** permet de savoir si une expression correspond à une date. Cette fonction renvoie : 

- 1 si l'expression correspond à une date ou une date-heure

- 0 dans les autres cas. 




**Format d'utilisation** :

```txt
ISSDATE(Expression)
```


**Exemple** : 

```sql
SELECT Date, ISDATE(Date) FROM Commande WHERE IDCommande=50
```

<a name="SQL_COALESCE"></a>


### COALESCE
<a name="coalesce_ELTPARAGRAPHE002417"></a>La fonction **COALESCE** permet de trouver la première expression non nulle parmi ses arguments. 

**Format d'utilisation** :

```txt
COALESCE(Param1, Param2, ...)
```


**Exemple** : 

```sql
SELECT COALESCE(hourly_wage, salary, commission) AS Total_Salary FROM wages
```


![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png) COALESCE n'est pas géré par Progress ou Informix.
<a name="SQL_GREATEST"></a>
**GREATEST**
La fonction **GREATEST** renvoie la valeur la plus grande des éléments passés en paramètre. 

**Format d'utilisation** :

```txt
GREATEST(Param1, Param2, ...)
```

<a name="SQL_LEAST"></a>
**LEAST**
La fonction **LEAST** renvoie la valeur la plus petite des éléments passés en paramètre. 

**Format d'utilisation** :

```txt
LEAST(Param1, Param2, ...)
```

<a name="SQL_NVL_IF_NULL_IS_NULL"></a>


### NVL, IFNULL, ISNULL
<a name="nvl_ifnull_isnull_ELTPARAGRAPHE002458"></a>La fonction **NVL** permet de remplacer les valeurs nulles d'une colonne par une valeur de substitution. Les fonctions ISNULL et IFNULL sont identiques.

ISNULL est utilisé en SQL Server et IFNULL avec les bases MySQL ou Progress.

**Format d'utilisation** :

```txt
NVL(Nom Colonne, Valeur de substitution)
```


**Exemple** : 

```sql
SELECT hourly_wage AS R1,NVL(hourly_wage,0) AS Total FROM wages
```

<a name="SQL_NULLIF"></a>


### NULLIF
<a name="nullif_ELTPARAGRAPHE002473"></a>La fonction **NULLIF** renvoie une valeur NULL si les deux expressions spécifiées sont égales.

**Format d'utilisation** :

```txt
NULLIF(expression1, expression2)
```

<a name="SQL_DECODE"></a>


### DECODE
<a name="decode_ELTPARAGRAPHE002483"></a>La fonction **DECODE** permet d'obtenir le fonctionnement d'une instruction SI .. ALORS .. SINON.

**Format d'utilisation** :

```txt
DECODE(Nom_Colonne, Valeur comparée 1, Valeur retournée 1, [Valeur comparée 2, ...
		Valeur retournée 2][, Valeur par défaut])
```


**Exemple** : Selon le client sélectionné, renvoie le nom correspondant à l'identifiant indiqué : 

```sql
SELECT CLIENT_NOM, 
DECODE(CLIENT_ID, 10000, 'Client 1',10001,'Client 2',10002,'Client 3','Autre')
FROM CLIENT
```


![Connecteurs Natifs (Accès Natifs)](https://doc.pcsoft.fr/ext/images/fr/AN.png)  DECODE n'est pas géré par SQL Server, MySQL, Progress, Informix, DB2, Sybase et ACCESS.
<a name="SQL_CASE"></a>


### CASE
<a name="case_ELTPARAGRAPHE002500"></a>La fonction **CASE** permet d'obtenir le fonctionnement d'une instruction SI .. ALORS .. SINON.

**Format d'utilisation** :

```txt
CASE Nom_Colonne WHEN Valeur comparée 1 THEN Valeur retournée 1 [WHEN Valeur comparée 2 THEN ...
		Valeur retournée 2][ELSE Valeur retournée par défaut] END
```



```txt
CASE WHEN Condition 1 THEN Valeur retournée 1 [WHEN Condition 2 THEN Valeur retournée 2] ...
		[ELSE Valeur retournée par défaut] END
```


**Exemple** : Si la rubrique correspond à "3" renvoie "trois", à "4" renvoie "quatre" et renvoie "autre" dans les autres cas : 

```sql
SELECT rubInt, CASE rubInt WHEN 3 THEN 'trois' WHEN 4 THEN 'quatre' ELSE 'autre' END
```



```sql
SELECT rubInt, CASE WHEN rubInt=3 THEN 'trois' WHEN rubInt=4 THEN 'quatre' ELSE 'autre' END
```

<a name="SQL_MATCH AGAINST"></a>


### MATCH AGAINST
<a name="match_against_ELTPARAGRAPHE002517"></a>La fonction **MATCH AGAINST** permet d'obtenir l'indice de pertinence de l'enregistrement lors d'une recherche full-text.

**Format d'utilisation** :

```txt
MATCH(Liste des rubriques) AGAINST [ALL] Valeur
```


Où : 

- **Liste des rubriques** correspond à la liste des rubriques de l'index séparées par des virgules (l'ordre des rubriques n'est pas important)

- **Valeur** correspond à la valeur recherchée dans les différentes rubriques. Ce paramètre peut correspondre à une valeur littérale ou à un nom de paramètre. La valeur de recherche peut contenir les éléments suivants :





|   |   |
| --- | --- |
| **Elément** | **Signification** |
| Un mot tout seul | Le mot indiqué sera recherché. La pertinence sera augmentée si le texte contient ce mot.<br><br>Exemple : "WINDEV" recherche le mot "WINDEV". |
| Deux mots séparés par un espace | Recherche l'un ou l'autre des mots.<br><br>Exemple : "WINDEV WEBDEV" recherche les textes contenant soit "WINDEV" soit "WEBDEV". |
| Un mot précédé du signe "+" | Le mot indiqué est obligatoire.<br><br>Exemple : "+WINDEV" recherche les textes contenant obligatoirement "WINDEV". |
| Un mot précédé du signe "-" | Le mot indiqué ne doit pas être présent dans le texte.<br><br>Exemple : "-Index" recherche les textes ne contenant pas "Index". |
| Un mot précédé du signe "~" | Si le texte contient le mot indiqué, la pertinence sera diminuée. |
| Un ou plusieurs mots entourés de guillemets | Les mots indiqués sont recherchés groupés et dans l'ordre.<br><br>Attention : si l'option "Ignorer les mots inférieurs à " est différente de 0, les mots entre les guillemets inférieurs à la taille précisée ne seront pas recherchés. |
| Un mot suivi du signe "\*" | La recherche est une recherche du type "Commence par" le mot indiqué. |

[ALL] permet de forcer le remplacement des espaces par des "+" dans la valeur recherchée.

**Exemple** : Dans cet exemple, SAI_Rechercher est un champ de saisie et IdUserConnecté est une variable.

```wl
MaRequête est une chaîne = [
SELECT * FROM Contact
WHERE MATCH(Contact.Nom, Contact.Prenom, Contact.CommentaireHTML, 
Contact.CommentaireTexteBrut, Contact.Commentaires, Contact.Telephone, Contact.Bureau, 
Contact.Portable, Contact.Mail, Contact.MSN, Contact.Site_internet, Contact.Pays,
		Contact.NumFax, Contact.Ville)
AGAINST ('
]
MaRequête = MaRequête + SAI_Rechercher + [
')	
AND Contact.IDUtilisateur =	
]
MaRequête = MaRequête + IdUserConnecté + [
ORDER BY Nom DESC
]

HExécuteRequêteSQL(REQ_RECH, hRequêteDéfaut, MaRequête)
POUR TOUT REQ_RECH
	TableAjouteLigne(TABLE_Contact_par_catégorie, ...
	REQ_RECH.idcontact,REQ_RECH.IDCategorie, IdUserConnecté, ...
	REQ_RECH.Nom, REQ_RECH.Prenom) 
FIN
CAS ERREUR: 
	Erreur(HErreurInfo())
```
Pour plus de détails sur la recherche full-text, consultez [Recherche et index full-text](../WDLang4/3044375.md).
<a name="SQL_MD5"></a>
**MD5**
La fonction **MD5** calcule la somme de vérification MD5 de la chaîne passée en paramètre. La valeur retournée est un entier hexadécimal de 32 caractères qui peut être utilisé par exemple comme clé de hachage. 

**Format d'utilisation** :

```txt
MD5(Chaîne)
```

<a name="SQL_SHA"></a>
**SHA et SHA1**
Les fonctions SHA et SHA1 calculent la somme de vérification SHA1 160 bits de la chaîne passée en paramètres selon la norme RFC 3174 (Secure Hash Algorithm). La valeur retournée est une chaîne hexadécimale de 40 caractères ou bien NULL si l'argument est NULL. Une des possibilités d'utilisation de cette fonction est le hachage de clé. 

**Format d'utilisation** :

```txt
SHA(Chaîne)

SHA1(Chaîne)
```

<a name="SQL_REGEXP"></a>
**REGEXP** ou **RLIKE** ou **~** ou **REGEXP_LIKE**


Le but des fonctions **REGEXP** ou **RLIKE** ou **~** ou **REGEXP_LIKE** est d'évaluer une expression régulière au sein d'une requête SQL.

**Format d'utilisation** :

```txt
chaîne REGEXP expression
```



```txt
chaîne RLIKE expression
```



```txt
chaîne ~ expression
```



```txt
REGEXP_LIKE(chaîne, expression)
```
où : 

- chaîne correspond à la chaîne que l'on souhaite évaluer.

- expression correspond à l'expression régulière.




Le résultat de la fonction est un booléen : 

- <u><u><u><u>Vrai</u></u></u></u> si la chaîne correspond à l'expression régulière.

- <u><u><u><u>Faux</u></u></u></u> si ce n'est pas le cas.




**Remarque** : Dans une expression régulière, le caractère "\\" permet de spécifier une mise en forme particulière. Ainsi "\\r" correspond à un retour chariot, "\\n" à un retour à la ligne...

**Exemples** : Dans ces exemples, la chaîne 'abcde' est comparée à une expression régulière.

```wl
sRequete = "SELECT 'abcde' REGEXP 'a[bcd]{3}e' AS result"
REQ est une Source de Données
HExécuteRequêteSQL(REQ, hRequêteDéfaut, sRequete)
HLitPremier(REQ)
soit bResult = REQ.result
// bResult vaut vrai
```



```wl
sRequete = "SELECT 'abcde' REGEXP 'a[bcd]{2}e' AS result"
HExécuteRequêteSQL(REQ, hRequêteDéfaut, sRequete)
HLitPremier(REQ)
bResult = REQ.result
// bResult vaut faux
```

<a name="SQL_BITS"></a>


### Opérateurs et fonctions sur les bits
<a name="operateurs_fonctions_sur_les_bits_ELTPARAGRAPHE002660"></a>Les opérateurs permettant de manipuler les bits sont les suivants : 

- & 

- | 

- ^ 

- ~ 

- &lt;&lt; 

- &gt;&gt;




Les fonctions correspondantes sont les suivantes : 

- BITAND, 

- BITOR, 

- BITXOR, 

- BITNOT,

- BITANDNOT.




Exemple : 

```wl
sdReq est une Source de Données
sSQL est chaîne = [
SELECT 
	1 | 2 AS op_or,						-- 3
	BITOR(1, 2) AS fct_or,					-- 3
	3 & 6 AS op_and,						-- 2
	BITAND(3, 6) AS fct_and,					-- 2
	~CAST(240 AS TINYINT) AS op_not,				-- 15
	BITNOT(CAST(240 AS TINYINT)) AS fct_not,			-- 15
	5 ^ 6 AS op_xor,						-- 3
	BITXOR(5, 6) AS fct_xor,					-- 3
	BITANDNOT(3,1) AS fct_andnot,				-- 2
	1 << 2 AS sl,							-- 4
	16 >> 2 AS sr							-- 4
]

HExécuteRequêteSQL(sdReq, sSQL)

Trace("attendu:")
Trace("3 - 3 - 2 - 2 - 15 - 15 - 3 - 3 - 2 - 4 - 4")
Trace("obtenu:")
POUR TOUT sdReq
	Trace(Remplace(HEnregistrementVersChaîne(sdReq), TAB, " - "))
FIN
```

<a name="SQL_ISJSON"></a>


### IS JSON XXX
<a name="json_xxx_ELTPARAGRAPHE002687"></a>

Les commandes "IS JSON xxx" permettent de savoir si une rubrique est :

- un contenu JSON (IS JSON),

- un contenu JSON représentant un objet (IS JSON OBJECT),

- un contenu JSON représentant un tableau (IS JSON ARRAY),

- ...




**Format d'utilisation** :

```txt
IS [NOT] JSON [OBJECT|ARRAY|SCALAR|VALUE] (expression)
```
La valeur renvoyée est 1 si l'expression contient des données valides, 0 dans le cas contraire. 

Exemple :

```sql
SELECT
	Produit.Caractéristiques IS JSON AS RubriqueISJSON,
	Produit.Caractéristiques IS JSON OBJECT AS RubriqueISJSONOBJECT,
	Produit.Caractéristiques IS JSON ARRAY AS RubriqueISJSONARRAY,
	Produit.Caractéristiques IS JSON SCALAR AS RubriqueISJSONSCALAR,
	Produit.Caractéristiques IS JSON VALUE AS RubriqueISJSONVALUE
FROM
	Produit
```

<a name="SQL_JSONVALUE"></a>


### JSON_VALUE
<a name="jsonvalue_ELTPARAGRAPHE002708"></a>La commande SQL "JSON_VALUE" permet de récupérer la valeur d'un élément contenu dans la rubrique JSON.
**Format d'utilisation** :

```txt
JSON_VALUE(expression, chemin)
```
 où : 

- expression correspond à une variable contenant du texte JSON

- chemin correspond à la propriété à extraire. 




Exemple :

```sql
SELECT
	Produit.Reference,
	Produit.Libellé,
	Produit.Caractéristiques,
	JSON_VALUE(Produit.Caractéristiques, 
		'$.marque' DEFAULT 'aucune marque' ON ERROR) AS Marque
FROM
	Produit
```

<a name="SQL_JSONQUERY"></a>


### JSON_QUERY
<a name="jsonquery_ELTPARAGRAPHE002728"></a>La commande SQL "JSON_QUERY" permet de récupérer un objet ou un tableau au format JSON.
**Format d'utilisation** :

```txt
JSON_QUERY(expression, chemin)
```
 où : 

- expression correspond à une variable contenant du JSON

- chemin spécifie l’objet ou le tableau à extraire. 




Exemple : 

```sql
SELECT
	Produit.Reference,
	Produit.Libellé,
	Produit.Caractéristiques,
	JSON_QUERY(Produit.Caractéristiques, '$.couleurs' ) AS Couleurs
FROM
	Produit
```

<a name="SQL_JSONEXISTS"></a>


### JSON_EXISTS
<a name="jsonexists_ELTPARAGRAPHE002747"></a>La commande SQL "JSON_EXISTS" permet de récupérer les enregistrements dont la rubrique JSON contient une donnée. 

**Format d'utilisation** :

```txt
JSON_EXISTS(expression, filtre)
```
 où : 

- expression correspond à une variable contenant du JSON

- filtre correspond aux données à extraire. 




Exemple : 

```sql
SELECT
	Produit.Reference,
	Produit.Libellé,
	Produit.Caractéristiques
FROM
	Produit
WHERE
	JSON_EXISTS(Produit.Caractéristiques, '$.talon?(@ == true)')
```

<a name="SQL_JSONOBJECT"></a>


### JSON_OBJECT
<a name="jsonobject_ELTPARAGRAPHE002767"></a>La commande SQL "JSON_OBJECT" permet de récupérer un objet JSON à partir de n'importe quelle rubrique. Le contenu JSON récupéré correspond à un objet. 

Exemple : 
```sql
SELECT
Contact.IDContact,
JSON_OBJECT('NomComplet' : Contact.nom+' '+Contact.prenom, 
		'Adresse' : Adresse+' '+CodePostal+' '+ville+' '+pays) 
		AS ContenuJSON
FROM
	Contact
WHERE
	IDContact <= 3
```





<a name="SQL_JSONOBJECTAGG"></a>


### JSON_OBJECTAGG
<a name="jsonobjectagg_ELTPARAGRAPHE002780"></a>La commande SQL "JSON_OBJECTAGG" permet de récupérer un objet JSON contenant une paire "clé:valeur" pour chaque clé et valeur spécifiques dans un ensemble de valeurs SQL.

Exemple : 
```sql
SELECT
JSON_OBJECTAGG(Contact.nom+' '+Contact.prenom VALUE Adresse+' '+
		CodePostal+' '+ville+' '+pays) AS ContenuJSON
FROM
	Contact
WHERE
	IDContact <= 3
```

<a name="SQL_JSONARRAY"></a>


### JSON_ARRAY
<a name="jsonarray_ELTPARAGRAPHE002792"></a>La commande SQL "JSON_ARRAY" permet de récupérer un tableau JSON à partir de n'importe quelle rubrique. Le contenu JSON récupéré correspond à un tableau ( [ xxx,...] ). 

Exemple : 
```sql
SELECT
Contact.IDContact,
JSON_ARRAY(Contact.nom+' '+Contact.prenom) AS ContenuJSON
FROM
	Contact
WHERE
	IDContact <= 3
```

<a name="SQL_JSONARRAYAGG"></a>


### JSON_ARRAYAGG
<a name="jsonarrayagg_ELTPARAGRAPHE002807"></a>La commande SQL "JSON_ARRAYAGG" permet de récupérer un tableau JSON contenant une paire "clé:valeur" pour chaque clé et valeur spécifiques dans un ensemble de valeurs SQL. Le contenu JSON récupéré correspond à un tableau ( [ xxx,...] ). 

Exemple : 
```sql
SELECT pays, 
JSON_ARRAYAGG(client.nom) 
FROM client 
GROUP BY pays -> [ "romaric", "bob", "joe" ]
```





