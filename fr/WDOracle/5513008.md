
## Connecteur Natif Oracle : Récupérer la valeur de sortie d'une procédure stockée
			



<a name="NOTE1"></a>
<a name="NOTE1_1"></a>


## Présentation
<a name="presentation_ELTTEXTE000242"></a>
Le Connecteur Natif Oracle (également appelé Accès Natif Oracle) permet de :

- spécifier des valeurs d'entrées lors de l'appel à une procédure stockée.

- récupérer des valeurs de sorties après l'appel d'une procédure stockée.




**Remarques** : 

- Il est également possible d'utiliser des variables dans tout type de requête.

- Les fonctions et procédures renvoyant un curseur peuvent également être exécutées.




**Si la requête doit être exécutée plusieurs fois**, il est possible de préparer la requête à exécuter (fonction [HPrépareRequêteSQL](../WDLang4/3044119.md)) ainsi que les différents paramètres à modifier puis exécuter la requête autant de fois que nécessaire avec la fonction [HExécuteRequêteSQL](../WDLang4/3044084.md). Cette solution est rapide et optimise le temps de parcours du résultat de la requête (cas d'une requête de type SELECT).



<a name="NOTE2"></a>
<a name="NOTE2_1"></a>


## Comment le faire ?
<a name="comment_faire_ELTTEXTE000266"></a>


### Les étapes
<a name="les_etapes_ELTPARAGRAPHE000036"></a>Pour spécifier et récupérer des valeurs lors de l'exécution d'une requête, il faut :

1. Déclarer une source de données. Cette source de données contiendra le résultat de la requête SQL.

2. Déclarer les différentes variables de la requête (variables d'entrées et variables de sorties). 
	Les variables sont récupérées dans le type spécifié en WLangage. Par défaut les variables sont de type texte.
	Des conversions peuvent donc se produire du type natif de la base vers le type WLangage qui peuvent entraîner arrondis ou des formatages inattendus (par exemple une Date transformée en chaîne).
	Il est donc conseillé de spécifier de façon adéquate les types WLangage des variables avant d'exécuter la requête. Ceci est peut être fait :

	- soit en initialisant la valeur de la variables (types simples : entier, chaîne, flottant)

	- soit en spécifiant le type attendu grâce à la propriété [Type](../Proprietes/2510131.md) (non supporté dans cette version)




3. Exécuter la requête à l'aide de la fonction [HExécuteRequêteSQL](../WDLang4/3044084.md).





<a name="NOTE2_2"></a>


### Remarques
<a name="remarques_ELTPARAGRAPHE000063"></a>

- La fonction [HExécuteRequêteSQL](../WDLang4/3044084.md) doit être utilisée avec :

	- le nom de la connexion,

	- la constante **hRequêteSansCorrection**. 




- Les variables déclarées doivent être identiques à celles utilisées. Dans le cas contraire, une erreur WLangage est affichée.

- Dans l'appel à la procédure stockée, il est nécessaire d'utiliser la syntaxe spécifique à la base de données utilisée, y compris pour la syntaxe des paramètres. Ainsi, pour Oracle, les paramètres sont spécifiés avec la syntaxe **:NomParam**. Attention : le caractère ":" doit être suivi d'au moins une lettre (la syntaxe :1 est interdite). 
	Il est possible d'utiliser plusieurs fois le même paramètre. Dans ce cas, la variable correspondante sera ré-utilisée.

- Pour exécuter une requête sans que le bind ne soit activé, utiliser la constante ***hSansBind*** dans la fonction [HExécuteRequêteSQL](../WDLang4/3044084.md).  






<a name="NOTE3"></a>
<a name="NOTE3_1"></a>


## Exemple
<a name="exemple_ELTTEXTE000296"></a>
La procédure stockée **'sp_cut(n,str)**' tronque la chaîne 'str' aux 'n' premiers caractères et renvoie l'ancienne longueur de chaîne.

- **n** est une variable d'entrée.

- **str** est une variable d'entrée / sortie.





<a name="NOTE3_2"></a>


### 1. Déclaration de la source de données
<a name="1_declaration_source_donnees_ELTPARAGRAPHE000096"></a>La source de données permet de manipuler les différentes variables de la procédure à exécuter.


```wl
MaProc est une Source de Données
```



<a name="NOTE3_3"></a>


### 2. Déclaration des variables utilisées par la procédure
<a name="2_declaration_des_variables_utilisees_par_procedure_ELTPARAGRAPHE000106"></a>La déclaration des variables manipulées par la procédure se fait à partir de la source de données.


```wl
MaProc.n = 3 // Déclare automatiquement un entier initialisé à 3
MaProc.str = "Exemple"
```


**Remarque** :  Il n'est pas obligatoire de déclarer toutes les variables utilisées. Dans cet exemple, la variable utilisée pour connaître le résultat de la procédure n'est pas déclarée.


<a name="NOTE3_4"></a>


### 3. Exécution de la requête et récupération du résultat
<a name="3_execution_requete_recuperation_resultat_ELTPARAGRAPHE000118"></a>Pour exécuter la requête, il suffit d'utiliser la fonction [HExécuteRequêteSQL](../WDLang4/3044084.md) :


```wl
HExécuteRequêteSQL(MaProc, Connexion, hRequêteSansCorrection, "begin :Res :=sp_cut(:n,:str);end;")
Info(MaProc.Res)
```


Après l'exécution de la requête, la variable MaProc.str contient "exe", et la variable MaProc.res contient 7.



<a name="NOTE4"></a>
<a name="NOTE4_1"></a>


## Fonctions et procédures renvoyant un curseur
<a name="fonctions_procedures_renvoyant_curseur_ELTTEXTE000338"></a>


### Principe
<a name="principe_ELTPARAGRAPHE000136"></a>Si la requête ne renvoie pas de 'resultset', mais si l'un de ses paramètres est un curseur (la valeur de retour est traitée comme un paramètre OUT), alors le curseur est parcouru comme si c'était le résultat de le requête. 

Remarques : 

- La fonction [HPrépareRequêteSQL](../WDLang4/3044119.md) ne permet pas d'initialiser le parcours du curseur. Il faut appeler directement la fonction [HExécuteRequêteSQL](../WDLang4/3044084.md). 

- Le nom du paramètre de type curseur ou de la valeur de retour de type curseur doit être postfixé par "%CURSOR" pour que le Connecteur Natif effectue un bind d'un paramètre de type curseur. 





<a name="NOTE4_2"></a>


### Exemple : Fonction renvoyant un curseur
<a name="exemple_fonction_renvoyant_curseur_ELTPARAGRAPHE000155"></a>

- Création de la table source des données : 
	
	```txt
	CREATE TABLE frm_user(user_nom      VARCHAR2(20));
	INSERT INTO frm_user VALUES ('toto');
	INSERT INTO frm_user VALUES ('titi');
	INSERT INTO frm_user VALUES ('tutu');
	COMMIT;
	```





- Fonction renvoyant un curseur : 
	
	```txt
	CREATE OR REPLACE FUNCTION affiche_user 
	RETURN SYS_REFCURSOR AS
		vRefCursor	SYS_REFCURSOR;
	begin
		OPEN vRefCursor FOR
		SELECT user_nom, upper(user_nom) FROM frm_user;
		RETURN vRefCursor;
	end;
	```





- Code WLangage permettant d'exécuter la fonction et de parcourir le résultat : 
	
	```wl
	maProcedure est une Source de Données
	SI PAS HExécuteRequêteSQL(maProcedure, connexionOracle, hRequêteSansCorrection, ...
				"begin :return_value%CURSOR := affiche_user(); end;") ALORS
		Erreur("Erreur sur HExécuteRequêteSQL", "", HErreurInfo(hErrComplet))
		RETOUR
	SINON
		POUR TOUT maProcedure 
			Trace(HEnregistrementVersChaîne(maProcedure))
		FIN
	FIN
	```

	La trace contient :
	
	```txt
	toto
	titi
	tutu
	```






<a name="NOTE4_3"></a>


### Exemple : Procédure avec un paramètre de type curseur
<a name="exemple_procedure_avec_parametre_type_curseur_ELTPARAGRAPHE000177"></a>

- Création de la table source des données : 
	
	```txt
	CREATE TABLE frm_user(user_nom VARCHAR2(20));
	INSERT INTO frm_user VALUES ('toto');
	INSERT INTO frm_user VALUES ('titi');
	INSERT INTO frm_user VALUES ('tutu');
	COMMIT;
	```





- Procédure avec un paramètre de type curseur : 
	
	```txt
	CREATE OR REPLACE PROCEDURE Proc_affiche_user(O_RESULT_SET OUT SYS_REFCURSOR)
	  AS
	  BEGIN
	    OPEN O_RESULT_SET FOR
	    SELECT user_nom, upper(user_nom) FROM frm_user;
	  END;
	```





- Code WLangage permettant d'exécuter la procédure et de parcourir le résultat : 
	
	```wl
	maProcedure est une Source de Données
	SI PAS HExécuteRequêteSQL(maProcedure, connexionOracle, hRequêteSansCorrection, ...
					"begin Proc_affiche_user(:return_value%CURSOR); end;") ALORS
		Erreur("Erreur sur HExécuteRequêteSQL", "", HErreurInfo(hErrComplet))
		RETOUR
	SINON
		POUR TOUT maProcedure 
			Trace(HEnregistrementVersChaîne(maProcedure))
		FIN
	FIN
	```

	La trace contient : 
	
	```txt
	toto
	titi
	tutu
	```










